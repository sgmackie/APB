; Listing generated by Microsoft (R) Optimizing Compiler Version 19.11.25507.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG7955	DB	'sound_file_gain: Change amplitude of input file', 0aH, 00H
	ORG $+15
$SG7957	DB	'Error: Insufficient number of arguments', 0aH, 'Usage: s'
	DB	'ound_file_gain.exe, input file, output file, buffer size, amp'
	DB	'litude', 0aH, 00H
	ORG $+3
$SG7959	DB	'Error: Unable to start portsf', 0aH, 00H
	ORG $+1
$SG7961	DB	'Error: Unable to open input file %s', 0aH, 00H
	ORG $+3
$SG7963	DB	'Error: Buffer size must be at least 1', 0aH, 00H
	ORG $+1
$SG7965	DB	'Error: Amplitdue factor must be greater than 0', 0aH, 00H
$SG7967	DB	'Error: Unable to create output file %s', 0aH, 00H
$SG7969	DB	'Error: No memory', 0aH, 00H
	ORG $+6
$SG7971	DB	'Error: No memory', 0aH, 00H
	ORG $+6
$SG7972	DB	'Info: Copying...', 0aH, 00H
	ORG $+6
$SG7974	DB	'Info: Copying %ld samples...', 0dH, 00H
	ORG $+2
$SG7976	DB	'Error: Cannot write to ouput file %s', 0aH, 00H
	ORG $+2
$SG7979	DB	'Error: Cannot read input file %s, output file %s is inco'
	DB	'mplete', 0aH, 00H
$SG7980	DB	0aH, 'Info: Done.', 0aH, 'Info: %d sample frames copied t'
	DB	'o %s', 0aH, 00H
	ORG $+6
$SG7982	DB	'Info: Peaks:', 0aH, 00H
	ORG $+2
$SG7983	DB	'Channel %d:', 09H, '%.4f (%.4f dB) at %.4f seconds', 0aH
	DB	00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	fprintf
PUBLIC	printf
PUBLIC	main
EXTRN	__acrt_iob_func:PROC
EXTRN	puts:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	free:PROC
EXTRN	malloc:PROC
EXTRN	atof:PROC
EXTRN	atoi:PROC
EXTRN	log10:PROC
EXTRN	psf_init:PROC
EXTRN	psf_finish:PROC
EXTRN	psf_sndCreate:PROC
EXTRN	psf_sndOpen:PROC
EXTRN	psf_sndClose:PROC
EXTRN	psf_sndWriteFloatFrames:PROC
EXTRN	psf_sndReadFloatFrames:PROC
EXTRN	psf_sndReadPeaks:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$fprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$printf
pdata	ENDS
pdata	SEGMENT
$pdata$main DD	imagerel $LN28
	DD	imagerel $LN28+1490
	DD	imagerel $unwind$main
pdata	ENDS
xdata	SEGMENT
$unwind$main DD	022219H
	DD	01b0110H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\chapter_2\2.2.1\code\sound_file_gain.c
_TEXT	SEGMENT
ErrorCode$ = 48
i$1 = 52
InputFile$ = 56
OutputFile$ = 60
i$2 = 64
BufferSize$ = 68
FramesRead_Total$ = 72
Buffer$ = 80
OutputFile_Peaks$ = 88
j$3 = 96
FramesRead$ = 100
AmplitudeFactor$ = 104
tv84 = 112
tv151 = 120
tv206 = 128
tv219 = 136
tv222 = 144
PeakTime$4 = 152
PeakDB$5 = 160
FileProperties$ = 168
__$ArrayPad$ = 192
argc$ = 224
argv$ = 232
main	PROC

; 9    : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 10   :     //Variable declarations
; 11   :     PSF_PROPS FileProperties; //File properties struct from portsf
; 12   :     DWORD BufferSize; //Unsigned int, buffer size cannot be a negative number
; 13   :     long FramesRead, FramesRead_Total;
; 14   :     float AmplitudeFactor;
; 15   : 
; 16   :     int InputFile = -1;

  00022	c7 44 24 38 ff
	ff ff ff	 mov	 DWORD PTR InputFile$[rsp], -1

; 17   :     int OutputFile = -1;

  0002a	c7 44 24 3c ff
	ff ff ff	 mov	 DWORD PTR OutputFile$[rsp], -1

; 18   :     int ErrorCode = 0;

  00032	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR ErrorCode$[rsp], 0

; 19   :     PSF_CHPEAK *OutputFile_Peaks = NULL; //Peak data struct from portsf

  0003a	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR OutputFile_Peaks$[rsp], 0

; 20   :     float *Buffer = NULL;

  00043	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR Buffer$[rsp], 0

; 21   : 
; 22   :     printf("sound_file_gain: Change amplitude of input file\n");

  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7955
  00053	e8 00 00 00 00	 call	 printf

; 23   : 
; 24   :     //Check number of arguments provided by user
; 25   :     if(argc < ARG_NUM_ARGS)

  00058	83 bc 24 e0 00
	00 00 05	 cmp	 DWORD PTR argc$[rsp], 5
  00060	7d 23		 jge	 SHORT $LN10@main

; 26   :     {
; 27   :         fprintf(stderr, "Error: Insufficient number of arguments\n"

  00062	b9 02 00 00 00	 mov	 ecx, 2
  00067	e8 00 00 00 00	 call	 __acrt_iob_func
  0006c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7957
  00073	48 8b c8	 mov	 rcx, rax
  00076	e8 00 00 00 00	 call	 fprintf

; 28   :                         "Usage: sound_file_gain.exe, input file, output file, buffer size, amplitude\n");
; 29   :         return 1;

  0007b	b8 01 00 00 00	 mov	 eax, 1
  00080	e9 35 05 00 00	 jmp	 $LN1@main
$LN10@main:

; 30   :     }
; 31   : 
; 32   :     //Start portsf library
; 33   :     if(psf_init())

  00085	e8 00 00 00 00	 call	 psf_init
  0008a	85 c0		 test	 eax, eax
  0008c	74 23		 je	 SHORT $LN11@main

; 34   :     {
; 35   :         fprintf(stderr, "Error: Unable to start portsf\n");

  0008e	b9 02 00 00 00	 mov	 ecx, 2
  00093	e8 00 00 00 00	 call	 __acrt_iob_func
  00098	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7959
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	e8 00 00 00 00	 call	 fprintf

; 36   :         return 1;

  000a7	b8 01 00 00 00	 mov	 eax, 1
  000ac	e9 09 05 00 00	 jmp	 $LN1@main
$LN11@main:

; 37   :     }
; 38   :     
; 39   :     //Open user input file
; 40   :     InputFile = psf_sndOpen(argv[ARG_INFILE], &FileProperties, 0);

  000b1	b8 08 00 00 00	 mov	 eax, 8
  000b6	48 6b c0 01	 imul	 rax, rax, 1
  000ba	45 33 c0	 xor	 r8d, r8d
  000bd	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR FileProperties$[rsp]
  000c5	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000cd	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  000d1	e8 00 00 00 00	 call	 psf_sndOpen
  000d6	89 44 24 38	 mov	 DWORD PTR InputFile$[rsp], eax

; 41   : 
; 42   :     if(InputFile < 0)

  000da	83 7c 24 38 00	 cmp	 DWORD PTR InputFile$[rsp], 0
  000df	7d 42		 jge	 SHORT $LN12@main

; 43   :     {
; 44   :         fprintf(stderr, "Error: Unable to open input file %s\n", argv[ARG_NAME]);

  000e1	b8 08 00 00 00	 mov	 eax, 8
  000e6	48 6b c0 00	 imul	 rax, rax, 0
  000ea	48 89 44 24 70	 mov	 QWORD PTR tv84[rsp], rax
  000ef	b9 02 00 00 00	 mov	 ecx, 2
  000f4	e8 00 00 00 00	 call	 __acrt_iob_func
  000f9	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00101	48 8b 54 24 70	 mov	 rdx, QWORD PTR tv84[rsp]
  00106	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  0010a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7961
  00111	48 8b c8	 mov	 rcx, rax
  00114	e8 00 00 00 00	 call	 fprintf

; 45   :         return 1;

  00119	b8 01 00 00 00	 mov	 eax, 1
  0011e	e9 97 04 00 00	 jmp	 $LN1@main
$LN12@main:

; 46   :     }
; 47   : 
; 48   :     //Create buffer 'chunk' size from user argument
; 49   :     BufferSize = (DWORD) atoi(argv[ARG_BUFFER_SIZE]);

  00123	b8 08 00 00 00	 mov	 eax, 8
  00128	48 6b c0 03	 imul	 rax, rax, 3
  0012c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00134	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00138	e8 00 00 00 00	 call	 atoi
  0013d	89 44 24 44	 mov	 DWORD PTR BufferSize$[rsp], eax

; 50   :     
; 51   :     if(BufferSize < 1)

  00141	83 7c 24 44 01	 cmp	 DWORD PTR BufferSize$[rsp], 1
  00146	73 23		 jae	 SHORT $LN13@main

; 52   :     {
; 53   :         fprintf(stderr, "Error: Buffer size must be at least 1\n");

  00148	b9 02 00 00 00	 mov	 ecx, 2
  0014d	e8 00 00 00 00	 call	 __acrt_iob_func
  00152	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7963
  00159	48 8b c8	 mov	 rcx, rax
  0015c	e8 00 00 00 00	 call	 fprintf

; 54   :         return 1;

  00161	b8 01 00 00 00	 mov	 eax, 1
  00166	e9 4f 04 00 00	 jmp	 $LN1@main
$LN13@main:

; 55   :     }
; 56   : 
; 57   :     //Assign amplitude from user argument
; 58   :     AmplitudeFactor = atof(argv[ARG_AMPLITUDE]);

  0016b	b8 08 00 00 00	 mov	 eax, 8
  00170	48 6b c0 04	 imul	 rax, rax, 4
  00174	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0017c	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00180	e8 00 00 00 00	 call	 atof
  00185	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00189	f3 0f 11 44 24
	68		 movss	 DWORD PTR AmplitudeFactor$[rsp], xmm0

; 59   :     
; 60   :     if(AmplitudeFactor <= 0)

  0018f	0f 57 c0	 xorps	 xmm0, xmm0
  00192	0f 2f 44 24 68	 comiss	 xmm0, DWORD PTR AmplitudeFactor$[rsp]
  00197	72 23		 jb	 SHORT $LN14@main

; 61   :     {
; 62   :         fprintf(stderr, "Error: Amplitdue factor must be greater than 0\n");

  00199	b9 02 00 00 00	 mov	 ecx, 2
  0019e	e8 00 00 00 00	 call	 __acrt_iob_func
  001a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7965
  001aa	48 8b c8	 mov	 rcx, rax
  001ad	e8 00 00 00 00	 call	 fprintf

; 63   :         return 1;

  001b2	b8 01 00 00 00	 mov	 eax, 1
  001b7	e9 fe 03 00 00	 jmp	 $LN1@main
$LN14@main:

; 64   :     }
; 65   : 
; 66   :     //Create output file for for reading/writing
; 67   :     OutputFile = psf_sndCreate(argv[ARG_OUTFILE], &FileProperties, 0, 0, PSF_CREATE_RDWR);

  001bc	b8 08 00 00 00	 mov	 eax, 8
  001c1	48 6b c0 02	 imul	 rax, rax, 2
  001c5	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  001cd	45 33 c9	 xor	 r9d, r9d
  001d0	45 33 c0	 xor	 r8d, r8d
  001d3	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR FileProperties$[rsp]
  001db	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001e3	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  001e7	e8 00 00 00 00	 call	 psf_sndCreate
  001ec	89 44 24 3c	 mov	 DWORD PTR OutputFile$[rsp], eax

; 68   : 
; 69   :     if(OutputFile < 0)

  001f0	83 7c 24 3c 00	 cmp	 DWORD PTR OutputFile$[rsp], 0
  001f5	7d 47		 jge	 SHORT $LN15@main

; 70   :     {
; 71   :         fprintf(stderr, "Error: Unable to create output file %s\n", argv[ARG_OUTFILE]);

  001f7	b8 08 00 00 00	 mov	 eax, 8
  001fc	48 6b c0 02	 imul	 rax, rax, 2
  00200	48 89 44 24 78	 mov	 QWORD PTR tv151[rsp], rax
  00205	b9 02 00 00 00	 mov	 ecx, 2
  0020a	e8 00 00 00 00	 call	 __acrt_iob_func
  0020f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00217	48 8b 54 24 78	 mov	 rdx, QWORD PTR tv151[rsp]
  0021c	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  00220	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7967
  00227	48 8b c8	 mov	 rcx, rax
  0022a	e8 00 00 00 00	 call	 fprintf

; 72   :         ErrorCode++;

  0022f	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  00233	ff c0		 inc	 eax
  00235	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 73   :         goto memory_cleanup;

  00239	e9 2f 03 00 00	 jmp	 $memory_cleanup$29
$LN15@main:

; 74   :     }
; 75   : 
; 76   :     //Allocate memory for buffer according to number of channels in input file and the buffer size
; 77   :     Buffer = (float*) malloc(BufferSize * FileProperties.chans * sizeof(float));

  0023e	8b 44 24 44	 mov	 eax, DWORD PTR BufferSize$[rsp]
  00242	0f af 84 24 ac
	00 00 00	 imul	 eax, DWORD PTR FileProperties$[rsp+4]
  0024a	8b c0		 mov	 eax, eax
  0024c	48 c1 e0 02	 shl	 rax, 2
  00250	48 8b c8	 mov	 rcx, rax
  00253	e8 00 00 00 00	 call	 malloc
  00258	48 89 44 24 50	 mov	 QWORD PTR Buffer$[rsp], rax

; 78   : 
; 79   :     if(Buffer == NULL)

  0025d	48 83 7c 24 50
	00		 cmp	 QWORD PTR Buffer$[rsp], 0
  00263	75 1b		 jne	 SHORT $LN16@main

; 80   :     {
; 81   :         //Puts uses less system memory than printf, applicable for severe memory errors
; 82   :         puts("Error: No memory\n");

  00265	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7969
  0026c	e8 00 00 00 00	 call	 puts

; 83   :         ErrorCode++;

  00271	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  00275	ff c0		 inc	 eax
  00277	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 84   :         goto memory_cleanup;

  0027b	e9 ed 02 00 00	 jmp	 $memory_cleanup$29
$LN16@main:

; 85   :     }
; 86   : 
; 87   :     //Allocate memory for the peak data of the output file
; 88   :     OutputFile_Peaks = (PSF_CHPEAK*) malloc(FileProperties.chans * sizeof(PSF_CHPEAK));

  00280	48 63 84 24 ac
	00 00 00	 movsxd	 rax, DWORD PTR FileProperties$[rsp+4]
  00288	48 c1 e0 03	 shl	 rax, 3
  0028c	48 8b c8	 mov	 rcx, rax
  0028f	e8 00 00 00 00	 call	 malloc
  00294	48 89 44 24 58	 mov	 QWORD PTR OutputFile_Peaks$[rsp], rax

; 89   : 
; 90   :     if(OutputFile_Peaks == NULL)

  00299	48 83 7c 24 58
	00		 cmp	 QWORD PTR OutputFile_Peaks$[rsp], 0
  0029f	75 1b		 jne	 SHORT $LN17@main

; 91   :     {
; 92   :         puts("Error: No memory\n");

  002a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7971
  002a8	e8 00 00 00 00	 call	 puts

; 93   :         ErrorCode++;

  002ad	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  002b1	ff c0		 inc	 eax
  002b3	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 94   :         goto memory_cleanup;

  002b7	e9 b1 02 00 00	 jmp	 $memory_cleanup$29
$LN17@main:

; 95   :     }
; 96   : 
; 97   :     printf("Info: Copying...\n");

  002bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7972
  002c3	e8 00 00 00 00	 call	 printf

; 98   : 
; 99   :     //Call portsf function for reading input file frames according to the buffer
; 100  :     FramesRead = psf_sndReadFloatFrames(InputFile, Buffer, BufferSize);

  002c8	44 8b 44 24 44	 mov	 r8d, DWORD PTR BufferSize$[rsp]
  002cd	48 8b 54 24 50	 mov	 rdx, QWORD PTR Buffer$[rsp]
  002d2	8b 4c 24 38	 mov	 ecx, DWORD PTR InputFile$[rsp]
  002d6	e8 00 00 00 00	 call	 psf_sndReadFloatFrames
  002db	89 44 24 64	 mov	 DWORD PTR FramesRead$[rsp], eax

; 101  :     FramesRead_Total = 0;

  002df	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR FramesRead_Total$[rsp], 0
$LN2@main:

; 102  :     
; 103  :     //Loop while the portsf function returns 1
; 104  :     while(FramesRead == 1)

  002e7	83 7c 24 64 01	 cmp	 DWORD PTR FramesRead$[rsp], 1
  002ec	0f 85 03 01 00
	00		 jne	 $LN3@main

; 105  :     {
; 106  :         //Calculate total amount of frames read from the input file
; 107  :         FramesRead_Total++;

  002f2	8b 44 24 48	 mov	 eax, DWORD PTR FramesRead_Total$[rsp]
  002f6	ff c0		 inc	 eax
  002f8	89 44 24 48	 mov	 DWORD PTR FramesRead_Total$[rsp], eax

; 108  : 
; 109  :         //Counter declare
; 110  :         int j = 0;

  002fc	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR j$3[rsp], 0

; 111  :         j++;

  00304	8b 44 24 60	 mov	 eax, DWORD PTR j$3[rsp]
  00308	ff c0		 inc	 eax
  0030a	89 44 24 60	 mov	 DWORD PTR j$3[rsp], eax

; 112  : 
; 113  :         //Update progress for every 1000 samples
; 114  :         if(j % 1000 == 0)

  0030e	8b 44 24 60	 mov	 eax, DWORD PTR j$3[rsp]
  00312	99		 cdq
  00313	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00318	f7 f9		 idiv	 ecx
  0031a	8b c2		 mov	 eax, edx
  0031c	85 c0		 test	 eax, eax
  0031e	75 10		 jne	 SHORT $LN18@main

; 115  :         {
; 116  :             printf("Info: Copying %ld samples...\r", FramesRead_Total);

  00320	8b 54 24 48	 mov	 edx, DWORD PTR FramesRead_Total$[rsp]
  00324	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7974
  0032b	e8 00 00 00 00	 call	 printf
$LN18@main:

; 117  :         }
; 118  : 
; 119  :         for(int i = 0; i < FileProperties.chans; i++)

  00330	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  00338	eb 0a		 jmp	 SHORT $LN6@main
$LN4@main:
  0033a	8b 44 24 40	 mov	 eax, DWORD PTR i$2[rsp]
  0033e	ff c0		 inc	 eax
  00340	89 44 24 40	 mov	 DWORD PTR i$2[rsp], eax
$LN6@main:
  00344	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR FileProperties$[rsp+4]
  0034b	39 44 24 40	 cmp	 DWORD PTR i$2[rsp], eax
  0034f	7d 26		 jge	 SHORT $LN5@main

; 120  :         {
; 121  :             Buffer[i] *= AmplitudeFactor;

  00351	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$2[rsp]
  00356	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Buffer$[rsp]
  0035b	f3 0f 10 04 81	 movss	 xmm0, DWORD PTR [rcx+rax*4]
  00360	f3 0f 59 44 24
	68		 mulss	 xmm0, DWORD PTR AmplitudeFactor$[rsp]
  00366	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$2[rsp]
  0036b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Buffer$[rsp]
  00370	f3 0f 11 04 81	 movss	 DWORD PTR [rcx+rax*4], xmm0

; 122  :         }

  00375	eb c3		 jmp	 SHORT $LN4@main
$LN5@main:

; 123  : 
; 124  :         //Check for errors writing to the output file
; 125  :         if(psf_sndWriteFloatFrames(OutputFile, Buffer, BufferSize) != 1)

  00377	44 8b 44 24 44	 mov	 r8d, DWORD PTR BufferSize$[rsp]
  0037c	48 8b 54 24 50	 mov	 rdx, QWORD PTR Buffer$[rsp]
  00381	8b 4c 24 3c	 mov	 ecx, DWORD PTR OutputFile$[rsp]
  00385	e8 00 00 00 00	 call	 psf_sndWriteFloatFrames
  0038a	83 f8 01	 cmp	 eax, 1
  0038d	74 4a		 je	 SHORT $LN19@main

; 126  :         {
; 127  :             fprintf(stderr, "Error: Cannot write to ouput file %s\n", argv[ARG_OUTFILE]);

  0038f	b8 08 00 00 00	 mov	 eax, 8
  00394	48 6b c0 02	 imul	 rax, rax, 2
  00398	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv206[rsp], rax
  003a0	b9 02 00 00 00	 mov	 ecx, 2
  003a5	e8 00 00 00 00	 call	 __acrt_iob_func
  003aa	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  003b2	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR tv206[rsp]
  003ba	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  003be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7976
  003c5	48 8b c8	 mov	 rcx, rax
  003c8	e8 00 00 00 00	 call	 fprintf

; 128  :             ErrorCode++;

  003cd	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  003d1	ff c0		 inc	 eax
  003d3	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 129  :             break;

  003d7	eb 1c		 jmp	 SHORT $LN3@main
$LN19@main:

; 130  :         }
; 131  : 
; 132  :         FramesRead = psf_sndReadFloatFrames(InputFile, Buffer, BufferSize);

  003d9	44 8b 44 24 44	 mov	 r8d, DWORD PTR BufferSize$[rsp]
  003de	48 8b 54 24 50	 mov	 rdx, QWORD PTR Buffer$[rsp]
  003e3	8b 4c 24 38	 mov	 ecx, DWORD PTR InputFile$[rsp]
  003e7	e8 00 00 00 00	 call	 psf_sndReadFloatFrames
  003ec	89 44 24 64	 mov	 DWORD PTR FramesRead$[rsp], eax

; 133  :     }

  003f0	e9 f2 fe ff ff	 jmp	 $LN2@main
$LN3@main:

; 134  : 
; 135  :     if(FramesRead < 0)

  003f5	83 7c 24 64 00	 cmp	 DWORD PTR FramesRead$[rsp], 0
  003fa	7d 6f		 jge	 SHORT $LN20@main

; 136  :     {
; 137  :         fprintf(stderr, "Error: Cannot read input file %s, output file %s is incomplete\n", argv[ARG_INFILE], argv[ARG_OUTFILE]);

  003fc	b8 08 00 00 00	 mov	 eax, 8
  00401	48 6b c0 02	 imul	 rax, rax, 2
  00405	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv219[rsp], rax
  0040d	b9 08 00 00 00	 mov	 ecx, 8
  00412	48 6b c9 01	 imul	 rcx, rcx, 1
  00416	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR tv222[rsp], rcx
  0041e	b9 02 00 00 00	 mov	 ecx, 2
  00423	e8 00 00 00 00	 call	 __acrt_iob_func
  00428	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00430	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR tv219[rsp]
  00438	4c 8b 0c 11	 mov	 r9, QWORD PTR [rcx+rdx]
  0043c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00444	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tv222[rsp]
  0044c	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  00450	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7979
  00457	48 8b c8	 mov	 rcx, rax
  0045a	e8 00 00 00 00	 call	 fprintf

; 138  :         ErrorCode++;

  0045f	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  00463	ff c0		 inc	 eax
  00465	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 139  :     }

  00469	eb 25		 jmp	 SHORT $LN21@main
$LN20@main:

; 140  : 
; 141  :     else
; 142  :     {
; 143  :         printf("\nInfo: Done.\n"

  0046b	b8 08 00 00 00	 mov	 eax, 8
  00470	48 6b c0 02	 imul	 rax, rax, 2
  00474	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0047c	4c 8b 04 01	 mov	 r8, QWORD PTR [rcx+rax]
  00480	8b 54 24 48	 mov	 edx, DWORD PTR FramesRead_Total$[rsp]
  00484	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7980
  0048b	e8 00 00 00 00	 call	 printf
$LN21@main:

; 144  :                "Info: %d sample frames copied to %s\n", FramesRead_Total, argv[ARG_OUTFILE]);
; 145  :     }
; 146  : 
; 147  :     //Check if any peak data was captured
; 148  :     if(psf_sndReadPeaks(OutputFile, OutputFile_Peaks, NULL) > 0)

  00490	45 33 c0	 xor	 r8d, r8d
  00493	48 8b 54 24 58	 mov	 rdx, QWORD PTR OutputFile_Peaks$[rsp]
  00498	8b 4c 24 3c	 mov	 ecx, DWORD PTR OutputFile$[rsp]
  0049c	e8 00 00 00 00	 call	 psf_sndReadPeaks
  004a1	85 c0		 test	 eax, eax
  004a3	0f 8e c4 00 00
	00		 jle	 $LN22@main

; 149  :     {
; 150  :         double PeakTime;
; 151  :         double PeakDB;
; 152  :         printf("Info: Peaks:\n");

  004a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7982
  004b0	e8 00 00 00 00	 call	 printf

; 153  : 
; 154  :         //Loop for every channel in the input file
; 155  :         for (long i = 0; i < FileProperties.chans; i++)

  004b5	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  004bd	eb 0a		 jmp	 SHORT $LN9@main
$LN7@main:
  004bf	8b 44 24 34	 mov	 eax, DWORD PTR i$1[rsp]
  004c3	ff c0		 inc	 eax
  004c5	89 44 24 34	 mov	 DWORD PTR i$1[rsp], eax
$LN9@main:
  004c9	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR FileProperties$[rsp+4]
  004d0	39 44 24 34	 cmp	 DWORD PTR i$1[rsp], eax
  004d4	0f 8d 93 00 00
	00		 jge	 $LN8@main

; 156  :         {
; 157  :             PeakTime = (double) OutputFile_Peaks[i].pos / FileProperties.srate; //Calculate the time in seconds according the input file sample rate

  004da	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$1[rsp]
  004df	48 8b 4c 24 58	 mov	 rcx, QWORD PTR OutputFile_Peaks$[rsp]
  004e4	8b 44 c1 04	 mov	 eax, DWORD PTR [rcx+rax*8+4]
  004e8	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  004ed	f2 0f 2a 8c 24
	a8 00 00 00	 cvtsi2sd xmm1, DWORD PTR FileProperties$[rsp]
  004f6	f2 0f 5e c1	 divsd	 xmm0, xmm1
  004fa	f2 0f 11 84 24
	98 00 00 00	 movsd	 QWORD PTR PeakTime$4[rsp], xmm0

; 158  :             PeakDB = log10(OutputFile_Peaks[i].val); //Calculate dB values from linear values

  00503	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$1[rsp]
  00508	48 8b 4c 24 58	 mov	 rcx, QWORD PTR OutputFile_Peaks$[rsp]
  0050d	f3 0f 5a 04 c1	 cvtss2sd xmm0, DWORD PTR [rcx+rax*8]
  00512	e8 00 00 00 00	 call	 log10
  00517	f2 0f 11 84 24
	a0 00 00 00	 movsd	 QWORD PTR PeakDB$5[rsp], xmm0

; 159  :             printf("Channel %d:\t%.4f (%.4f dB) at %.4f seconds\n", i + 1, OutputFile_Peaks[i].val, PeakDB, PeakTime);

  00520	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$1[rsp]
  00525	48 8b 4c 24 58	 mov	 rcx, QWORD PTR OutputFile_Peaks$[rsp]
  0052a	f3 0f 5a 04 c1	 cvtss2sd xmm0, DWORD PTR [rcx+rax*8]
  0052f	8b 44 24 34	 mov	 eax, DWORD PTR i$1[rsp]
  00533	ff c0		 inc	 eax
  00535	f2 0f 10 8c 24
	98 00 00 00	 movsd	 xmm1, QWORD PTR PeakTime$4[rsp]
  0053e	f2 0f 11 4c 24
	20		 movsd	 QWORD PTR [rsp+32], xmm1
  00544	f2 0f 10 9c 24
	a0 00 00 00	 movsd	 xmm3, QWORD PTR PeakDB$5[rsp]
  0054d	66 49 0f 7e d9	 movq	 r9, xmm3
  00552	0f 28 d0	 movaps	 xmm2, xmm0
  00555	66 49 0f 7e d0	 movq	 r8, xmm2
  0055a	8b d0		 mov	 edx, eax
  0055c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7983
  00563	e8 00 00 00 00	 call	 printf

; 160  :         }

  00568	e9 52 ff ff ff	 jmp	 $LN7@main
$LN8@main:
$LN22@main:
$memory_cleanup$29:

; 161  :     }
; 162  : 
; 163  :     //Close all files and free all allocated memory
; 164  :     memory_cleanup:
; 165  : 
; 166  :     if(InputFile >= 0)

  0056d	83 7c 24 38 00	 cmp	 DWORD PTR InputFile$[rsp], 0
  00572	7c 09		 jl	 SHORT $LN23@main

; 167  :     {
; 168  :         psf_sndClose(InputFile);

  00574	8b 4c 24 38	 mov	 ecx, DWORD PTR InputFile$[rsp]
  00578	e8 00 00 00 00	 call	 psf_sndClose
$LN23@main:

; 169  :     }
; 170  : 
; 171  :     if(OutputFile >= 0)

  0057d	83 7c 24 3c 00	 cmp	 DWORD PTR OutputFile$[rsp], 0
  00582	7c 09		 jl	 SHORT $LN24@main

; 172  :     {
; 173  :         psf_sndClose(OutputFile);

  00584	8b 4c 24 3c	 mov	 ecx, DWORD PTR OutputFile$[rsp]
  00588	e8 00 00 00 00	 call	 psf_sndClose
$LN24@main:

; 174  :     }
; 175  :     
; 176  :     if(Buffer)

  0058d	48 83 7c 24 50
	00		 cmp	 QWORD PTR Buffer$[rsp], 0
  00593	74 0a		 je	 SHORT $LN25@main

; 177  :     {
; 178  :         free(Buffer);

  00595	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Buffer$[rsp]
  0059a	e8 00 00 00 00	 call	 free
$LN25@main:

; 179  :     }
; 180  : 
; 181  :     if(OutputFile_Peaks)

  0059f	48 83 7c 24 58
	00		 cmp	 QWORD PTR OutputFile_Peaks$[rsp], 0
  005a5	74 0a		 je	 SHORT $LN26@main

; 182  :     {
; 183  :         free(OutputFile_Peaks);

  005a7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR OutputFile_Peaks$[rsp]
  005ac	e8 00 00 00 00	 call	 free
$LN26@main:

; 184  :     }
; 185  : 
; 186  :     //Close portsf library
; 187  :     psf_finish();

  005b1	e8 00 00 00 00	 call	 psf_finish

; 188  : 
; 189  :     return ErrorCode;

  005b6	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
$LN1@main:

; 190  : }

  005ba	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005c2	48 33 cc	 xor	 rcx, rsp
  005c5	e8 00 00 00 00	 call	 __security_check_cookie
  005ca	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  005d1	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 952  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 953  :         int _Result;
; 954  :         va_list _ArgList;
; 955  :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 48	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 956  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00022	b9 01 00 00 00	 mov	 ecx, 1
  00027	e8 00 00 00 00	 call	 __acrt_iob_func
  0002c	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00031	45 33 c0	 xor	 r8d, r8d
  00034	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Format$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 _vfprintf_l
  00041	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 957  :         __crt_va_end(_ArgList);

  00045	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 958  :         return _Result;

  0004e	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 959  :     }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Stream$ = 64
_Format$ = 72
fprintf	PROC						; COMDAT

; 833  :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 834  :         int _Result;
; 835  :         va_list _ArgList;
; 836  :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 837  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Stream$[rsp]
  00034	e8 00 00 00 00	 call	 _vfprintf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 838  :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 839  :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 840  :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 640  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 641  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	e8 00 00 00 00	 call	 __stdio_common_vfprintf

; 642  :     }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 86   :         static unsigned __int64 _OptionsStorage;
; 87   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 88   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
