; Listing generated by Microsoft (R) Optimizing Compiler Version 19.11.25507.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG7954	DB	'soundfile_template.exe: Used as basis for audio processi'
	DB	'ng code', 0aH, 00H
	ORG $+7
$SG7957	DB	'Error: Missing flag name', 0aH, 00H
	ORG $+6
$SG7962	DB	'Error: Unable to start portsf', 0aH, 00H
	ORG $+9
$SG7960	DB	'Error: Insufficient number of arguments', 0aH, 'Usage: s'
	DB	'ound_file_gain.exe, input file, output file, buffer size, dB '
	DB	'value', 0aH, 00H
	ORG $+4
$SG7964	DB	'Error: Unable to open input file %s', 0aH, 00H
	ORG $+3
$SG7966	DB	'Error: No memory', 0aH, 00H
	ORG $+6
$SG7968	DB	'Error: output file name %s has unknown format', 0aH, 00H
	ORG $+1
$SG7970	DB	'Error: No memory', 0aH, 00H
	ORG $+6
$SG7972	DB	'Error: Unable to create output file %s', 0aH, 00H
$SG7973	DB	'Info: Processing...', 0aH, 00H
	ORG $+3
$SG7975	DB	'Info: Copying %ld samples...', 0dH, 00H
	ORG $+2
$SG7977	DB	'Error: Cannot write to ouput file %s', 0aH, 00H
	ORG $+10
$SG7980	DB	'Error: Cannot read input file %s, output file %s is inco'
	DB	'mplete', 0aH, 00H
$SG7981	DB	0aH, 'Info: Done.', 0aH, 'Info: %d errors', 0aH, 00H
	ORG $+2
$SG7983	DB	'Info: Peaks:', 0aH, 00H
	ORG $+2
$SG7984	DB	'Channel %d:', 09H, '%.4f (%.4f dB) at %.4f seconds', 0aH
	DB	00H
	ORG $+4
$SG7987	DB	'Warning: Problem closing input file %s', 0aH, 00H
$SG7990	DB	'Warning: Problem closing output file %s', 0aH, 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	fprintf
PUBLIC	printf
PUBLIC	main
EXTRN	__acrt_iob_func:PROC
EXTRN	puts:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	free:PROC
EXTRN	malloc:PROC
EXTRN	log10:PROC
EXTRN	psf_init:PROC
EXTRN	psf_finish:PROC
EXTRN	psf_sndCreate:PROC
EXTRN	psf_sndOpen:PROC
EXTRN	psf_sndClose:PROC
EXTRN	psf_sndWriteFloatFrames:PROC
EXTRN	psf_sndReadFloatFrames:PROC
EXTRN	psf_sndReadPeaks:PROC
EXTRN	psf_getFormatExt:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$fprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$printf
pdata	ENDS
pdata	SEGMENT
$pdata$main DD	imagerel $LN33
	DD	imagerel $LN33+1615
	DD	imagerel $unwind$main
pdata	ENDS
xdata	SEGMENT
$unwind$main DD	042419H
	DD	01f0112H
	DD	0600a700bH
	DD	imagerel __GSHandlerCheck
	DD	0e0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\chapter_2\2.3.2\code\soundfile_template.c
_TEXT	SEGMENT
ErrorCode$ = 48
CommandFlag$1 = 52
i$2 = 56
OutputFile$ = 60
InputFile$ = 64
FramesRead_Total$ = 68
FramesRead$ = 72
PeakData$ = 80
BufferSize$ = 88
OutputFile_Format$ = 92
FramesInput$ = 96
tv77 = 104
tv138 = 112
tv161 = 120
tv188 = 128
tv212 = 136
tv221 = 144
tv224 = 152
PeakTime$3 = 160
PeakDB$4 = 168
InputFile_Properties$ = 176
OutputFile_Properties$ = 200
__$ArrayPad$ = 224
argc$ = 272
argv$ = 280
main	PROC

; 12   : {

$LN33:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 13   :     //Stage 1: Declare
; 14   :     PSF_PROPS InputFile_Properties, OutputFile_Properties; //File properties struct from portsf
; 15   :     long FramesRead, FramesRead_Total;
; 16   : 
; 17   :     //Initialise dyanmic variables to defaults
; 18   :     int InputFile = -1;

  00024	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR InputFile$[rsp], -1

; 19   :     int OutputFile = -1;

  0002c	c7 44 24 3c ff
	ff ff ff	 mov	 DWORD PTR OutputFile$[rsp], -1

; 20   :     int ErrorCode = 0;

  00034	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR ErrorCode$[rsp], 0

; 21   :     PSF_CHPEAK *PeakData = NULL; //Peak data struct from portsf

  0003c	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR PeakData$[rsp], 0

; 22   :     unsigned long BufferSize = BUFFER_SIZE; //Unsigned, buffer size cannot be a negative number

  00045	c7 44 24 58 00
	04 00 00	 mov	 DWORD PTR BufferSize$[rsp], 1024 ; 00000400H

; 23   :     psf_format OutputFile_Format;
; 24   :     float *FramesInput;
; 25   :     float *FramesOutput;
; 26   : 
; 27   :     printf("soundfile_template.exe: Used as basis for audio processing code\n");

  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7954
  00054	e8 00 00 00 00	 call	 printf

; 28   : 
; 29   :     //Stage 2: Argument check
; 30   : 
; 31   :     //Process optional flags
; 32   :     if(argc > 1)

  00059	83 bc 24 10 01
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  00061	0f 8e af 00 00
	00		 jle	 $LN11@main
$LN2@main:

; 33   :     {
; 34   :         char CommandFlag;
; 35   : 
; 36   :         while(argv[1][0] == '-')

  00067	b8 08 00 00 00	 mov	 eax, 8
  0006c	48 6b c0 01	 imul	 rax, rax, 1
  00070	b9 01 00 00 00	 mov	 ecx, 1
  00075	48 6b c9 00	 imul	 rcx, rcx, 0
  00079	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00081	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00085	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00089	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0008c	0f 85 84 00 00
	00		 jne	 $LN3@main

; 37   :         {
; 38   :             CommandFlag = argv[1][1];

  00092	b8 08 00 00 00	 mov	 eax, 8
  00097	48 6b c0 01	 imul	 rax, rax, 1
  0009b	b9 01 00 00 00	 mov	 ecx, 1
  000a0	48 6b c9 01	 imul	 rcx, rcx, 1
  000a4	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  000ac	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  000b0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b4	88 44 24 34	 mov	 BYTE PTR CommandFlag$1[rsp], al

; 39   : 
; 40   :             switch(CommandFlag)

  000b8	0f b6 44 24 34	 movzx	 eax, BYTE PTR CommandFlag$1[rsp]
  000bd	88 44 24 68	 mov	 BYTE PTR tv77[rsp], al
  000c1	80 7c 24 68 00	 cmp	 BYTE PTR tv77[rsp], 0
  000c6	74 02		 je	 SHORT $LN12@main
  000c8	eb 23		 jmp	 SHORT $LN13@main
$LN12@main:

; 41   :             {
; 42   :                 case('\0'):
; 43   :                     fprintf(stderr, "Error: Missing flag name\n");

  000ca	b9 02 00 00 00	 mov	 ecx, 2
  000cf	e8 00 00 00 00	 call	 __acrt_iob_func
  000d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7957
  000db	48 8b c8	 mov	 rcx, rax
  000de	e8 00 00 00 00	 call	 fprintf

; 44   :                     return 1;

  000e3	b8 01 00 00 00	 mov	 eax, 1
  000e8	e9 48 05 00 00	 jmp	 $LN1@main
$LN13@main:

; 45   :                 
; 46   :                 default:
; 47   :                     break;
; 48   :             }
; 49   : 
; 50   :             argc--;

  000ed	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  000f4	ff c8		 dec	 eax
  000f6	89 84 24 10 01
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 51   :             argv++;

  000fd	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00105	48 83 c0 08	 add	 rax, 8
  00109	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 52   :         }

  00111	e9 51 ff ff ff	 jmp	 $LN2@main
$LN3@main:
$LN11@main:

; 53   :     }
; 54   : 
; 55   :     //Check command line arguments
; 56   :     if(argc < ARG_NUM_ARGS)

  00116	83 bc 24 10 01
	00 00 03	 cmp	 DWORD PTR argc$[rsp], 3
  0011e	7d 23		 jge	 SHORT $LN14@main

; 57   :     {
; 58   :         fprintf(stderr, "Error: Insufficient number of arguments\n"

  00120	b9 02 00 00 00	 mov	 ecx, 2
  00125	e8 00 00 00 00	 call	 __acrt_iob_func
  0012a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7960
  00131	48 8b c8	 mov	 rcx, rax
  00134	e8 00 00 00 00	 call	 fprintf

; 59   :                         "Usage: sound_file_gain.exe, input file, output file, buffer size, dB value\n");
; 60   :         return 1;

  00139	b8 01 00 00 00	 mov	 eax, 1
  0013e	e9 f2 04 00 00	 jmp	 $LN1@main
$LN14@main:

; 61   :     }
; 62   : 
; 63   :     //Start portsf library
; 64   :     if(psf_init())

  00143	e8 00 00 00 00	 call	 psf_init
  00148	85 c0		 test	 eax, eax
  0014a	74 23		 je	 SHORT $LN15@main

; 65   :     {
; 66   :         fprintf(stderr, "Error: Unable to start portsf\n");

  0014c	b9 02 00 00 00	 mov	 ecx, 2
  00151	e8 00 00 00 00	 call	 __acrt_iob_func
  00156	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7962
  0015d	48 8b c8	 mov	 rcx, rax
  00160	e8 00 00 00 00	 call	 fprintf

; 67   :         return 1;

  00165	b8 01 00 00 00	 mov	 eax, 1
  0016a	e9 c6 04 00 00	 jmp	 $LN1@main
$LN15@main:

; 68   :     }
; 69   :     
; 70   :     //Stage 3: Process input file
; 71   :     //Open user input file
; 72   :     InputFile = psf_sndOpen(argv[ARG_INFILE], &InputFile_Properties, 0);

  0016f	b8 08 00 00 00	 mov	 eax, 8
  00174	48 6b c0 01	 imul	 rax, rax, 1
  00178	45 33 c0	 xor	 r8d, r8d
  0017b	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR InputFile_Properties$[rsp]
  00183	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0018b	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0018f	e8 00 00 00 00	 call	 psf_sndOpen
  00194	89 44 24 40	 mov	 DWORD PTR InputFile$[rsp], eax

; 73   : 
; 74   :     if(InputFile < 0)

  00198	83 7c 24 40 00	 cmp	 DWORD PTR InputFile$[rsp], 0
  0019d	7d 42		 jge	 SHORT $LN16@main

; 75   :     {
; 76   :         fprintf(stderr, "Error: Unable to open input file %s\n", argv[ARG_INFILE]);

  0019f	b8 08 00 00 00	 mov	 eax, 8
  001a4	48 6b c0 01	 imul	 rax, rax, 1
  001a8	48 89 44 24 70	 mov	 QWORD PTR tv138[rsp], rax
  001ad	b9 02 00 00 00	 mov	 ecx, 2
  001b2	e8 00 00 00 00	 call	 __acrt_iob_func
  001b7	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001bf	48 8b 54 24 70	 mov	 rdx, QWORD PTR tv138[rsp]
  001c4	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  001c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7964
  001cf	48 8b c8	 mov	 rcx, rax
  001d2	e8 00 00 00 00	 call	 fprintf

; 77   :         return 1;

  001d7	b8 01 00 00 00	 mov	 eax, 1
  001dc	e9 54 04 00 00	 jmp	 $LN1@main
$LN16@main:

; 78   :     }
; 79   : 
; 80   :     //Allocate memory for input file samples
; 81   :     FramesInput = (float*) malloc(BufferSize * InputFile_Properties.chans * sizeof(float));

  001e1	8b 44 24 58	 mov	 eax, DWORD PTR BufferSize$[rsp]
  001e5	0f af 84 24 b4
	00 00 00	 imul	 eax, DWORD PTR InputFile_Properties$[rsp+4]
  001ed	8b c0		 mov	 eax, eax
  001ef	48 c1 e0 02	 shl	 rax, 2
  001f3	48 8b c8	 mov	 rcx, rax
  001f6	e8 00 00 00 00	 call	 malloc
  001fb	48 89 44 24 60	 mov	 QWORD PTR FramesInput$[rsp], rax

; 82   : 
; 83   :     if(FramesInput == NULL)

  00200	48 83 7c 24 60
	00		 cmp	 QWORD PTR FramesInput$[rsp], 0
  00206	75 1b		 jne	 SHORT $LN17@main

; 84   :     {
; 85   :         puts("Error: No memory\n"); //Puts uses less system memory than printf, applicable for severe memory errors

  00208	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7966
  0020f	e8 00 00 00 00	 call	 puts

; 86   :         ErrorCode++;

  00214	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  00218	ff c0		 inc	 eax
  0021a	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 87   :         goto memory_cleanup;

  0021e	e9 83 03 00 00	 jmp	 $memory_cleanup$34
$LN17@main:

; 88   :     }
; 89   : 
; 90   :     //Check extension of output file name
; 91   : 
; 92   :     OutputFile_Format = psf_getFormatExt(argv[ARG_OUTFILE]);

  00223	b8 08 00 00 00	 mov	 eax, 8
  00228	48 6b c0 02	 imul	 rax, rax, 2
  0022c	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00234	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00238	e8 00 00 00 00	 call	 psf_getFormatExt
  0023d	89 44 24 5c	 mov	 DWORD PTR OutputFile_Format$[rsp], eax

; 93   : 
; 94   :     if(OutputFile_Format == PSF_FMT_UNKNOWN)

  00241	83 7c 24 5c 00	 cmp	 DWORD PTR OutputFile_Format$[rsp], 0
  00246	75 47		 jne	 SHORT $LN18@main

; 95   :     {
; 96   :         fprintf(stderr, "Error: output file name %s has unknown format\n", argv[ARG_OUTFILE]);

  00248	b8 08 00 00 00	 mov	 eax, 8
  0024d	48 6b c0 02	 imul	 rax, rax, 2
  00251	48 89 44 24 78	 mov	 QWORD PTR tv161[rsp], rax
  00256	b9 02 00 00 00	 mov	 ecx, 2
  0025b	e8 00 00 00 00	 call	 __acrt_iob_func
  00260	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00268	48 8b 54 24 78	 mov	 rdx, QWORD PTR tv161[rsp]
  0026d	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  00271	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7968
  00278	48 8b c8	 mov	 rcx, rax
  0027b	e8 00 00 00 00	 call	 fprintf

; 97   :         ErrorCode++;

  00280	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  00284	ff c0		 inc	 eax
  00286	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 98   :         goto memory_cleanup;

  0028a	e9 17 03 00 00	 jmp	 $memory_cleanup$34
$LN18@main:

; 99   :     }
; 100  : 
; 101  :     InputFile_Properties.format = OutputFile_Format;

  0028f	8b 44 24 5c	 mov	 eax, DWORD PTR OutputFile_Format$[rsp]
  00293	89 84 24 bc 00
	00 00		 mov	 DWORD PTR InputFile_Properties$[rsp+12], eax

; 102  :     OutputFile_Properties = InputFile_Properties;

  0029a	48 8d 84 24 c8
	00 00 00	 lea	 rax, QWORD PTR OutputFile_Properties$[rsp]
  002a2	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR InputFile_Properties$[rsp]
  002aa	48 8b f8	 mov	 rdi, rax
  002ad	48 8b f1	 mov	 rsi, rcx
  002b0	b9 14 00 00 00	 mov	 ecx, 20
  002b5	f3 a4		 rep movsb

; 103  : 
; 104  :     //Stage 4: Process output file
; 105  :     //Allocate memory for the peak data of the output file
; 106  :     PeakData = (PSF_CHPEAK*) malloc(OutputFile_Properties.chans * sizeof(PSF_CHPEAK));

  002b7	48 63 84 24 cc
	00 00 00	 movsxd	 rax, DWORD PTR OutputFile_Properties$[rsp+4]
  002bf	48 c1 e0 03	 shl	 rax, 3
  002c3	48 8b c8	 mov	 rcx, rax
  002c6	e8 00 00 00 00	 call	 malloc
  002cb	48 89 44 24 50	 mov	 QWORD PTR PeakData$[rsp], rax

; 107  :     
; 108  :     if(PeakData == NULL)

  002d0	48 83 7c 24 50
	00		 cmp	 QWORD PTR PeakData$[rsp], 0
  002d6	75 1b		 jne	 SHORT $LN19@main

; 109  :     {
; 110  :         puts("Error: No memory\n");

  002d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7970
  002df	e8 00 00 00 00	 call	 puts

; 111  :         ErrorCode++;

  002e4	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  002e8	ff c0		 inc	 eax
  002ea	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 112  :         goto memory_cleanup;

  002ee	e9 b3 02 00 00	 jmp	 $memory_cleanup$34
$LN19@main:

; 113  :     }
; 114  :     
; 115  :     //Create output file for for reading/writing
; 116  :     OutputFile = psf_sndCreate(argv[ARG_OUTFILE], &OutputFile_Properties, 0, 0, PSF_CREATE_RDWR);

  002f3	b8 08 00 00 00	 mov	 eax, 8
  002f8	48 6b c0 02	 imul	 rax, rax, 2
  002fc	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00304	45 33 c9	 xor	 r9d, r9d
  00307	45 33 c0	 xor	 r8d, r8d
  0030a	48 8d 94 24 c8
	00 00 00	 lea	 rdx, QWORD PTR OutputFile_Properties$[rsp]
  00312	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0031a	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0031e	e8 00 00 00 00	 call	 psf_sndCreate
  00323	89 44 24 3c	 mov	 DWORD PTR OutputFile$[rsp], eax

; 117  : 
; 118  :     if(OutputFile < 0)

  00327	83 7c 24 3c 00	 cmp	 DWORD PTR OutputFile$[rsp], 0
  0032c	7d 4d		 jge	 SHORT $LN20@main

; 119  :     {
; 120  :         fprintf(stderr, "Error: Unable to create output file %s\n", argv[ARG_OUTFILE]);

  0032e	b8 08 00 00 00	 mov	 eax, 8
  00333	48 6b c0 02	 imul	 rax, rax, 2
  00337	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv188[rsp], rax
  0033f	b9 02 00 00 00	 mov	 ecx, 2
  00344	e8 00 00 00 00	 call	 __acrt_iob_func
  00349	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00351	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR tv188[rsp]
  00359	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  0035d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7972
  00364	48 8b c8	 mov	 rcx, rax
  00367	e8 00 00 00 00	 call	 fprintf

; 121  :         ErrorCode++;

  0036c	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  00370	ff c0		 inc	 eax
  00372	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 122  :         goto memory_cleanup;

  00376	e9 2b 02 00 00	 jmp	 $memory_cleanup$34
$LN20@main:

; 123  :     }
; 124  : 
; 125  :     //Stage 5: Processing loop
; 126  :     printf("Info: Processing...\n");

  0037b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7973
  00382	e8 00 00 00 00	 call	 printf

; 127  : 
; 128  :     FramesRead_Total = 0;

  00387	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR FramesRead_Total$[rsp], 0
$LN6@main:

; 129  : 
; 130  :     //Main loop
; 131  :     while((FramesRead = psf_sndReadFloatFrames(InputFile, FramesInput, BufferSize)) > 0 )

  0038f	44 8b 44 24 58	 mov	 r8d, DWORD PTR BufferSize$[rsp]
  00394	48 8b 54 24 60	 mov	 rdx, QWORD PTR FramesInput$[rsp]
  00399	8b 4c 24 40	 mov	 ecx, DWORD PTR InputFile$[rsp]
  0039d	e8 00 00 00 00	 call	 psf_sndReadFloatFrames
  003a2	89 44 24 48	 mov	 DWORD PTR FramesRead$[rsp], eax
  003a6	83 7c 24 48 00	 cmp	 DWORD PTR FramesRead$[rsp], 0
  003ab	0f 8e 92 00 00
	00		 jle	 $LN7@main

; 132  :     {
; 133  :         //Buffer processing
; 134  : 
; 135  :         //Calculate total amount of frames read from the input file
; 136  :         FramesRead_Total++;

  003b1	8b 44 24 44	 mov	 eax, DWORD PTR FramesRead_Total$[rsp]
  003b5	ff c0		 inc	 eax
  003b7	89 44 24 44	 mov	 DWORD PTR FramesRead_Total$[rsp], eax

; 137  :         
; 138  :         //Update progress for every X number of samples
; 139  :         if(FramesRead_Total % BufferSize == 0)

  003bb	33 d2		 xor	 edx, edx
  003bd	8b 44 24 44	 mov	 eax, DWORD PTR FramesRead_Total$[rsp]
  003c1	f7 74 24 58	 div	 DWORD PTR BufferSize$[rsp]
  003c5	8b c2		 mov	 eax, edx
  003c7	85 c0		 test	 eax, eax
  003c9	75 10		 jne	 SHORT $LN21@main

; 140  :         {
; 141  :             printf("Info: Copying %ld samples...\r", FramesRead_Total);

  003cb	8b 54 24 44	 mov	 edx, DWORD PTR FramesRead_Total$[rsp]
  003cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7975
  003d6	e8 00 00 00 00	 call	 printf
$LN21@main:

; 142  :         }
; 143  : 
; 144  :         //Check for errors writing to the output file
; 145  :         if(psf_sndWriteFloatFrames(OutputFile, FramesInput, FramesRead) != FramesRead)

  003db	44 8b 44 24 48	 mov	 r8d, DWORD PTR FramesRead$[rsp]
  003e0	48 8b 54 24 60	 mov	 rdx, QWORD PTR FramesInput$[rsp]
  003e5	8b 4c 24 3c	 mov	 ecx, DWORD PTR OutputFile$[rsp]
  003e9	e8 00 00 00 00	 call	 psf_sndWriteFloatFrames
  003ee	3b 44 24 48	 cmp	 eax, DWORD PTR FramesRead$[rsp]
  003f2	74 4a		 je	 SHORT $LN22@main

; 146  :         {
; 147  :             fprintf(stderr, "Error: Cannot write to ouput file %s\n", argv[ARG_OUTFILE]);

  003f4	b8 08 00 00 00	 mov	 eax, 8
  003f9	48 6b c0 02	 imul	 rax, rax, 2
  003fd	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv212[rsp], rax
  00405	b9 02 00 00 00	 mov	 ecx, 2
  0040a	e8 00 00 00 00	 call	 __acrt_iob_func
  0040f	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00417	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR tv212[rsp]
  0041f	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  00423	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7977
  0042a	48 8b c8	 mov	 rcx, rax
  0042d	e8 00 00 00 00	 call	 fprintf

; 148  :             ErrorCode++;

  00432	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  00436	ff c0		 inc	 eax
  00438	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 149  :             break;

  0043c	eb 05		 jmp	 SHORT $LN7@main
$LN22@main:

; 150  :         }
; 151  :     }

  0043e	e9 4c ff ff ff	 jmp	 $LN6@main
$LN7@main:

; 152  : 
; 153  :     if(FramesRead < 0)

  00443	83 7c 24 48 00	 cmp	 DWORD PTR FramesRead$[rsp], 0
  00448	7d 6f		 jge	 SHORT $LN23@main

; 154  :     {
; 155  :         fprintf(stderr, "Error: Cannot read input file %s, output file %s is incomplete\n", argv[ARG_INFILE], argv[ARG_OUTFILE]);

  0044a	b8 08 00 00 00	 mov	 eax, 8
  0044f	48 6b c0 02	 imul	 rax, rax, 2
  00453	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv221[rsp], rax
  0045b	b9 08 00 00 00	 mov	 ecx, 8
  00460	48 6b c9 01	 imul	 rcx, rcx, 1
  00464	48 89 8c 24 98
	00 00 00	 mov	 QWORD PTR tv224[rsp], rcx
  0046c	b9 02 00 00 00	 mov	 ecx, 2
  00471	e8 00 00 00 00	 call	 __acrt_iob_func
  00476	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0047e	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tv221[rsp]
  00486	4c 8b 0c 11	 mov	 r9, QWORD PTR [rcx+rdx]
  0048a	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00492	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR tv224[rsp]
  0049a	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  0049e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7980
  004a5	48 8b c8	 mov	 rcx, rax
  004a8	e8 00 00 00 00	 call	 fprintf

; 156  :         ErrorCode++;

  004ad	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  004b1	ff c0		 inc	 eax
  004b3	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 157  :     }

  004b7	eb 10		 jmp	 SHORT $LN24@main
$LN23@main:

; 158  : 
; 159  :     else
; 160  :     {
; 161  :         printf("\nInfo: Done.\n"

  004b9	8b 54 24 30	 mov	 edx, DWORD PTR ErrorCode$[rsp]
  004bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7981
  004c4	e8 00 00 00 00	 call	 printf
$LN24@main:

; 162  :                "Info: %d errors\n", ErrorCode);
; 163  :     }
; 164  : 
; 165  :     //Stage 6: User reporting
; 166  :     //Check if any peak data was captured
; 167  :     if(psf_sndReadPeaks(OutputFile, PeakData, NULL) > 0)

  004c9	45 33 c0	 xor	 r8d, r8d
  004cc	48 8b 54 24 50	 mov	 rdx, QWORD PTR PeakData$[rsp]
  004d1	8b 4c 24 3c	 mov	 ecx, DWORD PTR OutputFile$[rsp]
  004d5	e8 00 00 00 00	 call	 psf_sndReadPeaks
  004da	85 c0		 test	 eax, eax
  004dc	0f 8e c4 00 00
	00		 jle	 $LN25@main

; 168  :     {
; 169  :         double PeakTime;
; 170  :         double PeakDB;
; 171  :         printf("Info: Peaks:\n");

  004e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7983
  004e9	e8 00 00 00 00	 call	 printf

; 172  : 
; 173  :         //Loop for every channel in the input file
; 174  :         for (long i = 0; i < InputFile_Properties.chans; i++)

  004ee	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  004f6	eb 0a		 jmp	 SHORT $LN10@main
$LN8@main:
  004f8	8b 44 24 38	 mov	 eax, DWORD PTR i$2[rsp]
  004fc	ff c0		 inc	 eax
  004fe	89 44 24 38	 mov	 DWORD PTR i$2[rsp], eax
$LN10@main:
  00502	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR InputFile_Properties$[rsp+4]
  00509	39 44 24 38	 cmp	 DWORD PTR i$2[rsp], eax
  0050d	0f 8d 93 00 00
	00		 jge	 $LN9@main

; 175  :         {
; 176  :             PeakTime = (double) PeakData[i].pos / (double) InputFile_Properties.srate; //Calculate the time in seconds according the input file sample rate

  00513	48 63 44 24 38	 movsxd	 rax, DWORD PTR i$2[rsp]
  00518	48 8b 4c 24 50	 mov	 rcx, QWORD PTR PeakData$[rsp]
  0051d	8b 44 c1 04	 mov	 eax, DWORD PTR [rcx+rax*8+4]
  00521	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  00526	f2 0f 2a 8c 24
	b0 00 00 00	 cvtsi2sd xmm1, DWORD PTR InputFile_Properties$[rsp]
  0052f	f2 0f 5e c1	 divsd	 xmm0, xmm1
  00533	f2 0f 11 84 24
	a0 00 00 00	 movsd	 QWORD PTR PeakTime$3[rsp], xmm0

; 177  :             PeakDB = log10(PeakData[i].val); //Calculate dB values from linear values

  0053c	48 63 44 24 38	 movsxd	 rax, DWORD PTR i$2[rsp]
  00541	48 8b 4c 24 50	 mov	 rcx, QWORD PTR PeakData$[rsp]
  00546	f3 0f 5a 04 c1	 cvtss2sd xmm0, DWORD PTR [rcx+rax*8]
  0054b	e8 00 00 00 00	 call	 log10
  00550	f2 0f 11 84 24
	a8 00 00 00	 movsd	 QWORD PTR PeakDB$4[rsp], xmm0

; 178  :             printf("Channel %d:\t%.4f (%.4f dB) at %.4f seconds\n", i + 1, PeakData[i].val, PeakDB, PeakTime);

  00559	48 63 44 24 38	 movsxd	 rax, DWORD PTR i$2[rsp]
  0055e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR PeakData$[rsp]
  00563	f3 0f 5a 04 c1	 cvtss2sd xmm0, DWORD PTR [rcx+rax*8]
  00568	8b 44 24 38	 mov	 eax, DWORD PTR i$2[rsp]
  0056c	ff c0		 inc	 eax
  0056e	f2 0f 10 8c 24
	a0 00 00 00	 movsd	 xmm1, QWORD PTR PeakTime$3[rsp]
  00577	f2 0f 11 4c 24
	20		 movsd	 QWORD PTR [rsp+32], xmm1
  0057d	f2 0f 10 9c 24
	a8 00 00 00	 movsd	 xmm3, QWORD PTR PeakDB$4[rsp]
  00586	66 49 0f 7e d9	 movq	 r9, xmm3
  0058b	0f 28 d0	 movaps	 xmm2, xmm0
  0058e	66 49 0f 7e d0	 movq	 r8, xmm2
  00593	8b d0		 mov	 edx, eax
  00595	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7984
  0059c	e8 00 00 00 00	 call	 printf

; 179  :         }

  005a1	e9 52 ff ff ff	 jmp	 $LN8@main
$LN9@main:
$LN25@main:
$memory_cleanup$34:

; 180  :     }
; 181  : 
; 182  :     //Stage 7: Cleanup
; 183  :     //Close all files and free all allocated memory
; 184  :     memory_cleanup:
; 185  : 
; 186  :     if(InputFile >= 0)

  005a6	83 7c 24 40 00	 cmp	 DWORD PTR InputFile$[rsp], 0
  005ab	7c 2a		 jl	 SHORT $LN26@main

; 187  :     {
; 188  :         if(psf_sndClose(InputFile));

  005ad	8b 4c 24 40	 mov	 ecx, DWORD PTR InputFile$[rsp]
  005b1	e8 00 00 00 00	 call	 psf_sndClose

; 189  :         {
; 190  :             printf("Warning: Problem closing input file %s\n", argv[ARG_INFILE]);

  005b6	b8 08 00 00 00	 mov	 eax, 8
  005bb	48 6b c0 01	 imul	 rax, rax, 1
  005bf	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  005c7	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  005cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7987
  005d2	e8 00 00 00 00	 call	 printf
$LN26@main:

; 191  :         }
; 192  :     }
; 193  : 
; 194  :     if(OutputFile >= 0)

  005d7	83 7c 24 3c 00	 cmp	 DWORD PTR OutputFile$[rsp], 0
  005dc	7c 2a		 jl	 SHORT $LN28@main

; 195  :     {
; 196  :         if(psf_sndClose(OutputFile));

  005de	8b 4c 24 3c	 mov	 ecx, DWORD PTR OutputFile$[rsp]
  005e2	e8 00 00 00 00	 call	 psf_sndClose

; 197  :         {
; 198  :             printf("Warning: Problem closing output file %s\n", argv[ARG_OUTFILE]);

  005e7	b8 08 00 00 00	 mov	 eax, 8
  005ec	48 6b c0 02	 imul	 rax, rax, 2
  005f0	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  005f8	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  005fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7990
  00603	e8 00 00 00 00	 call	 printf
$LN28@main:

; 199  :         }
; 200  :     }
; 201  :     
; 202  :     if(FramesInput)

  00608	48 83 7c 24 60
	00		 cmp	 QWORD PTR FramesInput$[rsp], 0
  0060e	74 0a		 je	 SHORT $LN30@main

; 203  :     {
; 204  :         free(FramesInput);

  00610	48 8b 4c 24 60	 mov	 rcx, QWORD PTR FramesInput$[rsp]
  00615	e8 00 00 00 00	 call	 free
$LN30@main:

; 205  :     }
; 206  : 
; 207  :     if(PeakData)

  0061a	48 83 7c 24 50
	00		 cmp	 QWORD PTR PeakData$[rsp], 0
  00620	74 0a		 je	 SHORT $LN31@main

; 208  :     {
; 209  :         free(PeakData);

  00622	48 8b 4c 24 50	 mov	 rcx, QWORD PTR PeakData$[rsp]
  00627	e8 00 00 00 00	 call	 free
$LN31@main:

; 210  :     }
; 211  : 
; 212  :     //Close portsf library
; 213  :     psf_finish();

  0062c	e8 00 00 00 00	 call	 psf_finish

; 214  : 
; 215  :     return ErrorCode;

  00631	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
$LN1@main:

; 216  : }

  00635	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0063d	48 33 cc	 xor	 rcx, rsp
  00640	e8 00 00 00 00	 call	 __security_check_cookie
  00645	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  0064c	5f		 pop	 rdi
  0064d	5e		 pop	 rsi
  0064e	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 952  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 953  :         int _Result;
; 954  :         va_list _ArgList;
; 955  :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 48	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 956  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00022	b9 01 00 00 00	 mov	 ecx, 1
  00027	e8 00 00 00 00	 call	 __acrt_iob_func
  0002c	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00031	45 33 c0	 xor	 r8d, r8d
  00034	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Format$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 _vfprintf_l
  00041	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 957  :         __crt_va_end(_ArgList);

  00045	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 958  :         return _Result;

  0004e	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 959  :     }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Stream$ = 64
_Format$ = 72
fprintf	PROC						; COMDAT

; 833  :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 834  :         int _Result;
; 835  :         va_list _ArgList;
; 836  :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 837  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Stream$[rsp]
  00034	e8 00 00 00 00	 call	 _vfprintf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 838  :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 839  :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 840  :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 640  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 641  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	e8 00 00 00 00	 call	 __stdio_common_vfprintf

; 642  :     }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 86   :         static unsigned __int64 _OptionsStorage;
; 87   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 88   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
