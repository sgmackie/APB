; Listing generated by Microsoft (R) Optimizing Compiler Version 19.11.25507.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG7973	DB	'sound_file_normalise: Normalise output copied from input'
	DB	' file', 0aH, 00H
	ORG $+1
$SG7975	DB	'Error: Insufficient number of arguments', 0aH, 'Usage: s'
	DB	'ound_file_gain.exe, input file, output file, buffer size, dB '
	DB	'value', 0aH, 00H
	ORG $+4
$SG7977	DB	'Error: Unable to start portsf', 0aH, 00H
	ORG $+1
$SG7979	DB	'Error: Unable to open input file %s', 0aH, 00H
	ORG $+3
$SG7981	DB	'Error: Buffer size must be at least 1', 0aH, 00H
	ORG $+1
$SG7983	DB	'Error: dB value cannot be positive', 0aH, 00H
	ORG $+4
$SG7985	DB	'Error: Unable to create output file %s', 0aH, 00H
$SG7987	DB	'Error: No memory', 0aH, 00H
	ORG $+6
$SG7989	DB	'Error: No memory', 0aH, 00H
	ORG $+6
$SG7993	DB	'Info: No input peak data found, scanning file', 0aH, 00H
	ORG $+1
$SG7996	DB	'Error: Could not scan input file', 0aH, 00H
	ORG $+6
$SG7998	DB	'Error: Unable to rewind input file', 0aH, 00H
	ORG $+4
$SG8000	DB	'Info: Input file is silent, no output file created', 0aH
	DB	00H
	ORG $+4
$SG8001	DB	'Info: Normalising by scale factor %.4f...', 0aH, 00H
	ORG $+5
$SG8003	DB	'Info: Copying %ld samples...', 0dH, 00H
	ORG $+2
$SG8005	DB	'Error: Cannot write to ouput file %s', 0aH, 00H
	ORG $+10
$SG8008	DB	'Error: Cannot read input file %s, output file %s is inco'
	DB	'mplete', 0aH, 00H
$SG8009	DB	0aH, 'Info: Done.', 0aH, 'Info: %d sample frames copied t'
	DB	'o %s', 0aH, 00H
	ORG $+6
$SG8011	DB	'Info: Peaks:', 0aH, 00H
	ORG $+2
$SG8012	DB	'Channel %d:', 09H, '%.4f (%.4f dB) at %.4f seconds', 0aH
	DB	00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	fprintf
PUBLIC	printf
PUBLIC	max_sample_value
PUBLIC	main
PUBLIC	__real@0000000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@4034000000000000
EXTRN	__acrt_iob_func:PROC
EXTRN	puts:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	free:PROC
EXTRN	malloc:PROC
EXTRN	atof:PROC
EXTRN	fabs:PROC
EXTRN	log10:PROC
EXTRN	pow:PROC
EXTRN	psf_init:PROC
EXTRN	psf_finish:PROC
EXTRN	psf_sndCreate:PROC
EXTRN	psf_sndOpen:PROC
EXTRN	psf_sndClose:PROC
EXTRN	psf_sndWriteFloatFrames:PROC
EXTRN	psf_sndSeek:PROC
EXTRN	psf_sndReadFloatFrames:PROC
EXTRN	psf_sndReadPeaks:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$fprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$printf
pdata	ENDS
pdata	SEGMENT
$pdata$max_sample_value DD imagerel $LN7
	DD	imagerel $LN7+116
	DD	imagerel $unwind$max_sample_value
$pdata$main DD	imagerel $LN40
	DD	imagerel $LN40+1990
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT __real@4034000000000000
CONST	SEGMENT
__real@4034000000000000 DQ 04034000000000000r	; 20
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
xdata	SEGMENT
$unwind$max_sample_value DD 010d01H
	DD	0820dH
$unwind$main DD	022219H
	DD	01f0110H
	DD	imagerel __GSHandlerCheck
	DD	0e0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\chapter_2\2.2.3\code\sound_file_normalise.c
_TEXT	SEGMENT
ErrorCode$ = 48
FramesRead$ = 52
InputFile$ = 56
i$1 = 60
BufferSize$ = 64
OutputFile$ = 68
Buffer$ = 72
i$2 = 80
i$3 = 84
CalculatedPeaks$ = 88
FramesRead_Total$ = 96
j$4 = 100
BlockSize$ = 104
InputFile_Peak$ = 112
ScaleFactor$ = 120
AmplitudeFactor$ = 124
dBValue$ = 128
ThisPeak$5 = 136
tv84 = 144
tv156 = 152
tv268 = 160
tv281 = 168
tv284 = 176
PeakTime$6 = 184
PeakDB$7 = 192
FileProperties$ = 200
__$ArrayPad$ = 224
argc$ = 256
argv$ = 264
main	PROC

; 13   : {

$LN40:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 14   :     //Variable declarations
; 15   :     PSF_PROPS FileProperties; //File properties struct from portsf
; 16   :     long FramesRead, FramesRead_Total, BlockSize;
; 17   :     float AmplitudeFactor, ScaleFactor;
; 18   :     double dBValue;
; 19   :     unsigned long BufferSize; //Unsigned, buffer size cannot be a negative number
; 20   : 
; 21   :     double InputFile_Peak = 0.0;

  00022	0f 57 c0	 xorps	 xmm0, xmm0
  00025	f2 0f 11 44 24
	70		 movsd	 QWORD PTR InputFile_Peak$[rsp], xmm0

; 22   :     int InputFile = -1;

  0002b	c7 44 24 38 ff
	ff ff ff	 mov	 DWORD PTR InputFile$[rsp], -1

; 23   :     int OutputFile = -1;

  00033	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR OutputFile$[rsp], -1

; 24   :     int ErrorCode = 0;

  0003b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR ErrorCode$[rsp], 0

; 25   :     PSF_CHPEAK *CalculatedPeaks = NULL; //Peak data struct from portsf

  00043	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR CalculatedPeaks$[rsp], 0

; 26   :     float *Buffer = NULL;

  0004c	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR Buffer$[rsp], 0

; 27   : 
; 28   :     printf("sound_file_normalise: Normalise output copied from input file\n");

  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7973
  0005c	e8 00 00 00 00	 call	 printf

; 29   : 
; 30   :     //Check number of arguments provided by user
; 31   :     if(argc < ARG_NUM_ARGS)

  00061	83 bc 24 00 01
	00 00 05	 cmp	 DWORD PTR argc$[rsp], 5
  00069	7d 23		 jge	 SHORT $LN15@main

; 32   :     {
; 33   :         fprintf(stderr, "Error: Insufficient number of arguments\n"

  0006b	b9 02 00 00 00	 mov	 ecx, 2
  00070	e8 00 00 00 00	 call	 __acrt_iob_func
  00075	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7975
  0007c	48 8b c8	 mov	 rcx, rax
  0007f	e8 00 00 00 00	 call	 fprintf

; 34   :                         "Usage: sound_file_gain.exe, input file, output file, buffer size, dB value\n");
; 35   :         return 1;

  00084	b8 01 00 00 00	 mov	 eax, 1
  00089	e9 20 07 00 00	 jmp	 $LN1@main
$LN15@main:

; 36   :     }
; 37   : 
; 38   :     //Start portsf library
; 39   :     if(psf_init())

  0008e	e8 00 00 00 00	 call	 psf_init
  00093	85 c0		 test	 eax, eax
  00095	74 23		 je	 SHORT $LN16@main

; 40   :     {
; 41   :         fprintf(stderr, "Error: Unable to start portsf\n");

  00097	b9 02 00 00 00	 mov	 ecx, 2
  0009c	e8 00 00 00 00	 call	 __acrt_iob_func
  000a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7977
  000a8	48 8b c8	 mov	 rcx, rax
  000ab	e8 00 00 00 00	 call	 fprintf

; 42   :         return 1;

  000b0	b8 01 00 00 00	 mov	 eax, 1
  000b5	e9 f4 06 00 00	 jmp	 $LN1@main
$LN16@main:

; 43   :     }
; 44   :     
; 45   :     //Open user input file
; 46   :     InputFile = psf_sndOpen(argv[ARG_INFILE], &FileProperties, 0);

  000ba	b8 08 00 00 00	 mov	 eax, 8
  000bf	48 6b c0 01	 imul	 rax, rax, 1
  000c3	45 33 c0	 xor	 r8d, r8d
  000c6	48 8d 94 24 c8
	00 00 00	 lea	 rdx, QWORD PTR FileProperties$[rsp]
  000ce	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000d6	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  000da	e8 00 00 00 00	 call	 psf_sndOpen
  000df	89 44 24 38	 mov	 DWORD PTR InputFile$[rsp], eax

; 47   : 
; 48   :     if(InputFile < 0)

  000e3	83 7c 24 38 00	 cmp	 DWORD PTR InputFile$[rsp], 0
  000e8	7d 48		 jge	 SHORT $LN17@main

; 49   :     {
; 50   :         fprintf(stderr, "Error: Unable to open input file %s\n", argv[ARG_NAME]);

  000ea	b8 08 00 00 00	 mov	 eax, 8
  000ef	48 6b c0 00	 imul	 rax, rax, 0
  000f3	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv84[rsp], rax
  000fb	b9 02 00 00 00	 mov	 ecx, 2
  00100	e8 00 00 00 00	 call	 __acrt_iob_func
  00105	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0010d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tv84[rsp]
  00115	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  00119	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7979
  00120	48 8b c8	 mov	 rcx, rax
  00123	e8 00 00 00 00	 call	 fprintf

; 51   :         return 1;

  00128	b8 01 00 00 00	 mov	 eax, 1
  0012d	e9 7c 06 00 00	 jmp	 $LN1@main
$LN17@main:

; 52   :     }
; 53   : 
; 54   :     //Create buffer 'chunk' size from user argument
; 55   :     BufferSize = atof(argv[ARG_BUFFER_SIZE]);

  00132	b8 08 00 00 00	 mov	 eax, 8
  00137	48 6b c0 03	 imul	 rax, rax, 3
  0013b	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00143	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00147	e8 00 00 00 00	 call	 atof
  0014c	f2 48 0f 2c c0	 cvttsd2si rax, xmm0
  00151	89 44 24 40	 mov	 DWORD PTR BufferSize$[rsp], eax

; 56   :     
; 57   :     if(BufferSize < 1)

  00155	83 7c 24 40 01	 cmp	 DWORD PTR BufferSize$[rsp], 1
  0015a	73 23		 jae	 SHORT $LN18@main

; 58   :     {
; 59   :         fprintf(stderr, "Error: Buffer size must be at least 1\n");

  0015c	b9 02 00 00 00	 mov	 ecx, 2
  00161	e8 00 00 00 00	 call	 __acrt_iob_func
  00166	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7981
  0016d	48 8b c8	 mov	 rcx, rax
  00170	e8 00 00 00 00	 call	 fprintf

; 60   :         return 1;

  00175	b8 01 00 00 00	 mov	 eax, 1
  0017a	e9 2f 06 00 00	 jmp	 $LN1@main
$LN18@main:

; 61   :     }
; 62   : 
; 63   :     //Assign amplitude from user argument
; 64   :     dBValue = atof(argv[ARG_AMPLITUDE]);

  0017f	b8 08 00 00 00	 mov	 eax, 8
  00184	48 6b c0 04	 imul	 rax, rax, 4
  00188	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00190	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00194	e8 00 00 00 00	 call	 atof
  00199	f2 0f 11 84 24
	80 00 00 00	 movsd	 QWORD PTR dBValue$[rsp], xmm0

; 65   :     
; 66   :     if(dBValue > 0.0)

  001a2	f2 0f 10 84 24
	80 00 00 00	 movsd	 xmm0, QWORD PTR dBValue$[rsp]
  001ab	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  001b3	76 23		 jbe	 SHORT $LN19@main

; 67   :     {
; 68   :         fprintf(stderr, "Error: dB value cannot be positive\n");

  001b5	b9 02 00 00 00	 mov	 ecx, 2
  001ba	e8 00 00 00 00	 call	 __acrt_iob_func
  001bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7983
  001c6	48 8b c8	 mov	 rcx, rax
  001c9	e8 00 00 00 00	 call	 fprintf

; 69   :         return 1;

  001ce	b8 01 00 00 00	 mov	 eax, 1
  001d3	e9 d6 05 00 00	 jmp	 $LN1@main
$LN19@main:

; 70   :     }
; 71   : 
; 72   :     AmplitudeFactor = (float) pow(10.0, dBValue / 20.0);

  001d8	f2 0f 10 84 24
	80 00 00 00	 movsd	 xmm0, QWORD PTR dBValue$[rsp]
  001e1	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4034000000000000
  001e9	0f 28 c8	 movaps	 xmm1, xmm0
  001ec	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4024000000000000
  001f4	e8 00 00 00 00	 call	 pow
  001f9	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  001fd	f3 0f 11 44 24
	7c		 movss	 DWORD PTR AmplitudeFactor$[rsp], xmm0

; 73   : 
; 74   :     //Create output file for for reading/writing
; 75   :     OutputFile = psf_sndCreate(argv[ARG_OUTFILE], &FileProperties, 0, 0, PSF_CREATE_RDWR);

  00203	b8 08 00 00 00	 mov	 eax, 8
  00208	48 6b c0 02	 imul	 rax, rax, 2
  0020c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00214	45 33 c9	 xor	 r9d, r9d
  00217	45 33 c0	 xor	 r8d, r8d
  0021a	48 8d 94 24 c8
	00 00 00	 lea	 rdx, QWORD PTR FileProperties$[rsp]
  00222	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0022a	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0022e	e8 00 00 00 00	 call	 psf_sndCreate
  00233	89 44 24 44	 mov	 DWORD PTR OutputFile$[rsp], eax

; 76   : 
; 77   :     if(OutputFile < 0)

  00237	83 7c 24 44 00	 cmp	 DWORD PTR OutputFile$[rsp], 0
  0023c	7d 4d		 jge	 SHORT $LN20@main

; 78   :     {
; 79   :         fprintf(stderr, "Error: Unable to create output file %s\n", argv[ARG_OUTFILE]);

  0023e	b8 08 00 00 00	 mov	 eax, 8
  00243	48 6b c0 02	 imul	 rax, rax, 2
  00247	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv156[rsp], rax
  0024f	b9 02 00 00 00	 mov	 ecx, 2
  00254	e8 00 00 00 00	 call	 __acrt_iob_func
  00259	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00261	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR tv156[rsp]
  00269	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  0026d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7985
  00274	48 8b c8	 mov	 rcx, rax
  00277	e8 00 00 00 00	 call	 fprintf

; 80   :         ErrorCode++;

  0027c	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  00280	ff c0		 inc	 eax
  00282	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 81   :         goto memory_cleanup;

  00286	e9 d6 04 00 00	 jmp	 $memory_cleanup$41
$LN20@main:

; 82   :     }
; 83   : 
; 84   :     //Allocate memory for buffer according to number of channels in input file and the buffer size
; 85   :     Buffer = (float*) malloc(BufferSize * FileProperties.chans * sizeof(float));

  0028b	8b 44 24 40	 mov	 eax, DWORD PTR BufferSize$[rsp]
  0028f	0f af 84 24 cc
	00 00 00	 imul	 eax, DWORD PTR FileProperties$[rsp+4]
  00297	8b c0		 mov	 eax, eax
  00299	48 c1 e0 02	 shl	 rax, 2
  0029d	48 8b c8	 mov	 rcx, rax
  002a0	e8 00 00 00 00	 call	 malloc
  002a5	48 89 44 24 48	 mov	 QWORD PTR Buffer$[rsp], rax

; 86   : 
; 87   :     if(Buffer == NULL)

  002aa	48 83 7c 24 48
	00		 cmp	 QWORD PTR Buffer$[rsp], 0
  002b0	75 1b		 jne	 SHORT $LN21@main

; 88   :     {
; 89   :         //Puts uses less system memory than printf, applicable for severe memory errors
; 90   :         puts("Error: No memory\n");

  002b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7987
  002b9	e8 00 00 00 00	 call	 puts

; 91   :         ErrorCode++;

  002be	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  002c2	ff c0		 inc	 eax
  002c4	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 92   :         goto memory_cleanup;

  002c8	e9 94 04 00 00	 jmp	 $memory_cleanup$41
$LN21@main:

; 93   :     }
; 94   : 
; 95   :     //Allocate memory for the peak data of the output file
; 96   :     CalculatedPeaks = (PSF_CHPEAK*) malloc(FileProperties.chans * sizeof(PSF_CHPEAK));

  002cd	48 63 84 24 cc
	00 00 00	 movsxd	 rax, DWORD PTR FileProperties$[rsp+4]
  002d5	48 c1 e0 03	 shl	 rax, 3
  002d9	48 8b c8	 mov	 rcx, rax
  002dc	e8 00 00 00 00	 call	 malloc
  002e1	48 89 44 24 58	 mov	 QWORD PTR CalculatedPeaks$[rsp], rax

; 97   : 
; 98   :     if(CalculatedPeaks == NULL)

  002e6	48 83 7c 24 58
	00		 cmp	 QWORD PTR CalculatedPeaks$[rsp], 0
  002ec	75 1b		 jne	 SHORT $LN22@main

; 99   :     {
; 100  :         puts("Error: No memory\n");

  002ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7989
  002f5	e8 00 00 00 00	 call	 puts

; 101  :         ErrorCode++;

  002fa	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  002fe	ff c0		 inc	 eax
  00300	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 102  :         goto memory_cleanup;

  00304	e9 58 04 00 00	 jmp	 $memory_cleanup$41
$LN22@main:

; 103  :     }
; 104  : 
; 105  :     //Read peak header from input file
; 106  :     if(psf_sndReadPeaks(InputFile, CalculatedPeaks, NULL) > 0)

  00309	45 33 c0	 xor	 r8d, r8d
  0030c	48 8b 54 24 58	 mov	 rdx, QWORD PTR CalculatedPeaks$[rsp]
  00311	8b 4c 24 38	 mov	 ecx, DWORD PTR InputFile$[rsp]
  00315	e8 00 00 00 00	 call	 psf_sndReadPeaks
  0031a	85 c0		 test	 eax, eax
  0031c	7e 54		 jle	 SHORT $LN23@main

; 107  :     {
; 108  :         //Loop for every channel in the input file
; 109  :         for (long i = 0; i < FileProperties.chans; i++)

  0031e	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  00326	eb 0a		 jmp	 SHORT $LN4@main
$LN2@main:
  00328	8b 44 24 50	 mov	 eax, DWORD PTR i$2[rsp]
  0032c	ff c0		 inc	 eax
  0032e	89 44 24 50	 mov	 DWORD PTR i$2[rsp], eax
$LN4@main:
  00332	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR FileProperties$[rsp+4]
  00339	39 44 24 50	 cmp	 DWORD PTR i$2[rsp], eax
  0033d	7d 2e		 jge	 SHORT $LN3@main

; 110  :         {
; 111  :             if(CalculatedPeaks[i].val > InputFile_Peak)

  0033f	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$2[rsp]
  00344	48 8b 4c 24 58	 mov	 rcx, QWORD PTR CalculatedPeaks$[rsp]
  00349	f3 0f 5a 04 c1	 cvtss2sd xmm0, DWORD PTR [rcx+rax*8]
  0034e	66 0f 2f 44 24
	70		 comisd	 xmm0, QWORD PTR InputFile_Peak$[rsp]
  00354	76 15		 jbe	 SHORT $LN25@main

; 112  :             {
; 113  :                 InputFile_Peak = CalculatedPeaks[i].val;

  00356	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$2[rsp]
  0035b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR CalculatedPeaks$[rsp]
  00360	f3 0f 5a 04 c1	 cvtss2sd xmm0, DWORD PTR [rcx+rax*8]
  00365	f2 0f 11 44 24
	70		 movsd	 QWORD PTR InputFile_Peak$[rsp], xmm0
$LN25@main:

; 114  :             }
; 115  :         }

  0036b	eb bb		 jmp	 SHORT $LN2@main
$LN3@main:

; 116  :     }

  0036d	e9 e9 00 00 00	 jmp	 $LN24@main
$LN23@main:

; 117  : 
; 118  :     //Scan file for peaks if format doesn't include peak header
; 119  :     else
; 120  :     {
; 121  :         FramesRead = psf_sndReadFloatFrames(InputFile, Buffer, BufferSize);

  00372	44 8b 44 24 40	 mov	 r8d, DWORD PTR BufferSize$[rsp]
  00377	48 8b 54 24 48	 mov	 rdx, QWORD PTR Buffer$[rsp]
  0037c	8b 4c 24 38	 mov	 ecx, DWORD PTR InputFile$[rsp]
  00380	e8 00 00 00 00	 call	 psf_sndReadFloatFrames
  00385	89 44 24 34	 mov	 DWORD PTR FramesRead$[rsp], eax

; 122  :         printf("Info: No input peak data found, scanning file\n");

  00389	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7993
  00390	e8 00 00 00 00	 call	 printf
$LN5@main:

; 123  : 
; 124  :         //Scan file for maximum peak value
; 125  :         while (FramesRead > 0)

  00395	83 7c 24 34 00	 cmp	 DWORD PTR FramesRead$[rsp], 0
  0039a	7e 60		 jle	 SHORT $LN6@main

; 126  :         {
; 127  :             BlockSize = FramesRead * FileProperties.chans;

  0039c	8b 44 24 34	 mov	 eax, DWORD PTR FramesRead$[rsp]
  003a0	0f af 84 24 cc
	00 00 00	 imul	 eax, DWORD PTR FileProperties$[rsp+4]
  003a8	89 44 24 68	 mov	 DWORD PTR BlockSize$[rsp], eax

; 128  :             double ThisPeak = max_sample_value(Buffer, BlockSize);

  003ac	8b 54 24 68	 mov	 edx, DWORD PTR BlockSize$[rsp]
  003b0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Buffer$[rsp]
  003b5	e8 00 00 00 00	 call	 max_sample_value
  003ba	f2 0f 11 84 24
	88 00 00 00	 movsd	 QWORD PTR ThisPeak$5[rsp], xmm0

; 129  :     
; 130  :             if(ThisPeak > InputFile_Peak)

  003c3	f2 0f 10 84 24
	88 00 00 00	 movsd	 xmm0, QWORD PTR ThisPeak$5[rsp]
  003cc	66 0f 2f 44 24
	70		 comisd	 xmm0, QWORD PTR InputFile_Peak$[rsp]
  003d2	76 0f		 jbe	 SHORT $LN26@main

; 131  :             {
; 132  :                 InputFile_Peak = ThisPeak;

  003d4	f2 0f 10 84 24
	88 00 00 00	 movsd	 xmm0, QWORD PTR ThisPeak$5[rsp]
  003dd	f2 0f 11 44 24
	70		 movsd	 QWORD PTR InputFile_Peak$[rsp], xmm0
$LN26@main:

; 133  :             }
; 134  :     
; 135  :             FramesRead = psf_sndReadFloatFrames(InputFile, Buffer, BufferSize);

  003e3	44 8b 44 24 40	 mov	 r8d, DWORD PTR BufferSize$[rsp]
  003e8	48 8b 54 24 48	 mov	 rdx, QWORD PTR Buffer$[rsp]
  003ed	8b 4c 24 38	 mov	 ecx, DWORD PTR InputFile$[rsp]
  003f1	e8 00 00 00 00	 call	 psf_sndReadFloatFrames
  003f6	89 44 24 34	 mov	 DWORD PTR FramesRead$[rsp], eax

; 136  :         }

  003fa	eb 99		 jmp	 SHORT $LN5@main
$LN6@main:

; 137  : 
; 138  :         if(FramesRead < 0)

  003fc	83 7c 24 34 00	 cmp	 DWORD PTR FramesRead$[rsp], 0
  00401	7d 1e		 jge	 SHORT $LN27@main

; 139  :         {
; 140  :             fprintf(stderr, "Error: Could not scan input file\n");

  00403	b9 02 00 00 00	 mov	 ecx, 2
  00408	e8 00 00 00 00	 call	 __acrt_iob_func
  0040d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7996
  00414	48 8b c8	 mov	 rcx, rax
  00417	e8 00 00 00 00	 call	 fprintf

; 141  :             goto memory_cleanup;

  0041c	e9 40 03 00 00	 jmp	 $memory_cleanup$41
$LN27@main:

; 142  :         }
; 143  : 
; 144  :         //Rewind file to 0
; 145  :         if((psf_sndSeek(InputFile, 0, PSF_SEEK_SET)) < 0)

  00421	45 33 c0	 xor	 r8d, r8d
  00424	33 d2		 xor	 edx, edx
  00426	8b 4c 24 38	 mov	 ecx, DWORD PTR InputFile$[rsp]
  0042a	e8 00 00 00 00	 call	 psf_sndSeek
  0042f	85 c0		 test	 eax, eax
  00431	7d 28		 jge	 SHORT $LN28@main

; 146  :         {
; 147  :             fprintf(stderr, "Error: Unable to rewind input file\n");

  00433	b9 02 00 00 00	 mov	 ecx, 2
  00438	e8 00 00 00 00	 call	 __acrt_iob_func
  0043d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7998
  00444	48 8b c8	 mov	 rcx, rax
  00447	e8 00 00 00 00	 call	 fprintf

; 148  :             ErrorCode++;

  0044c	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  00450	ff c0		 inc	 eax
  00452	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 149  :             goto memory_cleanup;

  00456	e9 06 03 00 00	 jmp	 $memory_cleanup$41
$LN28@main:
$LN24@main:

; 150  :         }
; 151  :     }
; 152  : 
; 153  :     //Check if input file is silent
; 154  :     if(InputFile_Peak == 0.0)

  0045b	f2 0f 10 44 24
	70		 movsd	 xmm0, QWORD PTR InputFile_Peak$[rsp]
  00461	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  00469	7a 13		 jp	 SHORT $LN29@main
  0046b	75 11		 jne	 SHORT $LN29@main

; 155  :     {
; 156  :         printf("Info: Input file is silent, no output file created\n");

  0046d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG8000
  00474	e8 00 00 00 00	 call	 printf

; 157  :         goto memory_cleanup;

  00479	e9 e3 02 00 00	 jmp	 $memory_cleanup$41
$LN29@main:

; 158  :     }
; 159  : 
; 160  :     ScaleFactor = (float) (AmplitudeFactor / InputFile_Peak);

  0047e	f3 0f 5a 44 24
	7c		 cvtss2sd xmm0, DWORD PTR AmplitudeFactor$[rsp]
  00484	f2 0f 5e 44 24
	70		 divsd	 xmm0, QWORD PTR InputFile_Peak$[rsp]
  0048a	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0048e	f3 0f 11 44 24
	78		 movss	 DWORD PTR ScaleFactor$[rsp], xmm0

; 161  : 
; 162  :     printf("Info: Normalising by scale factor %.4f...\n", ScaleFactor);

  00494	f3 0f 5a 44 24
	78		 cvtss2sd xmm0, DWORD PTR ScaleFactor$[rsp]
  0049a	0f 28 c8	 movaps	 xmm1, xmm0
  0049d	66 48 0f 7e ca	 movq	 rdx, xmm1
  004a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG8001
  004a9	e8 00 00 00 00	 call	 printf

; 163  : 
; 164  :     //Call portsf function for reading input file frames according to the buffer
; 165  :     FramesRead = psf_sndReadFloatFrames(InputFile, Buffer, BufferSize);

  004ae	44 8b 44 24 40	 mov	 r8d, DWORD PTR BufferSize$[rsp]
  004b3	48 8b 54 24 48	 mov	 rdx, QWORD PTR Buffer$[rsp]
  004b8	8b 4c 24 38	 mov	 ecx, DWORD PTR InputFile$[rsp]
  004bc	e8 00 00 00 00	 call	 psf_sndReadFloatFrames
  004c1	89 44 24 34	 mov	 DWORD PTR FramesRead$[rsp], eax

; 166  :     FramesRead_Total = 0;

  004c5	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR FramesRead_Total$[rsp], 0
$LN7@main:

; 167  :     
; 168  :     //Loop while the portsf function returns 1
; 169  :     while(FramesRead > 0)

  004cd	83 7c 24 34 00	 cmp	 DWORD PTR FramesRead$[rsp], 0
  004d2	0f 8e 11 01 00
	00		 jle	 $LN8@main

; 170  :     {
; 171  :         //Calculate the file size of the buffer
; 172  :         BlockSize = FramesRead * FileProperties.chans;

  004d8	8b 44 24 34	 mov	 eax, DWORD PTR FramesRead$[rsp]
  004dc	0f af 84 24 cc
	00 00 00	 imul	 eax, DWORD PTR FileProperties$[rsp+4]
  004e4	89 44 24 68	 mov	 DWORD PTR BlockSize$[rsp], eax

; 173  : 
; 174  :         //Calculate total amount of frames read from the input file
; 175  :         FramesRead_Total++;

  004e8	8b 44 24 60	 mov	 eax, DWORD PTR FramesRead_Total$[rsp]
  004ec	ff c0		 inc	 eax
  004ee	89 44 24 60	 mov	 DWORD PTR FramesRead_Total$[rsp], eax

; 176  : 
; 177  :         //Counter declare
; 178  :         int j = 0;

  004f2	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR j$4[rsp], 0

; 179  :         j++;

  004fa	8b 44 24 64	 mov	 eax, DWORD PTR j$4[rsp]
  004fe	ff c0		 inc	 eax
  00500	89 44 24 64	 mov	 DWORD PTR j$4[rsp], eax

; 180  : 
; 181  :         //Update progress for every 1000 samples
; 182  :         if(j % 1000 == 0)

  00504	8b 44 24 64	 mov	 eax, DWORD PTR j$4[rsp]
  00508	99		 cdq
  00509	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  0050e	f7 f9		 idiv	 ecx
  00510	8b c2		 mov	 eax, edx
  00512	85 c0		 test	 eax, eax
  00514	75 10		 jne	 SHORT $LN30@main

; 183  :         {
; 184  :             printf("Info: Copying %ld samples...\r", FramesRead_Total);

  00516	8b 54 24 60	 mov	 edx, DWORD PTR FramesRead_Total$[rsp]
  0051a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG8003
  00521	e8 00 00 00 00	 call	 printf
$LN30@main:

; 185  :         }
; 186  : 
; 187  :         for(int i = 0; i < BlockSize; i++)

  00526	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$3[rsp], 0
  0052e	eb 0a		 jmp	 SHORT $LN11@main
$LN9@main:
  00530	8b 44 24 54	 mov	 eax, DWORD PTR i$3[rsp]
  00534	ff c0		 inc	 eax
  00536	89 44 24 54	 mov	 DWORD PTR i$3[rsp], eax
$LN11@main:
  0053a	8b 44 24 68	 mov	 eax, DWORD PTR BlockSize$[rsp]
  0053e	39 44 24 54	 cmp	 DWORD PTR i$3[rsp], eax
  00542	7d 26		 jge	 SHORT $LN10@main

; 188  :         {
; 189  :             Buffer[i] *= ScaleFactor;

  00544	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$3[rsp]
  00549	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Buffer$[rsp]
  0054e	f3 0f 10 04 81	 movss	 xmm0, DWORD PTR [rcx+rax*4]
  00553	f3 0f 59 44 24
	78		 mulss	 xmm0, DWORD PTR ScaleFactor$[rsp]
  00559	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$3[rsp]
  0055e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Buffer$[rsp]
  00563	f3 0f 11 04 81	 movss	 DWORD PTR [rcx+rax*4], xmm0

; 190  :         }

  00568	eb c6		 jmp	 SHORT $LN9@main
$LN10@main:

; 191  : 
; 192  :         //Check for errors writing to the output file
; 193  :         if(psf_sndWriteFloatFrames(OutputFile, Buffer, FramesRead) != FramesRead)

  0056a	44 8b 44 24 34	 mov	 r8d, DWORD PTR FramesRead$[rsp]
  0056f	48 8b 54 24 48	 mov	 rdx, QWORD PTR Buffer$[rsp]
  00574	8b 4c 24 44	 mov	 ecx, DWORD PTR OutputFile$[rsp]
  00578	e8 00 00 00 00	 call	 psf_sndWriteFloatFrames
  0057d	3b 44 24 34	 cmp	 eax, DWORD PTR FramesRead$[rsp]
  00581	74 4a		 je	 SHORT $LN31@main

; 194  :         {
; 195  :             fprintf(stderr, "Error: Cannot write to ouput file %s\n", argv[ARG_OUTFILE]);

  00583	b8 08 00 00 00	 mov	 eax, 8
  00588	48 6b c0 02	 imul	 rax, rax, 2
  0058c	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv268[rsp], rax
  00594	b9 02 00 00 00	 mov	 ecx, 2
  00599	e8 00 00 00 00	 call	 __acrt_iob_func
  0059e	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  005a6	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR tv268[rsp]
  005ae	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  005b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG8005
  005b9	48 8b c8	 mov	 rcx, rax
  005bc	e8 00 00 00 00	 call	 fprintf

; 196  :             ErrorCode++;

  005c1	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  005c5	ff c0		 inc	 eax
  005c7	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 197  :             break;

  005cb	eb 1c		 jmp	 SHORT $LN8@main
$LN31@main:

; 198  :         }
; 199  : 
; 200  :         FramesRead = psf_sndReadFloatFrames(InputFile, Buffer, BufferSize);

  005cd	44 8b 44 24 40	 mov	 r8d, DWORD PTR BufferSize$[rsp]
  005d2	48 8b 54 24 48	 mov	 rdx, QWORD PTR Buffer$[rsp]
  005d7	8b 4c 24 38	 mov	 ecx, DWORD PTR InputFile$[rsp]
  005db	e8 00 00 00 00	 call	 psf_sndReadFloatFrames
  005e0	89 44 24 34	 mov	 DWORD PTR FramesRead$[rsp], eax

; 201  :     }

  005e4	e9 e4 fe ff ff	 jmp	 $LN7@main
$LN8@main:

; 202  : 
; 203  :     if(FramesRead < 0)

  005e9	83 7c 24 34 00	 cmp	 DWORD PTR FramesRead$[rsp], 0
  005ee	7d 6f		 jge	 SHORT $LN32@main

; 204  :     {
; 205  :         fprintf(stderr, "Error: Cannot read input file %s, output file %s is incomplete\n", argv[ARG_INFILE], argv[ARG_OUTFILE]);

  005f0	b8 08 00 00 00	 mov	 eax, 8
  005f5	48 6b c0 02	 imul	 rax, rax, 2
  005f9	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv281[rsp], rax
  00601	b9 08 00 00 00	 mov	 ecx, 8
  00606	48 6b c9 01	 imul	 rcx, rcx, 1
  0060a	48 89 8c 24 b0
	00 00 00	 mov	 QWORD PTR tv284[rsp], rcx
  00612	b9 02 00 00 00	 mov	 ecx, 2
  00617	e8 00 00 00 00	 call	 __acrt_iob_func
  0061c	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00624	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR tv281[rsp]
  0062c	4c 8b 0c 11	 mov	 r9, QWORD PTR [rcx+rdx]
  00630	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00638	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR tv284[rsp]
  00640	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  00644	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG8008
  0064b	48 8b c8	 mov	 rcx, rax
  0064e	e8 00 00 00 00	 call	 fprintf

; 206  :         ErrorCode++;

  00653	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  00657	ff c0		 inc	 eax
  00659	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 207  :     }

  0065d	eb 25		 jmp	 SHORT $LN33@main
$LN32@main:

; 208  : 
; 209  :     else
; 210  :     {
; 211  :         printf("\nInfo: Done.\n"

  0065f	b8 08 00 00 00	 mov	 eax, 8
  00664	48 6b c0 02	 imul	 rax, rax, 2
  00668	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00670	4c 8b 04 01	 mov	 r8, QWORD PTR [rcx+rax]
  00674	8b 54 24 60	 mov	 edx, DWORD PTR FramesRead_Total$[rsp]
  00678	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG8009
  0067f	e8 00 00 00 00	 call	 printf
$LN33@main:

; 212  :                "Info: %d sample frames copied to %s\n", FramesRead_Total, argv[ARG_OUTFILE]);
; 213  :     }
; 214  : 
; 215  :     //Check if any peak data was captured
; 216  :     if(psf_sndReadPeaks(OutputFile, CalculatedPeaks, NULL) > 0)

  00684	45 33 c0	 xor	 r8d, r8d
  00687	48 8b 54 24 58	 mov	 rdx, QWORD PTR CalculatedPeaks$[rsp]
  0068c	8b 4c 24 44	 mov	 ecx, DWORD PTR OutputFile$[rsp]
  00690	e8 00 00 00 00	 call	 psf_sndReadPeaks
  00695	85 c0		 test	 eax, eax
  00697	0f 8e c4 00 00
	00		 jle	 $LN34@main

; 217  :     {
; 218  :         double PeakTime;
; 219  :         double PeakDB;
; 220  :         printf("Info: Peaks:\n");

  0069d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG8011
  006a4	e8 00 00 00 00	 call	 printf

; 221  : 
; 222  :         //Loop for every channel in the input file
; 223  :         for (long i = 0; i < FileProperties.chans; i++)

  006a9	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  006b1	eb 0a		 jmp	 SHORT $LN14@main
$LN12@main:
  006b3	8b 44 24 3c	 mov	 eax, DWORD PTR i$1[rsp]
  006b7	ff c0		 inc	 eax
  006b9	89 44 24 3c	 mov	 DWORD PTR i$1[rsp], eax
$LN14@main:
  006bd	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR FileProperties$[rsp+4]
  006c4	39 44 24 3c	 cmp	 DWORD PTR i$1[rsp], eax
  006c8	0f 8d 93 00 00
	00		 jge	 $LN13@main

; 224  :         {
; 225  :             PeakTime = (double) CalculatedPeaks[i].pos / FileProperties.srate; //Calculate the time in seconds according the input file sample rate

  006ce	48 63 44 24 3c	 movsxd	 rax, DWORD PTR i$1[rsp]
  006d3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR CalculatedPeaks$[rsp]
  006d8	8b 44 c1 04	 mov	 eax, DWORD PTR [rcx+rax*8+4]
  006dc	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  006e1	f2 0f 2a 8c 24
	c8 00 00 00	 cvtsi2sd xmm1, DWORD PTR FileProperties$[rsp]
  006ea	f2 0f 5e c1	 divsd	 xmm0, xmm1
  006ee	f2 0f 11 84 24
	b8 00 00 00	 movsd	 QWORD PTR PeakTime$6[rsp], xmm0

; 226  :             PeakDB = log10(CalculatedPeaks[i].val); //Calculate dB values from linear values

  006f7	48 63 44 24 3c	 movsxd	 rax, DWORD PTR i$1[rsp]
  006fc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR CalculatedPeaks$[rsp]
  00701	f3 0f 5a 04 c1	 cvtss2sd xmm0, DWORD PTR [rcx+rax*8]
  00706	e8 00 00 00 00	 call	 log10
  0070b	f2 0f 11 84 24
	c0 00 00 00	 movsd	 QWORD PTR PeakDB$7[rsp], xmm0

; 227  :             printf("Channel %d:\t%.4f (%.4f dB) at %.4f seconds\n", i + 1, CalculatedPeaks[i].val, PeakDB, PeakTime);

  00714	48 63 44 24 3c	 movsxd	 rax, DWORD PTR i$1[rsp]
  00719	48 8b 4c 24 58	 mov	 rcx, QWORD PTR CalculatedPeaks$[rsp]
  0071e	f3 0f 5a 04 c1	 cvtss2sd xmm0, DWORD PTR [rcx+rax*8]
  00723	8b 44 24 3c	 mov	 eax, DWORD PTR i$1[rsp]
  00727	ff c0		 inc	 eax
  00729	f2 0f 10 8c 24
	b8 00 00 00	 movsd	 xmm1, QWORD PTR PeakTime$6[rsp]
  00732	f2 0f 11 4c 24
	20		 movsd	 QWORD PTR [rsp+32], xmm1
  00738	f2 0f 10 9c 24
	c0 00 00 00	 movsd	 xmm3, QWORD PTR PeakDB$7[rsp]
  00741	66 49 0f 7e d9	 movq	 r9, xmm3
  00746	0f 28 d0	 movaps	 xmm2, xmm0
  00749	66 49 0f 7e d0	 movq	 r8, xmm2
  0074e	8b d0		 mov	 edx, eax
  00750	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG8012
  00757	e8 00 00 00 00	 call	 printf

; 228  :         }

  0075c	e9 52 ff ff ff	 jmp	 $LN12@main
$LN13@main:
$LN34@main:
$memory_cleanup$41:

; 229  :     }
; 230  : 
; 231  :     //Close all files and free all allocated memory
; 232  :     memory_cleanup:
; 233  : 
; 234  :     if(InputFile >= 0)

  00761	83 7c 24 38 00	 cmp	 DWORD PTR InputFile$[rsp], 0
  00766	7c 09		 jl	 SHORT $LN35@main

; 235  :     {
; 236  :         psf_sndClose(InputFile);

  00768	8b 4c 24 38	 mov	 ecx, DWORD PTR InputFile$[rsp]
  0076c	e8 00 00 00 00	 call	 psf_sndClose
$LN35@main:

; 237  :     }
; 238  : 
; 239  :     if(OutputFile >= 0)

  00771	83 7c 24 44 00	 cmp	 DWORD PTR OutputFile$[rsp], 0
  00776	7c 09		 jl	 SHORT $LN36@main

; 240  :     {
; 241  :         psf_sndClose(OutputFile);

  00778	8b 4c 24 44	 mov	 ecx, DWORD PTR OutputFile$[rsp]
  0077c	e8 00 00 00 00	 call	 psf_sndClose
$LN36@main:

; 242  :     }
; 243  :     
; 244  :     if(Buffer)

  00781	48 83 7c 24 48
	00		 cmp	 QWORD PTR Buffer$[rsp], 0
  00787	74 0a		 je	 SHORT $LN37@main

; 245  :     {
; 246  :         free(Buffer);

  00789	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Buffer$[rsp]
  0078e	e8 00 00 00 00	 call	 free
$LN37@main:

; 247  :     }
; 248  : 
; 249  :     if(CalculatedPeaks)

  00793	48 83 7c 24 58
	00		 cmp	 QWORD PTR CalculatedPeaks$[rsp], 0
  00799	74 0a		 je	 SHORT $LN38@main

; 250  :     {
; 251  :         free(CalculatedPeaks);

  0079b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR CalculatedPeaks$[rsp]
  007a0	e8 00 00 00 00	 call	 free
$LN38@main:

; 252  :     }
; 253  : 
; 254  :     //Close portsf library
; 255  :     psf_finish();

  007a5	e8 00 00 00 00	 call	 psf_finish

; 256  : 
; 257  :     return ErrorCode;

  007aa	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
$LN1@main:

; 258  : }

  007ae	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  007b6	48 33 cc	 xor	 rcx, rsp
  007b9	e8 00 00 00 00	 call	 __security_check_cookie
  007be	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  007c5	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\chapter_2\2.2.3\code\sound_file_normalise.c
_TEXT	SEGMENT
i$1 = 32
PeakValue$ = 40
AbsoluteValue$ = 48
ReadBuffer$ = 80
BlockSize$ = 88
max_sample_value PROC

; 262  : {

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 263  :     double AbsoluteValue;
; 264  :     double PeakValue = 0.0;

  0000d	0f 57 c0	 xorps	 xmm0, xmm0
  00010	f2 0f 11 44 24
	28		 movsd	 QWORD PTR PeakValue$[rsp], xmm0

; 265  :     
; 266  :     for (unsigned long i = 0; i < BlockSize; i++)

  00016	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  0001e	eb 0a		 jmp	 SHORT $LN4@max_sample
$LN2@max_sample:
  00020	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00024	ff c0		 inc	 eax
  00026	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN4@max_sample:
  0002a	8b 44 24 58	 mov	 eax, DWORD PTR BlockSize$[rsp]
  0002e	39 44 24 20	 cmp	 DWORD PTR i$1[rsp], eax
  00032	73 35		 jae	 SHORT $LN3@max_sample

; 267  :     {
; 268  :         AbsoluteValue = fabs(ReadBuffer[i]);

  00034	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00038	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ReadBuffer$[rsp]
  0003d	f3 0f 5a 04 81	 cvtss2sd xmm0, DWORD PTR [rcx+rax*4]
  00042	e8 00 00 00 00	 call	 fabs
  00047	f2 0f 11 44 24
	30		 movsd	 QWORD PTR AbsoluteValue$[rsp], xmm0

; 269  : 
; 270  :         if(AbsoluteValue > PeakValue)

  0004d	f2 0f 10 44 24
	30		 movsd	 xmm0, QWORD PTR AbsoluteValue$[rsp]
  00053	66 0f 2f 44 24
	28		 comisd	 xmm0, QWORD PTR PeakValue$[rsp]
  00059	76 0c		 jbe	 SHORT $LN5@max_sample

; 271  :         {
; 272  :             PeakValue = AbsoluteValue;

  0005b	f2 0f 10 44 24
	30		 movsd	 xmm0, QWORD PTR AbsoluteValue$[rsp]
  00061	f2 0f 11 44 24
	28		 movsd	 QWORD PTR PeakValue$[rsp], xmm0
$LN5@max_sample:

; 273  :         }
; 274  :     }

  00067	eb b7		 jmp	 SHORT $LN2@max_sample
$LN3@max_sample:

; 275  : 
; 276  :     return PeakValue;

  00069	f2 0f 10 44 24
	28		 movsd	 xmm0, QWORD PTR PeakValue$[rsp]

; 277  : }

  0006f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00073	c3		 ret	 0
max_sample_value ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 952  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 953  :         int _Result;
; 954  :         va_list _ArgList;
; 955  :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 48	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 956  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00022	b9 01 00 00 00	 mov	 ecx, 1
  00027	e8 00 00 00 00	 call	 __acrt_iob_func
  0002c	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00031	45 33 c0	 xor	 r8d, r8d
  00034	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Format$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 _vfprintf_l
  00041	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 957  :         __crt_va_end(_ArgList);

  00045	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 958  :         return _Result;

  0004e	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 959  :     }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Stream$ = 64
_Format$ = 72
fprintf	PROC						; COMDAT

; 833  :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 834  :         int _Result;
; 835  :         va_list _ArgList;
; 836  :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 837  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Stream$[rsp]
  00034	e8 00 00 00 00	 call	 _vfprintf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 838  :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 839  :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 840  :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 640  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 641  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	e8 00 00 00 00	 call	 __stdio_common_vfprintf

; 642  :     }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 86   :         static unsigned __int64 _OptionsStorage;
; 87   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 88   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
