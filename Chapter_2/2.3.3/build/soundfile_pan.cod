; Listing generated by Microsoft (R) Optimizing Compiler Version 19.11.25547.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG7235	DB	'soundfile_pan.exe: Pan mono file in stereo from given po'
	DB	'sition values', 0aH, 00H
	ORG $+1
$SG7238	DB	'Error: Missing flag name', 0aH, 00H
	ORG $+6
$SG7246	DB	'Error: Unable to start portsf', 0aH, 00H
	ORG $+1
$SG7248	DB	'Error: Unable to open input file %s', 0aH, 00H
	ORG $+3
$SG7241	DB	'Error: Insufficient number of arguments', 0aH, 'Usage: s'
	DB	'oundfile_pan.exe, input file, output file, pan position', 0aH
	DB	00H
	ORG $+3
$SG7267	DB	'r', 00H
	ORG $+2
$SG7244	DB	'Error: Pan position values out of range', 0aH, 00H
	ORG $+7
$SG7250	DB	'Error: Input file must be mono', 0aH, 00H
$SG7253	DB	'Error: No memory', 0aH, 00H
	ORG $+6
$SG7256	DB	'Error: output file name %s has unknown format', 0aH, 00H
	ORG $+1
$SG7259	DB	'Error: No memory', 0aH, 00H
	ORG $+6
$SG7262	DB	'Error: No memory', 0aH, 00H
	ORG $+6
$SG7265	DB	'Error: Unable to create output file %s', 0aH, 00H
$SG7269	DB	'Error: Unable to open breakpoint file %s', 0aH, 00H
	ORG $+6
$SG7272	DB	'Error: No breakpoints read', 0aH, 00H
	ORG $+4
$SG7275	DB	'Error: At least two breakpoints required', 0aH, 00H
	ORG $+6
$SG7277	DB	'Error: First breakpoint time (%lf) must start from 0', 0aH
	DB	00H
	ORG $+2
$SG7280	DB	'Error: Breakpoint values out of range', 0aH, 00H
	ORG $+1
$SG7282	DB	'Info: Processing...', 0aH, 00H
	ORG $+3
$SG7284	DB	'Info: Copying %ld samples...', 0dH, 00H
	ORG $+2
$SG7286	DB	'Error: Cannot write to ouput file %s', 0aH, 00H
	ORG $+2
$SG7289	DB	'Error: Cannot read input file %s, output file %s is inco'
	DB	'mplete', 0aH, 00H
$SG7290	DB	0aH, 'Info: Done.', 0aH, 'Info: %d errors', 0aH, 00H
	ORG $+2
$SG7292	DB	'Info: Peaks:', 0aH, 00H
	ORG $+2
$SG7293	DB	'Channel %d:', 09H, '%.4f (%.4f dB) at %.4f seconds', 0aH
	DB	00H
	ORG $+4
$SG7296	DB	'Warning: Problem closing input file %s', 0aH, 00H
$SG7299	DB	'Warning: Problem closing output file %s', 0aH, 00H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	fprintf
PUBLIC	??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
PUBLIC	printf
PUBLIC	?simple_pan_stereo@@YA?AUpan_position@@N@Z	; simple_pan_stereo
PUBLIC	main
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	__real@0000000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@bff0000000000000
EXTRN	__acrt_iob_func:PROC
EXTRN	fclose:PROC
EXTRN	fopen:PROC
EXTRN	puts:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	free:PROC
EXTRN	malloc:PROC
EXTRN	log10:PROC
EXTRN	psf_init:PROC
EXTRN	psf_finish:PROC
EXTRN	psf_sndCreate:PROC
EXTRN	psf_sndOpen:PROC
EXTRN	psf_sndClose:PROC
EXTRN	psf_sndWriteFloatFrames:PROC
EXTRN	psf_sndReadFloatFrames:PROC
EXTRN	psf_sndReadPeaks:PROC
EXTRN	psf_getFormatExt:PROC
EXTRN	?breakpoint_get_breakpoints@@YAPEAUBreakpointFormat@@PEAU_iobuf@@PEAK@Z:PROC ; breakpoint_get_breakpoints
EXTRN	?breakpoint_inputfile_range_check@@YAHPEBUBreakpointFormat@@NNK@Z:PROC ; breakpoint_inputfile_range_check
EXTRN	?breakpoint_value_at_breakpoint_time@@YANPEBUBreakpointFormat@@KN@Z:PROC ; breakpoint_value_at_breakpoint_time
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$fprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+92
	DD	imagerel $unwind$printf
pdata	ENDS
pdata	SEGMENT
$pdata$?simple_pan_stereo@@YA?AUpan_position@@N@Z DD imagerel $LN3
	DD	imagerel $LN3+135
	DD	imagerel $unwind$?simple_pan_stereo@@YA?AUpan_position@@N@Z
$pdata$main DD	imagerel $LN59
	DD	imagerel $LN59+2853
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
xdata	SEGMENT
$unwind$?simple_pan_stereo@@YA?AUpan_position@@N@Z DD 032019H
	DD	0700d4211H
	DD	0600cH
	DD	imagerel __GSHandlerCheck
	DD	010H
$unwind$main DD	042419H
	DD	0330112H
	DD	0600a700bH
	DD	imagerel __GSHandlerCheck
	DD	0180H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\chapter_2\2.3.3\code\soundfile_pan.cpp
_TEXT	SEGMENT
ErrorCode$ = 48
CommandFlag$1 = 52
i$2 = 56
Output_i$3 = 60
OutputFile$ = 64
Input_i$4 = 68
FramesRead$ = 72
InputFile$ = 76
BufferSize$ = 80
FramesRead_Total$ = 84
ReadPoints$ = 88
PeakData$ = 96
BreakpointFile_Size$ = 104
FramesInput$ = 112
FramesOutput$ = 120
BreakpointFile$ = 128
OutputFile_Format$ = 136
tv77 = 140
PanPosition$ = 144
SampleTime$ = 152
tv144 = 160
tv172 = 168
tv210 = 176
tv224 = 184
tv252 = 192
StereoPan_Position$5 = 200
TimeIncrement$ = 208
tv359 = 216
tv368 = 224
tv371 = 232
PeakTime$6 = 240
PeakDB$7 = 248
$T8 = 256
$T9 = 272
OutputFile_Properties$ = 288
InputFile_Properties$ = 312
PanPosition_Current$ = 336
$T10 = 352
$T11 = 368
__$ArrayPad$ = 384
argc$ = 432
argv$ = 440
main	PROC

; 22   : {

$LN59:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 98 01
	00 00		 sub	 rsp, 408		; 00000198H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 23   :     //Stage 1: Declare
; 24   :     PSF_PROPS InputFile_Properties, OutputFile_Properties; //File properties struct from portsf
; 25   :     long FramesRead, FramesRead_Total;
; 26   :     psf_format OutputFile_Format;
; 27   :     PAN_POSITION PanPosition_Current;
; 28   : 
; 29   :     //Breakpoint variables
; 30   :     unsigned long BreakpointFile_Size;
; 31   :     FILE *BreakpointFile = NULL;

  00024	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR BreakpointFile$[rsp], 0

; 32   :     BREAKPOINT_FORMAT *ReadPoints = NULL;

  00030	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR ReadPoints$[rsp], 0

; 33   :     double TimeIncrement;
; 34   :     double SampleTime;
; 35   : 
; 36   :     //Initialise dyanmic variables to defaults
; 37   :     int InputFile = -1;

  00039	c7 44 24 4c ff
	ff ff ff	 mov	 DWORD PTR InputFile$[rsp], -1

; 38   :     int OutputFile = -1;

  00041	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR OutputFile$[rsp], -1

; 39   :     int ErrorCode = 0;

  00049	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR ErrorCode$[rsp], 0

; 40   :     double PanPosition = 0;

  00051	0f 57 c0	 xorps	 xmm0, xmm0
  00054	f2 0f 11 84 24
	90 00 00 00	 movsd	 QWORD PTR PanPosition$[rsp], xmm0

; 41   :     float *FramesInput = NULL;

  0005d	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR FramesInput$[rsp], 0

; 42   :     float *FramesOutput = NULL;

  00066	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR FramesOutput$[rsp], 0

; 43   :     PSF_CHPEAK *PeakData = NULL; //Peak data struct from portsf

  0006f	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR PeakData$[rsp], 0

; 44   :     unsigned long BufferSize = BUFFER_SIZE; //Unsigned, buffer size cannot be a negative number

  00078	c7 44 24 50 00
	04 00 00	 mov	 DWORD PTR BufferSize$[rsp], 1024 ; 00000400H

; 45   : 
; 46   :     printf("soundfile_pan.exe: Pan mono file in stereo from given position values\n");

  00080	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7235
  00087	e8 00 00 00 00	 call	 printf

; 47   : 
; 48   :     //Stage 2: Argument check
; 49   :     //Process optional flags
; 50   :     if(argc > 1)

  0008c	83 bc 24 b0 01
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  00094	0f 8e b5 00 00
	00		 jle	 $LN14@main
$LN2@main:

; 51   :     {
; 52   :         char CommandFlag;
; 53   : 
; 54   :         while(argv[1][0] == '-')

  0009a	b8 08 00 00 00	 mov	 eax, 8
  0009f	48 6b c0 01	 imul	 rax, rax, 1
  000a3	b9 01 00 00 00	 mov	 ecx, 1
  000a8	48 6b c9 00	 imul	 rcx, rcx, 0
  000ac	48 8b 94 24 b8
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  000b4	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  000b8	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  000bc	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  000bf	0f 85 8a 00 00
	00		 jne	 $LN3@main

; 55   :         {
; 56   :             CommandFlag = argv[1][1];

  000c5	b8 08 00 00 00	 mov	 eax, 8
  000ca	48 6b c0 01	 imul	 rax, rax, 1
  000ce	b9 01 00 00 00	 mov	 ecx, 1
  000d3	48 6b c9 01	 imul	 rcx, rcx, 1
  000d7	48 8b 94 24 b8
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  000df	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  000e3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000e7	88 44 24 34	 mov	 BYTE PTR CommandFlag$1[rsp], al

; 57   : 
; 58   :             switch(CommandFlag)

  000eb	0f b6 44 24 34	 movzx	 eax, BYTE PTR CommandFlag$1[rsp]
  000f0	88 84 24 8c 00
	00 00		 mov	 BYTE PTR tv77[rsp], al
  000f7	80 bc 24 8c 00
	00 00 00	 cmp	 BYTE PTR tv77[rsp], 0
  000ff	74 02		 je	 SHORT $LN15@main
  00101	eb 23		 jmp	 SHORT $LN16@main
$LN15@main:

; 59   :             {
; 60   :                 case('\0'):
; 61   :                     fprintf(stderr, "Error: Missing flag name\n");

  00103	b9 02 00 00 00	 mov	 ecx, 2
  00108	e8 00 00 00 00	 call	 __acrt_iob_func
  0010d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7238
  00114	48 8b c8	 mov	 rcx, rax
  00117	e8 00 00 00 00	 call	 fprintf

; 62   :                     return 1;

  0011c	b8 01 00 00 00	 mov	 eax, 1
  00121	e9 e5 09 00 00	 jmp	 $LN1@main
$LN16@main:

; 63   :                 
; 64   :                 default:
; 65   :                     break;
; 66   :             }
; 67   : 
; 68   :             argc--;

  00126	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  0012d	ff c8		 dec	 eax
  0012f	89 84 24 b0 01
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 69   :             argv++;

  00136	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0013e	48 83 c0 08	 add	 rax, 8
  00142	48 89 84 24 b8
	01 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 70   :         }

  0014a	e9 4b ff ff ff	 jmp	 $LN2@main
$LN3@main:
$LN14@main:

; 71   :     }
; 72   : 
; 73   :     //Check command line arguments
; 74   :     if(argc < ARG_NUM_ARGS)

  0014f	83 bc 24 b0 01
	00 00 04	 cmp	 DWORD PTR argc$[rsp], 4
  00157	7d 23		 jge	 SHORT $LN17@main

; 75   :     {
; 76   :         fprintf(stderr, "Error: Insufficient number of arguments\n"

  00159	b9 02 00 00 00	 mov	 ecx, 2
  0015e	e8 00 00 00 00	 call	 __acrt_iob_func
  00163	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7241
  0016a	48 8b c8	 mov	 rcx, rax
  0016d	e8 00 00 00 00	 call	 fprintf

; 77   :                         "Usage: soundfile_pan.exe, input file, output file, pan position\n");
; 78   :         return 1;

  00172	b8 01 00 00 00	 mov	 eax, 1
  00177	e9 8f 09 00 00	 jmp	 $LN1@main
$LN17@main:

; 79   :     }
; 80   : 
; 81   :     //Check pan arguments
; 82   :     if(PanPosition > 1.0 || PanPosition < -1.0)

  0017c	f2 0f 10 84 24
	90 00 00 00	 movsd	 xmm0, QWORD PTR PanPosition$[rsp]
  00185	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@3ff0000000000000
  0018d	77 13		 ja	 SHORT $LN19@main
  0018f	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@bff0000000000000
  00197	66 0f 2f 84 24
	90 00 00 00	 comisd	 xmm0, QWORD PTR PanPosition$[rsp]
  001a0	76 23		 jbe	 SHORT $LN18@main
$LN19@main:

; 83   :     {
; 84   :         fprintf(stderr, "Error: Pan position values out of range\n");

  001a2	b9 02 00 00 00	 mov	 ecx, 2
  001a7	e8 00 00 00 00	 call	 __acrt_iob_func
  001ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7244
  001b3	48 8b c8	 mov	 rcx, rax
  001b6	e8 00 00 00 00	 call	 fprintf

; 85   :         return 1;

  001bb	b8 01 00 00 00	 mov	 eax, 1
  001c0	e9 46 09 00 00	 jmp	 $LN1@main
$LN18@main:

; 86   :     } 
; 87   : 
; 88   :     //Start portsf library
; 89   :     if(psf_init())

  001c5	e8 00 00 00 00	 call	 psf_init
  001ca	85 c0		 test	 eax, eax
  001cc	74 23		 je	 SHORT $LN20@main

; 90   :     {
; 91   :         fprintf(stderr, "Error: Unable to start portsf\n");

  001ce	b9 02 00 00 00	 mov	 ecx, 2
  001d3	e8 00 00 00 00	 call	 __acrt_iob_func
  001d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7246
  001df	48 8b c8	 mov	 rcx, rax
  001e2	e8 00 00 00 00	 call	 fprintf

; 92   :         return 1;

  001e7	b8 01 00 00 00	 mov	 eax, 1
  001ec	e9 1a 09 00 00	 jmp	 $LN1@main
$LN20@main:

; 93   :     }
; 94   :     
; 95   :     //Stage 3: Process input file
; 96   :     //Open user input file
; 97   :     InputFile = psf_sndOpen(argv[ARG_INFILE], &InputFile_Properties, 0);

  001f1	b8 08 00 00 00	 mov	 eax, 8
  001f6	48 6b c0 01	 imul	 rax, rax, 1
  001fa	45 33 c0	 xor	 r8d, r8d
  001fd	48 8d 94 24 38
	01 00 00	 lea	 rdx, QWORD PTR InputFile_Properties$[rsp]
  00205	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0020d	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00211	e8 00 00 00 00	 call	 psf_sndOpen
  00216	89 44 24 4c	 mov	 DWORD PTR InputFile$[rsp], eax

; 98   : 
; 99   :     if(InputFile < 0)

  0021a	83 7c 24 4c 00	 cmp	 DWORD PTR InputFile$[rsp], 0
  0021f	7d 48		 jge	 SHORT $LN21@main

; 100  :     {
; 101  :         fprintf(stderr, "Error: Unable to open input file %s\n", argv[ARG_INFILE]);

  00221	b8 08 00 00 00	 mov	 eax, 8
  00226	48 6b c0 01	 imul	 rax, rax, 1
  0022a	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv144[rsp], rax
  00232	b9 02 00 00 00	 mov	 ecx, 2
  00237	e8 00 00 00 00	 call	 __acrt_iob_func
  0023c	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00244	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR tv144[rsp]
  0024c	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  00250	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7248
  00257	48 8b c8	 mov	 rcx, rax
  0025a	e8 00 00 00 00	 call	 fprintf

; 102  :         return 1;

  0025f	b8 01 00 00 00	 mov	 eax, 1
  00264	e9 a2 08 00 00	 jmp	 $LN1@main
$LN21@main:

; 103  :     }
; 104  : 
; 105  :     //Check if input file is mono
; 106  :     if(InputFile_Properties.chans != 1)

  00269	83 bc 24 3c 01
	00 00 01	 cmp	 DWORD PTR InputFile_Properties$[rsp+4], 1
  00271	74 23		 je	 SHORT $LN22@main

; 107  :     {
; 108  :         fprintf(stderr, "Error: Input file must be mono\n");

  00273	b9 02 00 00 00	 mov	 ecx, 2
  00278	e8 00 00 00 00	 call	 __acrt_iob_func
  0027d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7250
  00284	48 8b c8	 mov	 rcx, rax
  00287	e8 00 00 00 00	 call	 fprintf

; 109  :         goto memory_cleanup;

  0028c	e9 af 07 00 00	 jmp	 $LN23@main
  00291	e9 aa 07 00 00	 jmp	 $memory_cleanup$60
$LN22@main:

; 110  :     }
; 111  : 
; 112  :     //Allocate memory for input file samples
; 113  :     FramesInput = (float*) malloc(BufferSize * InputFile_Properties.chans * sizeof(float));

  00296	8b 44 24 50	 mov	 eax, DWORD PTR BufferSize$[rsp]
  0029a	0f af 84 24 3c
	01 00 00	 imul	 eax, DWORD PTR InputFile_Properties$[rsp+4]
  002a2	8b c0		 mov	 eax, eax
  002a4	48 c1 e0 02	 shl	 rax, 2
  002a8	48 8b c8	 mov	 rcx, rax
  002ab	e8 00 00 00 00	 call	 malloc
  002b0	48 89 44 24 70	 mov	 QWORD PTR FramesInput$[rsp], rax

; 114  : 
; 115  :     if(FramesInput == NULL)

  002b5	48 83 7c 24 70
	00		 cmp	 QWORD PTR FramesInput$[rsp], 0
  002bb	75 20		 jne	 SHORT $LN24@main

; 116  :     {
; 117  :         puts("Error: No memory\n"); //Puts uses less system memory than printf, applicable for severe memory errors

  002bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7253
  002c4	e8 00 00 00 00	 call	 puts

; 118  :         ErrorCode++;

  002c9	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  002cd	ff c0		 inc	 eax
  002cf	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 119  :         goto memory_cleanup;

  002d3	e9 68 07 00 00	 jmp	 $LN25@main
  002d8	e9 63 07 00 00	 jmp	 $memory_cleanup$60
$LN24@main:

; 120  :     }
; 121  : 
; 122  :     //Check extension of output file name
; 123  : 
; 124  :     OutputFile_Format = psf_getFormatExt(argv[ARG_OUTFILE]);

  002dd	b8 08 00 00 00	 mov	 eax, 8
  002e2	48 6b c0 02	 imul	 rax, rax, 2
  002e6	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002ee	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  002f2	e8 00 00 00 00	 call	 psf_getFormatExt
  002f7	89 84 24 88 00
	00 00		 mov	 DWORD PTR OutputFile_Format$[rsp], eax

; 125  : 
; 126  :     if(OutputFile_Format == PSF_FMT_UNKNOWN)

  002fe	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR OutputFile_Format$[rsp], 0
  00306	75 52		 jne	 SHORT $LN26@main

; 127  :     {
; 128  :         fprintf(stderr, "Error: output file name %s has unknown format\n", argv[ARG_OUTFILE]);

  00308	b8 08 00 00 00	 mov	 eax, 8
  0030d	48 6b c0 02	 imul	 rax, rax, 2
  00311	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv172[rsp], rax
  00319	b9 02 00 00 00	 mov	 ecx, 2
  0031e	e8 00 00 00 00	 call	 __acrt_iob_func
  00323	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0032b	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR tv172[rsp]
  00333	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  00337	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7256
  0033e	48 8b c8	 mov	 rcx, rax
  00341	e8 00 00 00 00	 call	 fprintf

; 129  :         ErrorCode++;

  00346	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  0034a	ff c0		 inc	 eax
  0034c	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 130  :         goto memory_cleanup;

  00350	e9 eb 06 00 00	 jmp	 $LN27@main
  00355	e9 e6 06 00 00	 jmp	 $memory_cleanup$60
$LN26@main:

; 131  :     }
; 132  : 
; 133  :     //Copy struct from input file to output file
; 134  :     InputFile_Properties.format = OutputFile_Format;

  0035a	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR OutputFile_Format$[rsp]
  00361	89 84 24 44 01
	00 00		 mov	 DWORD PTR InputFile_Properties$[rsp+12], eax

; 135  :     OutputFile_Properties = InputFile_Properties;

  00368	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR OutputFile_Properties$[rsp]
  00370	48 8d 8c 24 38
	01 00 00	 lea	 rcx, QWORD PTR InputFile_Properties$[rsp]
  00378	48 8b f8	 mov	 rdi, rax
  0037b	48 8b f1	 mov	 rsi, rcx
  0037e	b9 14 00 00 00	 mov	 ecx, 20
  00383	f3 a4		 rep movsb

; 136  :     OutputFile_Properties.chans = 2;

  00385	c7 84 24 24 01
	00 00 02 00 00
	00		 mov	 DWORD PTR OutputFile_Properties$[rsp+4], 2

; 137  : 
; 138  :     //Allocate memory for output file frames
; 139  :     FramesOutput = (float*) malloc(BufferSize * OutputFile_Properties.chans * sizeof(float));

  00390	8b 44 24 50	 mov	 eax, DWORD PTR BufferSize$[rsp]
  00394	0f af 84 24 24
	01 00 00	 imul	 eax, DWORD PTR OutputFile_Properties$[rsp+4]
  0039c	8b c0		 mov	 eax, eax
  0039e	48 c1 e0 02	 shl	 rax, 2
  003a2	48 8b c8	 mov	 rcx, rax
  003a5	e8 00 00 00 00	 call	 malloc
  003aa	48 89 44 24 78	 mov	 QWORD PTR FramesOutput$[rsp], rax

; 140  : 
; 141  :     if(FramesOutput == NULL)

  003af	48 83 7c 24 78
	00		 cmp	 QWORD PTR FramesOutput$[rsp], 0
  003b5	75 20		 jne	 SHORT $LN28@main

; 142  :     {
; 143  :         puts("Error: No memory\n"); //Puts uses less system memory than printf, applicable for severe memory errors

  003b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7259
  003be	e8 00 00 00 00	 call	 puts

; 144  :         ErrorCode++;

  003c3	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  003c7	ff c0		 inc	 eax
  003c9	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 145  :         goto memory_cleanup;

  003cd	e9 6e 06 00 00	 jmp	 $LN29@main
  003d2	e9 69 06 00 00	 jmp	 $memory_cleanup$60
$LN28@main:

; 146  :     }
; 147  : 
; 148  :     //Stage 4: Process output file
; 149  :     //Allocate memory for the peak data of the output file
; 150  :     PeakData = (PSF_CHPEAK*) malloc(OutputFile_Properties.chans * sizeof(PSF_CHPEAK));

  003d7	48 63 84 24 24
	01 00 00	 movsxd	 rax, DWORD PTR OutputFile_Properties$[rsp+4]
  003df	48 c1 e0 03	 shl	 rax, 3
  003e3	48 8b c8	 mov	 rcx, rax
  003e6	e8 00 00 00 00	 call	 malloc
  003eb	48 89 44 24 60	 mov	 QWORD PTR PeakData$[rsp], rax

; 151  :     
; 152  :     if(PeakData == NULL)

  003f0	48 83 7c 24 60
	00		 cmp	 QWORD PTR PeakData$[rsp], 0
  003f6	75 20		 jne	 SHORT $LN30@main

; 153  :     {
; 154  :         puts("Error: No memory\n");

  003f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7262
  003ff	e8 00 00 00 00	 call	 puts

; 155  :         ErrorCode++;

  00404	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  00408	ff c0		 inc	 eax
  0040a	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 156  :         goto memory_cleanup;

  0040e	e9 2d 06 00 00	 jmp	 $LN31@main
  00413	e9 28 06 00 00	 jmp	 $memory_cleanup$60
$LN30@main:

; 157  :     }
; 158  :     
; 159  :     //Create output file for for reading/writing
; 160  :     OutputFile = psf_sndCreate(argv[ARG_OUTFILE], &OutputFile_Properties, 0, 0, PSF_CREATE_RDWR);

  00418	b8 08 00 00 00	 mov	 eax, 8
  0041d	48 6b c0 02	 imul	 rax, rax, 2
  00421	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00429	45 33 c9	 xor	 r9d, r9d
  0042c	45 33 c0	 xor	 r8d, r8d
  0042f	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR OutputFile_Properties$[rsp]
  00437	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0043f	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00443	e8 00 00 00 00	 call	 psf_sndCreate
  00448	89 44 24 40	 mov	 DWORD PTR OutputFile$[rsp], eax

; 161  : 
; 162  :     if(OutputFile < 0)

  0044c	83 7c 24 40 00	 cmp	 DWORD PTR OutputFile$[rsp], 0
  00451	7d 52		 jge	 SHORT $LN32@main

; 163  :     {
; 164  :         fprintf(stderr, "Error: Unable to create output file %s\n", argv[ARG_OUTFILE]);

  00453	b8 08 00 00 00	 mov	 eax, 8
  00458	48 6b c0 02	 imul	 rax, rax, 2
  0045c	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv210[rsp], rax
  00464	b9 02 00 00 00	 mov	 ecx, 2
  00469	e8 00 00 00 00	 call	 __acrt_iob_func
  0046e	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00476	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR tv210[rsp]
  0047e	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  00482	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7265
  00489	48 8b c8	 mov	 rcx, rax
  0048c	e8 00 00 00 00	 call	 fprintf

; 165  :         ErrorCode++;

  00491	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  00495	ff c0		 inc	 eax
  00497	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 166  :         goto memory_cleanup;

  0049b	e9 a0 05 00 00	 jmp	 $LN33@main
  004a0	e9 9b 05 00 00	 jmp	 $memory_cleanup$60
$LN32@main:

; 167  :     }
; 168  : 
; 169  :     //Breakpoint file processing
; 170  :     //Open text file
; 171  :     BreakpointFile = fopen(argv[ARG_BREAKPOINT_FILE], "r");

  004a5	b8 08 00 00 00	 mov	 eax, 8
  004aa	48 6b c0 03	 imul	 rax, rax, 3
  004ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7267
  004b5	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  004bd	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  004c1	e8 00 00 00 00	 call	 fopen
  004c6	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR BreakpointFile$[rsp], rax

; 172  :     
; 173  :         if(BreakpointFile == NULL)

  004ce	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR BreakpointFile$[rsp], 0
  004d7	75 52		 jne	 SHORT $LN34@main

; 174  :         {
; 175  :             fprintf(stderr, "Error: Unable to open breakpoint file %s\n", argv[ARG_BREAKPOINT_FILE]);

  004d9	b8 08 00 00 00	 mov	 eax, 8
  004de	48 6b c0 03	 imul	 rax, rax, 3
  004e2	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv224[rsp], rax
  004ea	b9 02 00 00 00	 mov	 ecx, 2
  004ef	e8 00 00 00 00	 call	 __acrt_iob_func
  004f4	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  004fc	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR tv224[rsp]
  00504	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  00508	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7269
  0050f	48 8b c8	 mov	 rcx, rax
  00512	e8 00 00 00 00	 call	 fprintf

; 176  :             ErrorCode++;

  00517	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  0051b	ff c0		 inc	 eax
  0051d	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 177  :             goto memory_cleanup;

  00521	e9 1a 05 00 00	 jmp	 $LN35@main
  00526	e9 15 05 00 00	 jmp	 $memory_cleanup$60
$LN34@main:

; 178  :         }    
; 179  : 
; 180  :     //Call function to gather breakpoints
; 181  :     ReadPoints = breakpoint_get_breakpoints(BreakpointFile, &BreakpointFile_Size);

  0052b	48 8d 54 24 68	 lea	 rdx, QWORD PTR BreakpointFile_Size$[rsp]
  00530	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR BreakpointFile$[rsp]
  00538	e8 00 00 00 00	 call	 ?breakpoint_get_breakpoints@@YAPEAUBreakpointFormat@@PEAU_iobuf@@PEAK@Z ; breakpoint_get_breakpoints
  0053d	48 89 44 24 58	 mov	 QWORD PTR ReadPoints$[rsp], rax

; 182  : 
; 183  :     if(ReadPoints == NULL)

  00542	48 83 7c 24 58
	00		 cmp	 QWORD PTR ReadPoints$[rsp], 0
  00548	75 2d		 jne	 SHORT $LN36@main

; 184  :     {
; 185  :         fprintf(stderr, "Error: No breakpoints read\n");

  0054a	b9 02 00 00 00	 mov	 ecx, 2
  0054f	e8 00 00 00 00	 call	 __acrt_iob_func
  00554	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7272
  0055b	48 8b c8	 mov	 rcx, rax
  0055e	e8 00 00 00 00	 call	 fprintf

; 186  :         ErrorCode++;

  00563	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  00567	ff c0		 inc	 eax
  00569	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 187  :         goto memory_cleanup;

  0056d	e9 ce 04 00 00	 jmp	 $LN37@main
  00572	e9 c9 04 00 00	 jmp	 $memory_cleanup$60
$LN36@main:

; 188  :     }
; 189  : 
; 190  :     //Check number of breakpoints in file
; 191  :     if(BreakpointFile_Size < 2)

  00577	83 7c 24 68 02	 cmp	 DWORD PTR BreakpointFile_Size$[rsp], 2
  0057c	73 3a		 jae	 SHORT $LN38@main

; 192  :     {
; 193  :         fprintf(stderr, "Error: At least two breakpoints required\n");

  0057e	b9 02 00 00 00	 mov	 ecx, 2
  00583	e8 00 00 00 00	 call	 __acrt_iob_func
  00588	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7275
  0058f	48 8b c8	 mov	 rcx, rax
  00592	e8 00 00 00 00	 call	 fprintf

; 194  : 		free(ReadPoints);

  00597	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ReadPoints$[rsp]
  0059c	e8 00 00 00 00	 call	 free

; 195  : 		fclose(BreakpointFile);

  005a1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR BreakpointFile$[rsp]
  005a9	e8 00 00 00 00	 call	 fclose

; 196  : 		return 1;

  005ae	b8 01 00 00 00	 mov	 eax, 1
  005b3	e9 53 05 00 00	 jmp	 $LN1@main
$LN38@main:

; 197  :     }
; 198  : 
; 199  :     //Check if first time value isn't 0
; 200  :     if(ReadPoints[0].BreakpointTime != 0.0)

  005b8	b8 10 00 00 00	 mov	 eax, 16
  005bd	48 6b c0 00	 imul	 rax, rax, 0
  005c1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ReadPoints$[rsp]
  005c6	f2 0f 10 04 01	 movsd	 xmm0, QWORD PTR [rcx+rax]
  005cb	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  005d3	7a 02		 jp	 SHORT $LN58@main
  005d5	74 55		 je	 SHORT $LN39@main
$LN58@main:

; 201  :     {
; 202  :         fprintf(stderr, "Error: First breakpoint time (%lf) must start from 0\n", ReadPoints[0].BreakpointTime);

  005d7	b8 10 00 00 00	 mov	 eax, 16
  005dc	48 6b c0 00	 imul	 rax, rax, 0
  005e0	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv252[rsp], rax
  005e8	b9 02 00 00 00	 mov	 ecx, 2
  005ed	e8 00 00 00 00	 call	 __acrt_iob_func
  005f2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ReadPoints$[rsp]
  005f7	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR tv252[rsp]
  005ff	f2 0f 10 14 11	 movsd	 xmm2, QWORD PTR [rcx+rdx]
  00604	66 49 0f 7e d0	 movq	 r8, xmm2
  00609	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7277
  00610	48 8b c8	 mov	 rcx, rax
  00613	e8 00 00 00 00	 call	 fprintf

; 203  :         ErrorCode++;

  00618	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  0061c	ff c0		 inc	 eax
  0061e	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 204  :         goto memory_cleanup;

  00622	e9 19 04 00 00	 jmp	 $LN40@main
  00627	e9 14 04 00 00	 jmp	 $memory_cleanup$60
$LN39@main:

; 205  :     }
; 206  : 
; 207  :     //Check if breakpoint values are out of range
; 208  :     if(!breakpoint_inputfile_range_check(ReadPoints, -1.0, 1.0, BreakpointFile_Size))

  0062c	44 8b 4c 24 68	 mov	 r9d, DWORD PTR BreakpointFile_Size$[rsp]
  00631	f2 0f 10 15 00
	00 00 00	 movsd	 xmm2, QWORD PTR __real@3ff0000000000000
  00639	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@bff0000000000000
  00641	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ReadPoints$[rsp]
  00646	e8 00 00 00 00	 call	 ?breakpoint_inputfile_range_check@@YAHPEBUBreakpointFormat@@NNK@Z ; breakpoint_inputfile_range_check
  0064b	85 c0		 test	 eax, eax
  0064d	75 2d		 jne	 SHORT $LN41@main

; 209  :     {
; 210  :         fprintf(stderr, "Error: Breakpoint values out of range\n");

  0064f	b9 02 00 00 00	 mov	 ecx, 2
  00654	e8 00 00 00 00	 call	 __acrt_iob_func
  00659	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7280
  00660	48 8b c8	 mov	 rcx, rax
  00663	e8 00 00 00 00	 call	 fprintf

; 211  :         ErrorCode++;

  00668	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  0066c	ff c0		 inc	 eax
  0066e	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 212  :         goto memory_cleanup;

  00672	e9 c9 03 00 00	 jmp	 $LN42@main
  00677	e9 c4 03 00 00	 jmp	 $memory_cleanup$60
$LN41@main:

; 213  :     } 
; 214  : 
; 215  :     //Stage 5: Processing loop
; 216  :     printf("Info: Processing...\n");

  0067c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7282
  00683	e8 00 00 00 00	 call	 printf

; 217  : 
; 218  :     FramesRead_Total = 0;

  00688	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR FramesRead_Total$[rsp], 0

; 219  :     PanPosition_Current = simple_pan_stereo(PanPosition);

  00690	f2 0f 10 8c 24
	90 00 00 00	 movsd	 xmm1, QWORD PTR PanPosition$[rsp]
  00699	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR $T8[rsp]
  006a1	e8 00 00 00 00	 call	 ?simple_pan_stereo@@YA?AUpan_position@@N@Z ; simple_pan_stereo
  006a6	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR $T10[rsp]
  006ae	48 8b f9	 mov	 rdi, rcx
  006b1	48 8b f0	 mov	 rsi, rax
  006b4	b9 10 00 00 00	 mov	 ecx, 16
  006b9	f3 a4		 rep movsb
  006bb	48 8d 84 24 50
	01 00 00	 lea	 rax, QWORD PTR PanPosition_Current$[rsp]
  006c3	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR $T10[rsp]
  006cb	48 8b f8	 mov	 rdi, rax
  006ce	48 8b f1	 mov	 rsi, rcx
  006d1	b9 10 00 00 00	 mov	 ecx, 16
  006d6	f3 a4		 rep movsb

; 220  :     TimeIncrement = 1.0 / InputFile_Properties.srate;

  006d8	f2 0f 2a 84 24
	38 01 00 00	 cvtsi2sd xmm0, DWORD PTR InputFile_Properties$[rsp]
  006e1	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  006e9	f2 0f 5e c8	 divsd	 xmm1, xmm0
  006ed	0f 28 c1	 movaps	 xmm0, xmm1
  006f0	f2 0f 11 84 24
	d0 00 00 00	 movsd	 QWORD PTR TimeIncrement$[rsp], xmm0

; 221  :     SampleTime = 0.0;

  006f9	0f 57 c0	 xorps	 xmm0, xmm0
  006fc	f2 0f 11 84 24
	98 00 00 00	 movsd	 QWORD PTR SampleTime$[rsp], xmm0
$LN6@main:

; 222  : 
; 223  :     //Main loop
; 224  :     while((FramesRead = psf_sndReadFloatFrames(InputFile, FramesInput, BufferSize)) > 0 )

  00705	44 8b 44 24 50	 mov	 r8d, DWORD PTR BufferSize$[rsp]
  0070a	48 8b 54 24 70	 mov	 rdx, QWORD PTR FramesInput$[rsp]
  0070f	8b 4c 24 4c	 mov	 ecx, DWORD PTR InputFile$[rsp]
  00713	e8 00 00 00 00	 call	 psf_sndReadFloatFrames
  00718	89 44 24 48	 mov	 DWORD PTR FramesRead$[rsp], eax
  0071c	83 7c 24 48 00	 cmp	 DWORD PTR FramesRead$[rsp], 0
  00721	0f 8e b6 01 00
	00		 jle	 $LN7@main

; 225  :     {
; 226  :         //Buffer processing
; 227  :         int Input_i, Output_i;
; 228  :         double StereoPan_Position;
; 229  : 
; 230  :         for(Input_i = 0, Output_i = 0; Input_i < FramesRead; Input_i++)

  00727	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR Input_i$4[rsp], 0
  0072f	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR Output_i$3[rsp], 0
  00737	eb 0a		 jmp	 SHORT $LN10@main
$LN8@main:
  00739	8b 44 24 44	 mov	 eax, DWORD PTR Input_i$4[rsp]
  0073d	ff c0		 inc	 eax
  0073f	89 44 24 44	 mov	 DWORD PTR Input_i$4[rsp], eax
$LN10@main:
  00743	8b 44 24 48	 mov	 eax, DWORD PTR FramesRead$[rsp]
  00747	39 44 24 44	 cmp	 DWORD PTR Input_i$4[rsp], eax
  0074b	0f 8d fa 00 00
	00		 jge	 $LN9@main

; 231  :         {
; 232  :             StereoPan_Position = breakpoint_value_at_breakpoint_time(ReadPoints, BreakpointFile_Size, SampleTime);

  00751	f2 0f 10 94 24
	98 00 00 00	 movsd	 xmm2, QWORD PTR SampleTime$[rsp]
  0075a	8b 54 24 68	 mov	 edx, DWORD PTR BreakpointFile_Size$[rsp]
  0075e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ReadPoints$[rsp]
  00763	e8 00 00 00 00	 call	 ?breakpoint_value_at_breakpoint_time@@YANPEBUBreakpointFormat@@KN@Z ; breakpoint_value_at_breakpoint_time
  00768	f2 0f 11 84 24
	c8 00 00 00	 movsd	 QWORD PTR StereoPan_Position$5[rsp], xmm0

; 233  :             PanPosition_Current = simple_pan_stereo(StereoPan_Position);

  00771	f2 0f 10 8c 24
	c8 00 00 00	 movsd	 xmm1, QWORD PTR StereoPan_Position$5[rsp]
  0077a	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR $T9[rsp]
  00782	e8 00 00 00 00	 call	 ?simple_pan_stereo@@YA?AUpan_position@@N@Z ; simple_pan_stereo
  00787	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR $T11[rsp]
  0078f	48 8b f9	 mov	 rdi, rcx
  00792	48 8b f0	 mov	 rsi, rax
  00795	b9 10 00 00 00	 mov	 ecx, 16
  0079a	f3 a4		 rep movsb
  0079c	48 8d 84 24 50
	01 00 00	 lea	 rax, QWORD PTR PanPosition_Current$[rsp]
  007a4	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR $T11[rsp]
  007ac	48 8b f8	 mov	 rdi, rax
  007af	48 8b f1	 mov	 rsi, rcx
  007b2	b9 10 00 00 00	 mov	 ecx, 16
  007b7	f3 a4		 rep movsb

; 234  :             FramesOutput[Output_i++] = (float) (FramesInput[Input_i]) * PanPosition_Current.PanLeft;

  007b9	48 63 44 24 44	 movsxd	 rax, DWORD PTR Input_i$4[rsp]
  007be	48 8b 4c 24 70	 mov	 rcx, QWORD PTR FramesInput$[rsp]
  007c3	f3 0f 10 04 81	 movss	 xmm0, DWORD PTR [rcx+rax*4]
  007c8	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  007cc	f2 0f 59 84 24
	50 01 00 00	 mulsd	 xmm0, QWORD PTR PanPosition_Current$[rsp]
  007d5	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  007d9	48 63 44 24 3c	 movsxd	 rax, DWORD PTR Output_i$3[rsp]
  007de	48 8b 4c 24 78	 mov	 rcx, QWORD PTR FramesOutput$[rsp]
  007e3	f3 0f 11 04 81	 movss	 DWORD PTR [rcx+rax*4], xmm0
  007e8	8b 44 24 3c	 mov	 eax, DWORD PTR Output_i$3[rsp]
  007ec	ff c0		 inc	 eax
  007ee	89 44 24 3c	 mov	 DWORD PTR Output_i$3[rsp], eax

; 235  :             FramesOutput[Output_i++] = (float) (FramesInput[Input_i]) * PanPosition_Current.PanRight;

  007f2	48 63 44 24 44	 movsxd	 rax, DWORD PTR Input_i$4[rsp]
  007f7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR FramesInput$[rsp]
  007fc	f3 0f 10 04 81	 movss	 xmm0, DWORD PTR [rcx+rax*4]
  00801	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00805	f2 0f 59 84 24
	58 01 00 00	 mulsd	 xmm0, QWORD PTR PanPosition_Current$[rsp+8]
  0080e	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00812	48 63 44 24 3c	 movsxd	 rax, DWORD PTR Output_i$3[rsp]
  00817	48 8b 4c 24 78	 mov	 rcx, QWORD PTR FramesOutput$[rsp]
  0081c	f3 0f 11 04 81	 movss	 DWORD PTR [rcx+rax*4], xmm0
  00821	8b 44 24 3c	 mov	 eax, DWORD PTR Output_i$3[rsp]
  00825	ff c0		 inc	 eax
  00827	89 44 24 3c	 mov	 DWORD PTR Output_i$3[rsp], eax

; 236  :             SampleTime += TimeIncrement;

  0082b	f2 0f 10 84 24
	98 00 00 00	 movsd	 xmm0, QWORD PTR SampleTime$[rsp]
  00834	f2 0f 58 84 24
	d0 00 00 00	 addsd	 xmm0, QWORD PTR TimeIncrement$[rsp]
  0083d	f2 0f 11 84 24
	98 00 00 00	 movsd	 QWORD PTR SampleTime$[rsp], xmm0

; 237  :         }

  00846	e9 ee fe ff ff	 jmp	 $LN8@main
$LN9@main:

; 238  : 
; 239  :         //Calculate total amount of frames read from the input file
; 240  :         FramesRead_Total++;

  0084b	8b 44 24 54	 mov	 eax, DWORD PTR FramesRead_Total$[rsp]
  0084f	ff c0		 inc	 eax
  00851	89 44 24 54	 mov	 DWORD PTR FramesRead_Total$[rsp], eax

; 241  :         
; 242  :         //Update progress for every X number of samples
; 243  :         if(FramesRead_Total % BufferSize == 0)

  00855	33 d2		 xor	 edx, edx
  00857	8b 44 24 54	 mov	 eax, DWORD PTR FramesRead_Total$[rsp]
  0085b	f7 74 24 50	 div	 DWORD PTR BufferSize$[rsp]
  0085f	8b c2		 mov	 eax, edx
  00861	85 c0		 test	 eax, eax
  00863	75 10		 jne	 SHORT $LN43@main

; 244  :         {
; 245  :             printf("Info: Copying %ld samples...\r", FramesRead_Total);

  00865	8b 54 24 54	 mov	 edx, DWORD PTR FramesRead_Total$[rsp]
  00869	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7284
  00870	e8 00 00 00 00	 call	 printf
$LN43@main:

; 246  :         }
; 247  : 
; 248  :         //Check for errors writing to the output file
; 249  :         if(psf_sndWriteFloatFrames(OutputFile, FramesOutput, FramesRead) != FramesRead)

  00875	44 8b 44 24 48	 mov	 r8d, DWORD PTR FramesRead$[rsp]
  0087a	48 8b 54 24 78	 mov	 rdx, QWORD PTR FramesOutput$[rsp]
  0087f	8b 4c 24 40	 mov	 ecx, DWORD PTR OutputFile$[rsp]
  00883	e8 00 00 00 00	 call	 psf_sndWriteFloatFrames
  00888	3b 44 24 48	 cmp	 eax, DWORD PTR FramesRead$[rsp]
  0088c	74 4a		 je	 SHORT $LN44@main

; 250  :         {
; 251  :             fprintf(stderr, "Error: Cannot write to ouput file %s\n", argv[ARG_OUTFILE]);

  0088e	b8 08 00 00 00	 mov	 eax, 8
  00893	48 6b c0 02	 imul	 rax, rax, 2
  00897	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv359[rsp], rax
  0089f	b9 02 00 00 00	 mov	 ecx, 2
  008a4	e8 00 00 00 00	 call	 __acrt_iob_func
  008a9	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  008b1	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR tv359[rsp]
  008b9	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  008bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7286
  008c4	48 8b c8	 mov	 rcx, rax
  008c7	e8 00 00 00 00	 call	 fprintf

; 252  :             ErrorCode++;

  008cc	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  008d0	ff c0		 inc	 eax
  008d2	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 253  :             break;

  008d6	eb 05		 jmp	 SHORT $LN7@main
$LN44@main:

; 254  :         }
; 255  :     }

  008d8	e9 28 fe ff ff	 jmp	 $LN6@main
$LN7@main:

; 256  : 
; 257  :     if(FramesRead < 0)

  008dd	83 7c 24 48 00	 cmp	 DWORD PTR FramesRead$[rsp], 0
  008e2	7d 6f		 jge	 SHORT $LN45@main

; 258  :     {
; 259  :         fprintf(stderr, "Error: Cannot read input file %s, output file %s is incomplete\n", argv[ARG_INFILE], argv[ARG_OUTFILE]);

  008e4	b8 08 00 00 00	 mov	 eax, 8
  008e9	48 6b c0 02	 imul	 rax, rax, 2
  008ed	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv368[rsp], rax
  008f5	b9 08 00 00 00	 mov	 ecx, 8
  008fa	48 6b c9 01	 imul	 rcx, rcx, 1
  008fe	48 89 8c 24 e8
	00 00 00	 mov	 QWORD PTR tv371[rsp], rcx
  00906	b9 02 00 00 00	 mov	 ecx, 2
  0090b	e8 00 00 00 00	 call	 __acrt_iob_func
  00910	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00918	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR tv368[rsp]
  00920	4c 8b 0c 11	 mov	 r9, QWORD PTR [rcx+rdx]
  00924	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0092c	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR tv371[rsp]
  00934	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  00938	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7289
  0093f	48 8b c8	 mov	 rcx, rax
  00942	e8 00 00 00 00	 call	 fprintf

; 260  :         ErrorCode++;

  00947	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  0094b	ff c0		 inc	 eax
  0094d	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 261  :     }
; 262  : 
; 263  :     else

  00951	eb 10		 jmp	 SHORT $LN46@main
$LN45@main:

; 264  :     {
; 265  :         printf("\nInfo: Done.\n"

  00953	8b 54 24 30	 mov	 edx, DWORD PTR ErrorCode$[rsp]
  00957	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7290
  0095e	e8 00 00 00 00	 call	 printf
$LN46@main:

; 266  :                "Info: %d errors\n", ErrorCode);
; 267  :     }
; 268  : 
; 269  :     //Stage 6: User reporting
; 270  :     //Check if any peak data was captured
; 271  :     if(psf_sndReadPeaks(OutputFile, PeakData, NULL) > 0)

  00963	45 33 c0	 xor	 r8d, r8d
  00966	48 8b 54 24 60	 mov	 rdx, QWORD PTR PeakData$[rsp]
  0096b	8b 4c 24 40	 mov	 ecx, DWORD PTR OutputFile$[rsp]
  0096f	e8 00 00 00 00	 call	 psf_sndReadPeaks
  00974	85 c0		 test	 eax, eax
  00976	0f 8e c4 00 00
	00		 jle	 $LN47@main

; 272  :     {
; 273  :         double PeakTime;
; 274  :         double PeakDB;
; 275  :         printf("Info: Peaks:\n");

  0097c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7292
  00983	e8 00 00 00 00	 call	 printf

; 276  : 
; 277  :         //Loop for every channel in the input file
; 278  :         for (long i = 0; i < OutputFile_Properties.chans; i++)

  00988	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  00990	eb 0a		 jmp	 SHORT $LN13@main
$LN11@main:
  00992	8b 44 24 38	 mov	 eax, DWORD PTR i$2[rsp]
  00996	ff c0		 inc	 eax
  00998	89 44 24 38	 mov	 DWORD PTR i$2[rsp], eax
$LN13@main:
  0099c	8b 84 24 24 01
	00 00		 mov	 eax, DWORD PTR OutputFile_Properties$[rsp+4]
  009a3	39 44 24 38	 cmp	 DWORD PTR i$2[rsp], eax
  009a7	0f 8d 93 00 00
	00		 jge	 $LN12@main

; 279  :         {
; 280  :             PeakTime = (double) PeakData[i].pos / (double) OutputFile_Properties.srate; //Calculate the time in seconds according the input file sample rate

  009ad	48 63 44 24 38	 movsxd	 rax, DWORD PTR i$2[rsp]
  009b2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR PeakData$[rsp]
  009b7	8b 44 c1 04	 mov	 eax, DWORD PTR [rcx+rax*8+4]
  009bb	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  009c0	f2 0f 2a 8c 24
	20 01 00 00	 cvtsi2sd xmm1, DWORD PTR OutputFile_Properties$[rsp]
  009c9	f2 0f 5e c1	 divsd	 xmm0, xmm1
  009cd	f2 0f 11 84 24
	f0 00 00 00	 movsd	 QWORD PTR PeakTime$6[rsp], xmm0

; 281  :             PeakDB = log10(PeakData[i].val); //Calculate dB values from linear values

  009d6	48 63 44 24 38	 movsxd	 rax, DWORD PTR i$2[rsp]
  009db	48 8b 4c 24 60	 mov	 rcx, QWORD PTR PeakData$[rsp]
  009e0	f3 0f 5a 04 c1	 cvtss2sd xmm0, DWORD PTR [rcx+rax*8]
  009e5	e8 00 00 00 00	 call	 log10
  009ea	f2 0f 11 84 24
	f8 00 00 00	 movsd	 QWORD PTR PeakDB$7[rsp], xmm0

; 282  :             printf("Channel %d:\t%.4f (%.4f dB) at %.4f seconds\n", i + 1, PeakData[i].val, PeakDB, PeakTime);

  009f3	48 63 44 24 38	 movsxd	 rax, DWORD PTR i$2[rsp]
  009f8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR PeakData$[rsp]
  009fd	f3 0f 5a 04 c1	 cvtss2sd xmm0, DWORD PTR [rcx+rax*8]
  00a02	8b 44 24 38	 mov	 eax, DWORD PTR i$2[rsp]
  00a06	ff c0		 inc	 eax
  00a08	f2 0f 10 8c 24
	f0 00 00 00	 movsd	 xmm1, QWORD PTR PeakTime$6[rsp]
  00a11	f2 0f 11 4c 24
	20		 movsd	 QWORD PTR [rsp+32], xmm1
  00a17	f2 0f 10 9c 24
	f8 00 00 00	 movsd	 xmm3, QWORD PTR PeakDB$7[rsp]
  00a20	66 49 0f 7e d9	 movq	 r9, xmm3
  00a25	0f 28 d0	 movaps	 xmm2, xmm0
  00a28	66 49 0f 7e d0	 movq	 r8, xmm2
  00a2d	8b d0		 mov	 edx, eax
  00a2f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7293
  00a36	e8 00 00 00 00	 call	 printf

; 283  :         }

  00a3b	e9 52 ff ff ff	 jmp	 $LN11@main
$LN12@main:
$LN47@main:
$LN23@main:
$LN25@main:
$LN27@main:
$LN29@main:
$LN31@main:
$LN33@main:
$LN35@main:
$LN37@main:
$LN40@main:
$LN42@main:
$memory_cleanup$60:

; 284  :     }
; 285  : 
; 286  :     //Stage 7: Cleanup
; 287  :     //Close all files and free all allocated memory
; 288  :     memory_cleanup:
; 289  : 
; 290  :     if(InputFile >= 0)

  00a40	83 7c 24 4c 00	 cmp	 DWORD PTR InputFile$[rsp], 0
  00a45	7c 2a		 jl	 SHORT $LN48@main

; 291  :     {
; 292  :         if(psf_sndClose(InputFile));

  00a47	8b 4c 24 4c	 mov	 ecx, DWORD PTR InputFile$[rsp]
  00a4b	e8 00 00 00 00	 call	 psf_sndClose

; 293  :         {
; 294  :             printf("Warning: Problem closing input file %s\n", argv[ARG_INFILE]);

  00a50	b8 08 00 00 00	 mov	 eax, 8
  00a55	48 6b c0 01	 imul	 rax, rax, 1
  00a59	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00a61	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  00a65	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7296
  00a6c	e8 00 00 00 00	 call	 printf
$LN48@main:

; 295  :         }
; 296  :     }
; 297  : 
; 298  :     if(OutputFile >= 0)

  00a71	83 7c 24 40 00	 cmp	 DWORD PTR OutputFile$[rsp], 0
  00a76	7c 2a		 jl	 SHORT $LN50@main

; 299  :     {
; 300  :         if(psf_sndClose(OutputFile));

  00a78	8b 4c 24 40	 mov	 ecx, DWORD PTR OutputFile$[rsp]
  00a7c	e8 00 00 00 00	 call	 psf_sndClose

; 301  :         {
; 302  :             printf("Warning: Problem closing output file %s\n", argv[ARG_OUTFILE]);

  00a81	b8 08 00 00 00	 mov	 eax, 8
  00a86	48 6b c0 02	 imul	 rax, rax, 2
  00a8a	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00a92	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  00a96	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7299
  00a9d	e8 00 00 00 00	 call	 printf
$LN50@main:

; 303  :         }
; 304  :     }
; 305  :     
; 306  :     if(BreakpointFile)

  00aa2	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR BreakpointFile$[rsp], 0
  00aab	74 0d		 je	 SHORT $LN52@main

; 307  :     {
; 308  :         fclose(BreakpointFile);

  00aad	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR BreakpointFile$[rsp]
  00ab5	e8 00 00 00 00	 call	 fclose
$LN52@main:

; 309  :     }
; 310  : 
; 311  :     if(FramesInput)

  00aba	48 83 7c 24 70
	00		 cmp	 QWORD PTR FramesInput$[rsp], 0
  00ac0	74 0a		 je	 SHORT $LN53@main

; 312  :     {
; 313  :         free(FramesInput);

  00ac2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR FramesInput$[rsp]
  00ac7	e8 00 00 00 00	 call	 free
$LN53@main:

; 314  :     }
; 315  : 
; 316  :     if(FramesOutput)

  00acc	48 83 7c 24 78
	00		 cmp	 QWORD PTR FramesOutput$[rsp], 0
  00ad2	74 0a		 je	 SHORT $LN54@main

; 317  :     {
; 318  :         free(FramesOutput);

  00ad4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR FramesOutput$[rsp]
  00ad9	e8 00 00 00 00	 call	 free
$LN54@main:

; 319  :     }
; 320  : 
; 321  :     if(PeakData)

  00ade	48 83 7c 24 60
	00		 cmp	 QWORD PTR PeakData$[rsp], 0
  00ae4	74 0a		 je	 SHORT $LN55@main

; 322  :     {
; 323  :         free(PeakData);

  00ae6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR PeakData$[rsp]
  00aeb	e8 00 00 00 00	 call	 free
$LN55@main:

; 324  :     }
; 325  : 
; 326  :     if(ReadPoints)

  00af0	48 83 7c 24 58
	00		 cmp	 QWORD PTR ReadPoints$[rsp], 0
  00af6	74 0a		 je	 SHORT $LN56@main

; 327  :     {
; 328  :         free(ReadPoints);

  00af8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ReadPoints$[rsp]
  00afd	e8 00 00 00 00	 call	 free
$LN56@main:

; 329  :     }
; 330  : 
; 331  :     //Close portsf library
; 332  :     psf_finish();

  00b02	e8 00 00 00 00	 call	 psf_finish

; 333  : 
; 334  :     return ErrorCode;

  00b07	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
$LN1@main:

; 335  : }

  00b0b	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00b13	48 33 cc	 xor	 rcx, rsp
  00b16	e8 00 00 00 00	 call	 __security_check_cookie
  00b1b	48 81 c4 98 01
	00 00		 add	 rsp, 408		; 00000198H
  00b22	5f		 pop	 rdi
  00b23	5e		 pop	 rsi
  00b24	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\chapter_2\2.3.3\code\soundfile_pan.cpp
_TEXT	SEGMENT
StereoPosition$ = 0
__$ArrayPad$ = 16
$T1 = 64
PanPosition$ = 72
?simple_pan_stereo@@YA?AUpan_position@@N@Z PROC		; simple_pan_stereo

; 338  : {

$LN3:
  00000	f2 0f 11 4c 24
	10		 movsd	 QWORD PTR [rsp+16], xmm1
  00006	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 44 24 10	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 339  :     PAN_POSITION StereoPosition;
; 340  :     
; 341  :     PanPosition *= 0.5;

  00020	f2 0f 10 44 24
	48		 movsd	 xmm0, QWORD PTR PanPosition$[rsp]
  00026	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fe0000000000000
  0002e	f2 0f 11 44 24
	48		 movsd	 QWORD PTR PanPosition$[rsp], xmm0

; 342  :     StereoPosition.PanLeft = PanPosition - 0.5;

  00034	f2 0f 10 44 24
	48		 movsd	 xmm0, QWORD PTR PanPosition$[rsp]
  0003a	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00042	f2 0f 11 04 24	 movsd	 QWORD PTR StereoPosition$[rsp], xmm0

; 343  :     StereoPosition.PanRight = PanPosition + 0.5;

  00047	f2 0f 10 44 24
	48		 movsd	 xmm0, QWORD PTR PanPosition$[rsp]
  0004d	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00055	f2 0f 11 44 24
	08		 movsd	 QWORD PTR StereoPosition$[rsp+8], xmm0

; 344  : 
; 345  :     return StereoPosition;

  0005b	48 8d 04 24	 lea	 rax, QWORD PTR StereoPosition$[rsp]
  0005f	48 8b 7c 24 40	 mov	 rdi, QWORD PTR $T1[rsp]
  00064	48 8b f0	 mov	 rsi, rax
  00067	b9 10 00 00 00	 mov	 ecx, 16
  0006c	f3 a4		 rep movsb
  0006e	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]

; 346  : }

  00073	48 8b 4c 24 10	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00078	48 33 cc	 xor	 rcx, rsp
  0007b	e8 00 00 00 00	 call	 __security_check_cookie
  00080	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00084	5f		 pop	 rdi
  00085	5e		 pop	 rsi
  00086	c3		 ret	 0
?simple_pan_stereo@@YA?AUpan_position@@N@Z ENDP		; simple_pan_stereo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 952  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 953  :         int _Result;
; 954  :         va_list _ArgList;
; 955  :         __crt_va_start(_ArgList, _Format);

  00018	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
  0001d	48 8d 44 24 48	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00022	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 956  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00027	b9 01 00 00 00	 mov	 ecx, 1
  0002c	e8 00 00 00 00	 call	 __acrt_iob_func
  00031	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00036	45 33 c0	 xor	 r8d, r8d
  00039	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Format$[rsp]
  0003e	48 8b c8	 mov	 rcx, rax
  00041	e8 00 00 00 00	 call	 _vfprintf_l
  00046	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 957  :         __crt_va_end(_ArgList);

  0004a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 958  :         return _Result;

  00053	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 959  :     }

  00057	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005b	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.11.25503\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>, COMDAT

; 151  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 152  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Stream$ = 64
_Format$ = 72
fprintf	PROC						; COMDAT

; 833  :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 834  :         int _Result;
; 835  :         va_list _ArgList;
; 836  :         __crt_va_start(_ArgList, _Format);

  00018	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
  0001d	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00022	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 837  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00027	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0002c	45 33 c0	 xor	 r8d, r8d
  0002f	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Stream$[rsp]
  00039	e8 00 00 00 00	 call	 _vfprintf_l
  0003e	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 838  :         __crt_va_end(_ArgList);

  00042	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 839  :         return _Result;

  0004b	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 840  :     }

  0004f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00053	c3		 ret	 0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 640  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 641  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	e8 00 00 00 00	 call	 __stdio_common_vfprintf

; 642  :     }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 86   :         static unsigned __int64 _OptionsStorage;
; 87   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 88   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
