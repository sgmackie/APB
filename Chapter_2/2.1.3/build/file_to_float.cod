; Listing generated by Microsoft (R) Optimizing Compiler Version 19.11.25507.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG7949	DB	'file_to_float: Convert soundfile to float sample format', 0aH
	DB	00H
	ORG $+7
$SG7951	DB	'Error: Insufficient number of arguments', 0aH, 'Usage: f'
	DB	'ile_to_float.exe, input file, output file, buffer size', 0aH, 00H
$SG7953	DB	'Error: Unable to start portsf', 0aH, 00H
	ORG $+1
$SG7955	DB	'Error: Unable to open input file %s', 0aH, 00H
	ORG $+3
$SG7957	DB	'Info: Input file %s is already in float format', 0aH, 00H
$SG7959	DB	'Error: Buffer size must be at least 1', 0aH, 00H
	ORG $+1
$SG7961	DB	'Error: Output file %s has unknown format', 0aH, 00H
	ORG $+6
$SG7963	DB	'Error: Unable to create output file %s', 0aH, 00H
$SG7965	DB	'Error: No memory', 0aH, 00H
	ORG $+6
$SG7967	DB	'Error: No memory', 0aH, 00H
	ORG $+6
$SG7968	DB	'Info: Copying...', 0aH, 00H
	ORG $+6
$SG7970	DB	'Error: Cannot write to ouput file %s', 0aH, 00H
	ORG $+2
$SG7973	DB	'Error: Cannot read input file %s, output file %s is inco'
	DB	'mplete', 0aH, 00H
$SG7974	DB	'Info: Done.', 0aH, 'Info: %d sample frames copied to %s', 0aH
	DB	00H
	ORG $+7
$SG7976	DB	'Info: Peaks:', 0aH, 00H
	ORG $+2
$SG7977	DB	'Channel %d:', 09H, '%.4f (%.4f dB) at %.4f seconds', 0aH
	DB	00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	fprintf
PUBLIC	printf
PUBLIC	main
EXTRN	__acrt_iob_func:PROC
EXTRN	puts:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	free:PROC
EXTRN	malloc:PROC
EXTRN	atoi:PROC
EXTRN	log10:PROC
EXTRN	psf_init:PROC
EXTRN	psf_finish:PROC
EXTRN	psf_sndCreate:PROC
EXTRN	psf_sndOpen:PROC
EXTRN	psf_sndClose:PROC
EXTRN	psf_sndWriteFloatFrames:PROC
EXTRN	psf_sndReadFloatFrames:PROC
EXTRN	psf_sndReadPeaks:PROC
EXTRN	psf_getFormatExt:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$fprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$printf
pdata	ENDS
pdata	SEGMENT
$pdata$main DD	imagerel $LN25
	DD	imagerel $LN25+1479
	DD	imagerel $unwind$main
pdata	ENDS
xdata	SEGMENT
$unwind$main DD	022219H
	DD	01b0110H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\chapter_2\2.1.3\code\file_to_float.c
_TEXT	SEGMENT
ErrorCode$ = 48
i$1 = 52
InputFile$ = 56
OutputFile$ = 60
BufferSize$ = 64
OutputFile_Peaks$ = 72
OutputFile_Format$ = 80
FramesRead$ = 84
FramesRead_Total$ = 88
Buffer$ = 96
tv84 = 104
tv142 = 112
tv159 = 120
tv201 = 128
tv214 = 136
tv217 = 144
PeakTime$2 = 152
PeakDB$3 = 160
FileProperties$ = 168
__$ArrayPad$ = 192
argc$ = 224
argv$ = 232
main	PROC

; 9    : {

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 10   :     PSF_PROPS FileProperties;
; 11   :     long FramesRead, FramesRead_Total;
; 12   : 
; 13   :     int InputFile = -1;

  00022	c7 44 24 38 ff
	ff ff ff	 mov	 DWORD PTR InputFile$[rsp], -1

; 14   :     int OutputFile = -1;

  0002a	c7 44 24 3c ff
	ff ff ff	 mov	 DWORD PTR OutputFile$[rsp], -1

; 15   :     int ErrorCode = 0;

  00032	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR ErrorCode$[rsp], 0

; 16   :     psf_format OutputFile_Format = PSF_FMT_UNKNOWN;

  0003a	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR OutputFile_Format$[rsp], 0

; 17   :     PSF_CHPEAK *OutputFile_Peaks = NULL;

  00042	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR OutputFile_Peaks$[rsp], 0

; 18   :     float *Buffer = NULL;

  0004b	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR Buffer$[rsp], 0

; 19   :     DWORD BufferSize;
; 20   : 
; 21   :     printf("file_to_float: Convert soundfile to float sample format\n");

  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7949
  0005b	e8 00 00 00 00	 call	 printf

; 22   : 
; 23   :     if(argc < ARG_NUM_ARGS)

  00060	83 bc 24 e0 00
	00 00 04	 cmp	 DWORD PTR argc$[rsp], 4
  00068	7d 23		 jge	 SHORT $LN7@main

; 24   :     {
; 25   :         fprintf(stderr, "Error: Insufficient number of arguments\n"

  0006a	b9 02 00 00 00	 mov	 ecx, 2
  0006f	e8 00 00 00 00	 call	 __acrt_iob_func
  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7951
  0007b	48 8b c8	 mov	 rcx, rax
  0007e	e8 00 00 00 00	 call	 fprintf

; 26   :                         "Usage: file_to_float.exe, input file, output file, buffer size\n");
; 27   :         return 1;

  00083	b8 01 00 00 00	 mov	 eax, 1
  00088	e9 22 05 00 00	 jmp	 $LN1@main
$LN7@main:

; 28   :     }
; 29   : 
; 30   :     if(psf_init())

  0008d	e8 00 00 00 00	 call	 psf_init
  00092	85 c0		 test	 eax, eax
  00094	74 23		 je	 SHORT $LN8@main

; 31   :     {
; 32   :         fprintf(stderr, "Error: Unable to start portsf\n");

  00096	b9 02 00 00 00	 mov	 ecx, 2
  0009b	e8 00 00 00 00	 call	 __acrt_iob_func
  000a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7953
  000a7	48 8b c8	 mov	 rcx, rax
  000aa	e8 00 00 00 00	 call	 fprintf

; 33   :         return 1;

  000af	b8 01 00 00 00	 mov	 eax, 1
  000b4	e9 f6 04 00 00	 jmp	 $LN1@main
$LN8@main:

; 34   :     }
; 35   :     
; 36   :     InputFile = psf_sndOpen(argv[ARG_INFILE], &FileProperties, 0);

  000b9	b8 08 00 00 00	 mov	 eax, 8
  000be	48 6b c0 01	 imul	 rax, rax, 1
  000c2	45 33 c0	 xor	 r8d, r8d
  000c5	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR FileProperties$[rsp]
  000cd	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000d5	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  000d9	e8 00 00 00 00	 call	 psf_sndOpen
  000de	89 44 24 38	 mov	 DWORD PTR InputFile$[rsp], eax

; 37   : 
; 38   :     if(InputFile < 0)

  000e2	83 7c 24 38 00	 cmp	 DWORD PTR InputFile$[rsp], 0
  000e7	7d 42		 jge	 SHORT $LN9@main

; 39   :     {
; 40   :         fprintf(stderr, "Error: Unable to open input file %s\n", argv[ARG_NAME]);

  000e9	b8 08 00 00 00	 mov	 eax, 8
  000ee	48 6b c0 00	 imul	 rax, rax, 0
  000f2	48 89 44 24 68	 mov	 QWORD PTR tv84[rsp], rax
  000f7	b9 02 00 00 00	 mov	 ecx, 2
  000fc	e8 00 00 00 00	 call	 __acrt_iob_func
  00101	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00109	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv84[rsp]
  0010e	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  00112	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7955
  00119	48 8b c8	 mov	 rcx, rax
  0011c	e8 00 00 00 00	 call	 fprintf

; 41   :         return 1;

  00121	b8 01 00 00 00	 mov	 eax, 1
  00126	e9 84 04 00 00	 jmp	 $LN1@main
$LN9@main:

; 42   :     }
; 43   : 
; 44   :     if(FileProperties.samptype == PSF_SAMP_IEEE_FLOAT)

  0012b	83 bc 24 b0 00
	00 00 05	 cmp	 DWORD PTR FileProperties$[rsp+8], 5
  00133	75 2b		 jne	 SHORT $LN10@main

; 45   :     {
; 46   :         printf("Info: Input file %s is already in float format\n", argv[ARG_INFILE]);

  00135	b8 08 00 00 00	 mov	 eax, 8
  0013a	48 6b c0 01	 imul	 rax, rax, 1
  0013e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00146	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  0014a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7957
  00151	e8 00 00 00 00	 call	 printf

; 47   :         return 1;

  00156	b8 01 00 00 00	 mov	 eax, 1
  0015b	e9 4f 04 00 00	 jmp	 $LN1@main
$LN10@main:

; 48   :     }
; 49   : 
; 50   :     BufferSize = (DWORD) atoi(argv[ARG_BUFFER_SIZE]);

  00160	b8 08 00 00 00	 mov	 eax, 8
  00165	48 6b c0 03	 imul	 rax, rax, 3
  00169	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00171	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00175	e8 00 00 00 00	 call	 atoi
  0017a	89 44 24 40	 mov	 DWORD PTR BufferSize$[rsp], eax

; 51   :     
; 52   :     if(BufferSize < 1)

  0017e	83 7c 24 40 01	 cmp	 DWORD PTR BufferSize$[rsp], 1
  00183	73 23		 jae	 SHORT $LN11@main

; 53   :     {
; 54   :         fprintf(stderr, "Error: Buffer size must be at least 1\n");

  00185	b9 02 00 00 00	 mov	 ecx, 2
  0018a	e8 00 00 00 00	 call	 __acrt_iob_func
  0018f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7959
  00196	48 8b c8	 mov	 rcx, rax
  00199	e8 00 00 00 00	 call	 fprintf

; 55   :         return 1;

  0019e	b8 01 00 00 00	 mov	 eax, 1
  001a3	e9 07 04 00 00	 jmp	 $LN1@main
$LN11@main:

; 56   :     }
; 57   : 
; 58   :     FileProperties.samptype = PSF_SAMP_IEEE_FLOAT;

  001a8	c7 84 24 b0 00
	00 00 05 00 00
	00		 mov	 DWORD PTR FileProperties$[rsp+8], 5

; 59   :     OutputFile_Format = psf_getFormatExt(argv[ARG_OUTFILE]);

  001b3	b8 08 00 00 00	 mov	 eax, 8
  001b8	48 6b c0 02	 imul	 rax, rax, 2
  001bc	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001c4	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  001c8	e8 00 00 00 00	 call	 psf_getFormatExt
  001cd	89 44 24 50	 mov	 DWORD PTR OutputFile_Format$[rsp], eax

; 60   : 
; 61   :     if(OutputFile_Format == PSF_FMT_UNKNOWN)

  001d1	83 7c 24 50 00	 cmp	 DWORD PTR OutputFile_Format$[rsp], 0
  001d6	75 47		 jne	 SHORT $LN12@main

; 62   :     {
; 63   :         fprintf(stderr, "Error: Output file %s has unknown format\n", argv[ARG_OUTFILE]);

  001d8	b8 08 00 00 00	 mov	 eax, 8
  001dd	48 6b c0 02	 imul	 rax, rax, 2
  001e1	48 89 44 24 70	 mov	 QWORD PTR tv142[rsp], rax
  001e6	b9 02 00 00 00	 mov	 ecx, 2
  001eb	e8 00 00 00 00	 call	 __acrt_iob_func
  001f0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001f8	48 8b 54 24 70	 mov	 rdx, QWORD PTR tv142[rsp]
  001fd	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  00201	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7961
  00208	48 8b c8	 mov	 rcx, rax
  0020b	e8 00 00 00 00	 call	 fprintf

; 64   :         ErrorCode++;

  00210	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  00214	ff c0		 inc	 eax
  00216	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 65   :         goto memory_cleanup;

  0021a	e9 43 03 00 00	 jmp	 $memory_cleanup$26
$LN12@main:

; 66   :     }
; 67   : 
; 68   :     FileProperties.format = OutputFile_Format;

  0021f	8b 44 24 50	 mov	 eax, DWORD PTR OutputFile_Format$[rsp]
  00223	89 84 24 b4 00
	00 00		 mov	 DWORD PTR FileProperties$[rsp+12], eax

; 69   :     OutputFile = psf_sndCreate(argv[ARG_OUTFILE], &FileProperties, 0, 0, PSF_CREATE_RDWR);

  0022a	b8 08 00 00 00	 mov	 eax, 8
  0022f	48 6b c0 02	 imul	 rax, rax, 2
  00233	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0023b	45 33 c9	 xor	 r9d, r9d
  0023e	45 33 c0	 xor	 r8d, r8d
  00241	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR FileProperties$[rsp]
  00249	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00251	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00255	e8 00 00 00 00	 call	 psf_sndCreate
  0025a	89 44 24 3c	 mov	 DWORD PTR OutputFile$[rsp], eax

; 70   : 
; 71   :     if(OutputFile < 0)

  0025e	83 7c 24 3c 00	 cmp	 DWORD PTR OutputFile$[rsp], 0
  00263	7d 47		 jge	 SHORT $LN13@main

; 72   :     {
; 73   :         fprintf(stderr, "Error: Unable to create output file %s\n", argv[ARG_OUTFILE]);

  00265	b8 08 00 00 00	 mov	 eax, 8
  0026a	48 6b c0 02	 imul	 rax, rax, 2
  0026e	48 89 44 24 78	 mov	 QWORD PTR tv159[rsp], rax
  00273	b9 02 00 00 00	 mov	 ecx, 2
  00278	e8 00 00 00 00	 call	 __acrt_iob_func
  0027d	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00285	48 8b 54 24 78	 mov	 rdx, QWORD PTR tv159[rsp]
  0028a	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  0028e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7963
  00295	48 8b c8	 mov	 rcx, rax
  00298	e8 00 00 00 00	 call	 fprintf

; 74   :         ErrorCode++;

  0029d	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  002a1	ff c0		 inc	 eax
  002a3	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 75   :         goto memory_cleanup;

  002a7	e9 b6 02 00 00	 jmp	 $memory_cleanup$26
$LN13@main:

; 76   :     }
; 77   : 
; 78   :     Buffer = (float*) malloc(FileProperties.chans * sizeof(float) * BufferSize);

  002ac	48 63 84 24 ac
	00 00 00	 movsxd	 rax, DWORD PTR FileProperties$[rsp+4]
  002b4	48 c1 e0 02	 shl	 rax, 2
  002b8	8b 4c 24 40	 mov	 ecx, DWORD PTR BufferSize$[rsp]
  002bc	48 0f af c1	 imul	 rax, rcx
  002c0	48 8b c8	 mov	 rcx, rax
  002c3	e8 00 00 00 00	 call	 malloc
  002c8	48 89 44 24 60	 mov	 QWORD PTR Buffer$[rsp], rax

; 79   : 
; 80   :     if(Buffer == NULL)

  002cd	48 83 7c 24 60
	00		 cmp	 QWORD PTR Buffer$[rsp], 0
  002d3	75 1b		 jne	 SHORT $LN14@main

; 81   :     {
; 82   :         //Puts uses less system memory than printf, applicable for severe memory errors
; 83   :         puts("Error: No memory\n");

  002d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7965
  002dc	e8 00 00 00 00	 call	 puts

; 84   :         ErrorCode++;

  002e1	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  002e5	ff c0		 inc	 eax
  002e7	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 85   :         goto memory_cleanup;

  002eb	e9 72 02 00 00	 jmp	 $memory_cleanup$26
$LN14@main:

; 86   :     }
; 87   : 
; 88   :     OutputFile_Peaks = (PSF_CHPEAK*) malloc(FileProperties.chans * sizeof(PSF_CHPEAK));

  002f0	48 63 84 24 ac
	00 00 00	 movsxd	 rax, DWORD PTR FileProperties$[rsp+4]
  002f8	48 c1 e0 03	 shl	 rax, 3
  002fc	48 8b c8	 mov	 rcx, rax
  002ff	e8 00 00 00 00	 call	 malloc
  00304	48 89 44 24 48	 mov	 QWORD PTR OutputFile_Peaks$[rsp], rax

; 89   : 
; 90   :     if(OutputFile_Peaks == NULL)

  00309	48 83 7c 24 48
	00		 cmp	 QWORD PTR OutputFile_Peaks$[rsp], 0
  0030f	75 1b		 jne	 SHORT $LN15@main

; 91   :     {
; 92   :         puts("Error: No memory\n");

  00311	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7967
  00318	e8 00 00 00 00	 call	 puts

; 93   :         ErrorCode++;

  0031d	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  00321	ff c0		 inc	 eax
  00323	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 94   :         goto memory_cleanup;

  00327	e9 36 02 00 00	 jmp	 $memory_cleanup$26
$LN15@main:

; 95   :     }
; 96   : 
; 97   :     printf("Info: Copying...\n");

  0032c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7968
  00333	e8 00 00 00 00	 call	 printf

; 98   : 
; 99   :     FramesRead = psf_sndReadFloatFrames(InputFile, Buffer, BufferSize);

  00338	44 8b 44 24 40	 mov	 r8d, DWORD PTR BufferSize$[rsp]
  0033d	48 8b 54 24 60	 mov	 rdx, QWORD PTR Buffer$[rsp]
  00342	8b 4c 24 38	 mov	 ecx, DWORD PTR InputFile$[rsp]
  00346	e8 00 00 00 00	 call	 psf_sndReadFloatFrames
  0034b	89 44 24 54	 mov	 DWORD PTR FramesRead$[rsp], eax

; 100  :     FramesRead_Total = 0;

  0034f	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR FramesRead_Total$[rsp], 0
$LN2@main:

; 101  :     
; 102  :     while(FramesRead == 1)

  00357	83 7c 24 54 01	 cmp	 DWORD PTR FramesRead$[rsp], 1
  0035c	0f 85 88 00 00
	00		 jne	 $LN3@main

; 103  :     {
; 104  :         FramesRead_Total++;

  00362	8b 44 24 58	 mov	 eax, DWORD PTR FramesRead_Total$[rsp]
  00366	ff c0		 inc	 eax
  00368	89 44 24 58	 mov	 DWORD PTR FramesRead_Total$[rsp], eax

; 105  : 
; 106  :         if(psf_sndWriteFloatFrames(OutputFile, Buffer, BufferSize) != 1)

  0036c	44 8b 44 24 40	 mov	 r8d, DWORD PTR BufferSize$[rsp]
  00371	48 8b 54 24 60	 mov	 rdx, QWORD PTR Buffer$[rsp]
  00376	8b 4c 24 3c	 mov	 ecx, DWORD PTR OutputFile$[rsp]
  0037a	e8 00 00 00 00	 call	 psf_sndWriteFloatFrames
  0037f	83 f8 01	 cmp	 eax, 1
  00382	74 4a		 je	 SHORT $LN16@main

; 107  :         {
; 108  :             fprintf(stderr, "Error: Cannot write to ouput file %s\n", argv[ARG_OUTFILE]);

  00384	b8 08 00 00 00	 mov	 eax, 8
  00389	48 6b c0 02	 imul	 rax, rax, 2
  0038d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv201[rsp], rax
  00395	b9 02 00 00 00	 mov	 ecx, 2
  0039a	e8 00 00 00 00	 call	 __acrt_iob_func
  0039f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  003a7	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR tv201[rsp]
  003af	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  003b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7970
  003ba	48 8b c8	 mov	 rcx, rax
  003bd	e8 00 00 00 00	 call	 fprintf

; 109  :             ErrorCode++;

  003c2	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  003c6	ff c0		 inc	 eax
  003c8	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 110  :             break;

  003cc	eb 1c		 jmp	 SHORT $LN3@main
$LN16@main:

; 111  :         }
; 112  : 
; 113  :         FramesRead = psf_sndReadFloatFrames(InputFile, Buffer, BufferSize);

  003ce	44 8b 44 24 40	 mov	 r8d, DWORD PTR BufferSize$[rsp]
  003d3	48 8b 54 24 60	 mov	 rdx, QWORD PTR Buffer$[rsp]
  003d8	8b 4c 24 38	 mov	 ecx, DWORD PTR InputFile$[rsp]
  003dc	e8 00 00 00 00	 call	 psf_sndReadFloatFrames
  003e1	89 44 24 54	 mov	 DWORD PTR FramesRead$[rsp], eax

; 114  :     }

  003e5	e9 6d ff ff ff	 jmp	 $LN2@main
$LN3@main:

; 115  : 
; 116  :     if(FramesRead < 0)

  003ea	83 7c 24 54 00	 cmp	 DWORD PTR FramesRead$[rsp], 0
  003ef	7d 6f		 jge	 SHORT $LN17@main

; 117  :     {
; 118  :         fprintf(stderr, "Error: Cannot read input file %s, output file %s is incomplete\n", argv[ARG_INFILE], argv[ARG_OUTFILE]);

  003f1	b8 08 00 00 00	 mov	 eax, 8
  003f6	48 6b c0 02	 imul	 rax, rax, 2
  003fa	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv214[rsp], rax
  00402	b9 08 00 00 00	 mov	 ecx, 8
  00407	48 6b c9 01	 imul	 rcx, rcx, 1
  0040b	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR tv217[rsp], rcx
  00413	b9 02 00 00 00	 mov	 ecx, 2
  00418	e8 00 00 00 00	 call	 __acrt_iob_func
  0041d	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00425	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR tv214[rsp]
  0042d	4c 8b 0c 11	 mov	 r9, QWORD PTR [rcx+rdx]
  00431	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00439	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tv217[rsp]
  00441	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  00445	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7973
  0044c	48 8b c8	 mov	 rcx, rax
  0044f	e8 00 00 00 00	 call	 fprintf

; 119  :         ErrorCode++;

  00454	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  00458	ff c0		 inc	 eax
  0045a	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 120  :     }

  0045e	eb 25		 jmp	 SHORT $LN18@main
$LN17@main:

; 121  : 
; 122  :     else
; 123  :     {
; 124  :         printf("Info: Done.\n"

  00460	b8 08 00 00 00	 mov	 eax, 8
  00465	48 6b c0 02	 imul	 rax, rax, 2
  00469	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00471	4c 8b 04 01	 mov	 r8, QWORD PTR [rcx+rax]
  00475	8b 54 24 58	 mov	 edx, DWORD PTR FramesRead_Total$[rsp]
  00479	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7974
  00480	e8 00 00 00 00	 call	 printf
$LN18@main:

; 125  :                "Info: %d sample frames copied to %s\n", FramesRead_Total, argv[ARG_OUTFILE]);
; 126  :     }
; 127  : 
; 128  :     if(psf_sndReadPeaks(OutputFile, OutputFile_Peaks, NULL) > 0)

  00485	45 33 c0	 xor	 r8d, r8d
  00488	48 8b 54 24 48	 mov	 rdx, QWORD PTR OutputFile_Peaks$[rsp]
  0048d	8b 4c 24 3c	 mov	 ecx, DWORD PTR OutputFile$[rsp]
  00491	e8 00 00 00 00	 call	 psf_sndReadPeaks
  00496	85 c0		 test	 eax, eax
  00498	0f 8e c4 00 00
	00		 jle	 $LN19@main

; 129  :     {
; 130  :         double PeakTime;
; 131  :         double PeakDB;
; 132  :         printf("Info: Peaks:\n");

  0049e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7976
  004a5	e8 00 00 00 00	 call	 printf

; 133  : 
; 134  :         for (long i = 0; i < FileProperties.chans; i++)

  004aa	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  004b2	eb 0a		 jmp	 SHORT $LN6@main
$LN4@main:
  004b4	8b 44 24 34	 mov	 eax, DWORD PTR i$1[rsp]
  004b8	ff c0		 inc	 eax
  004ba	89 44 24 34	 mov	 DWORD PTR i$1[rsp], eax
$LN6@main:
  004be	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR FileProperties$[rsp+4]
  004c5	39 44 24 34	 cmp	 DWORD PTR i$1[rsp], eax
  004c9	0f 8d 93 00 00
	00		 jge	 $LN5@main

; 135  :         {
; 136  :             PeakTime = (double) OutputFile_Peaks[i].pos / FileProperties.srate;

  004cf	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$1[rsp]
  004d4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR OutputFile_Peaks$[rsp]
  004d9	8b 44 c1 04	 mov	 eax, DWORD PTR [rcx+rax*8+4]
  004dd	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  004e2	f2 0f 2a 8c 24
	a8 00 00 00	 cvtsi2sd xmm1, DWORD PTR FileProperties$[rsp]
  004eb	f2 0f 5e c1	 divsd	 xmm0, xmm1
  004ef	f2 0f 11 84 24
	98 00 00 00	 movsd	 QWORD PTR PeakTime$2[rsp], xmm0

; 137  :             PeakDB = log10(OutputFile_Peaks[i].val);

  004f8	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$1[rsp]
  004fd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR OutputFile_Peaks$[rsp]
  00502	f3 0f 5a 04 c1	 cvtss2sd xmm0, DWORD PTR [rcx+rax*8]
  00507	e8 00 00 00 00	 call	 log10
  0050c	f2 0f 11 84 24
	a0 00 00 00	 movsd	 QWORD PTR PeakDB$3[rsp], xmm0

; 138  :             printf("Channel %d:\t%.4f (%.4f dB) at %.4f seconds\n", i + 1, OutputFile_Peaks[i].val, PeakDB, PeakTime);

  00515	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$1[rsp]
  0051a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR OutputFile_Peaks$[rsp]
  0051f	f3 0f 5a 04 c1	 cvtss2sd xmm0, DWORD PTR [rcx+rax*8]
  00524	8b 44 24 34	 mov	 eax, DWORD PTR i$1[rsp]
  00528	ff c0		 inc	 eax
  0052a	f2 0f 10 8c 24
	98 00 00 00	 movsd	 xmm1, QWORD PTR PeakTime$2[rsp]
  00533	f2 0f 11 4c 24
	20		 movsd	 QWORD PTR [rsp+32], xmm1
  00539	f2 0f 10 9c 24
	a0 00 00 00	 movsd	 xmm3, QWORD PTR PeakDB$3[rsp]
  00542	66 49 0f 7e d9	 movq	 r9, xmm3
  00547	0f 28 d0	 movaps	 xmm2, xmm0
  0054a	66 49 0f 7e d0	 movq	 r8, xmm2
  0054f	8b d0		 mov	 edx, eax
  00551	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7977
  00558	e8 00 00 00 00	 call	 printf

; 139  :         }

  0055d	e9 52 ff ff ff	 jmp	 $LN4@main
$LN5@main:
$LN19@main:
$memory_cleanup$26:

; 140  :     }
; 141  : 
; 142  :     memory_cleanup:
; 143  : 
; 144  :     if(InputFile >= 0)

  00562	83 7c 24 38 00	 cmp	 DWORD PTR InputFile$[rsp], 0
  00567	7c 09		 jl	 SHORT $LN20@main

; 145  :     {
; 146  :         psf_sndClose(InputFile);

  00569	8b 4c 24 38	 mov	 ecx, DWORD PTR InputFile$[rsp]
  0056d	e8 00 00 00 00	 call	 psf_sndClose
$LN20@main:

; 147  :     }
; 148  : 
; 149  :     if(OutputFile >= 0)

  00572	83 7c 24 3c 00	 cmp	 DWORD PTR OutputFile$[rsp], 0
  00577	7c 09		 jl	 SHORT $LN21@main

; 150  :     {
; 151  :         psf_sndClose(OutputFile);

  00579	8b 4c 24 3c	 mov	 ecx, DWORD PTR OutputFile$[rsp]
  0057d	e8 00 00 00 00	 call	 psf_sndClose
$LN21@main:

; 152  :     }
; 153  :     
; 154  : 
; 155  :     if(Buffer)

  00582	48 83 7c 24 60
	00		 cmp	 QWORD PTR Buffer$[rsp], 0
  00588	74 0a		 je	 SHORT $LN22@main

; 156  :     {
; 157  :         free(Buffer);

  0058a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR Buffer$[rsp]
  0058f	e8 00 00 00 00	 call	 free
$LN22@main:

; 158  :     }
; 159  : 
; 160  :     if(OutputFile_Peaks)

  00594	48 83 7c 24 48
	00		 cmp	 QWORD PTR OutputFile_Peaks$[rsp], 0
  0059a	74 0a		 je	 SHORT $LN23@main

; 161  :     {
; 162  :         free(OutputFile_Peaks);

  0059c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR OutputFile_Peaks$[rsp]
  005a1	e8 00 00 00 00	 call	 free
$LN23@main:

; 163  :     }
; 164  : 
; 165  :     psf_finish();

  005a6	e8 00 00 00 00	 call	 psf_finish

; 166  : 
; 167  :     return ErrorCode;

  005ab	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
$LN1@main:

; 168  : }

  005af	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005b7	48 33 cc	 xor	 rcx, rsp
  005ba	e8 00 00 00 00	 call	 __security_check_cookie
  005bf	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  005c6	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 952  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 953  :         int _Result;
; 954  :         va_list _ArgList;
; 955  :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 48	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 956  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00022	b9 01 00 00 00	 mov	 ecx, 1
  00027	e8 00 00 00 00	 call	 __acrt_iob_func
  0002c	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00031	45 33 c0	 xor	 r8d, r8d
  00034	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Format$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 _vfprintf_l
  00041	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 957  :         __crt_va_end(_ArgList);

  00045	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 958  :         return _Result;

  0004e	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 959  :     }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Stream$ = 64
_Format$ = 72
fprintf	PROC						; COMDAT

; 833  :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 834  :         int _Result;
; 835  :         va_list _ArgList;
; 836  :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 837  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Stream$[rsp]
  00034	e8 00 00 00 00	 call	 _vfprintf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 838  :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 839  :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 840  :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 640  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 641  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	e8 00 00 00 00	 call	 __stdio_common_vfprintf

; 642  :     }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 86   :         static unsigned __int64 _OptionsStorage;
; 87   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 88   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
