; Listing generated by Microsoft (R) Optimizing Compiler Version 19.11.25507.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG7772	DB	'IEEE80:DoubleToUlong: val < 0', 0aH, 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	fprintf
PUBLIC	ieee_80_to_double
PUBLIC	double_to_ieee_80
PUBLIC	__real@0000000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@4040000000000000
PUBLIC	__real@40cfff8000000000
PUBLIC	__real@40d0078000000000
PUBLIC	__real@41e0000000000000
PUBLIC	__real@c03f000000000000
PUBLIC	__real@c04f800000000000
PUBLIC	__xmm@80000000000000008000000000000000
EXTRN	__acrt_iob_func:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	log:PROC
EXTRN	pow:PROC
EXTRN	_fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$fprintf
pdata	ENDS
pdata	SEGMENT
$pdata$ieee_80_to_double DD imagerel $LN9
	DD	imagerel $LN9+750
	DD	imagerel $unwind$ieee_80_to_double
$pdata$double_to_ieee_80 DD imagerel $LN6
	DD	imagerel $LN6+640
	DD	imagerel $unwind$double_to_ieee_80
$pdata$myUlongToDouble DD imagerel myUlongToDouble
	DD	imagerel myUlongToDouble+82
	DD	imagerel $unwind$myUlongToDouble
$pdata$myDoubleToUlong DD imagerel myDoubleToUlong
	DD	imagerel myDoubleToUlong+111
	DD	imagerel $unwind$myDoubleToUlong
pdata	ENDS
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c04f800000000000
CONST	SEGMENT
__real@c04f800000000000 DQ 0c04f800000000000r	; -63
CONST	ENDS
;	COMDAT __real@c03f000000000000
CONST	SEGMENT
__real@c03f000000000000 DQ 0c03f000000000000r	; -31
CONST	ENDS
;	COMDAT __real@41e0000000000000
CONST	SEGMENT
__real@41e0000000000000 DQ 041e0000000000000r	; 2.14748e+09
CONST	ENDS
;	COMDAT __real@40d0078000000000
CONST	SEGMENT
__real@40d0078000000000 DQ 040d0078000000000r	; 16414
CONST	ENDS
;	COMDAT __real@40cfff8000000000
CONST	SEGMENT
__real@40cfff8000000000 DQ 040cfff8000000000r	; 16383
CONST	ENDS
;	COMDAT __real@4040000000000000
CONST	SEGMENT
__real@4040000000000000 DQ 04040000000000000r	; 32
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
xdata	SEGMENT
$unwind$ieee_80_to_double DD 010901H
	DD	0c209H
$unwind$double_to_ieee_80 DD 010f01H
	DD	0820fH
$unwind$myUlongToDouble DD 010801H
	DD	02208H
$unwind$myDoubleToUlong DD 010a01H
	DD	0620aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\ieee80.c
_TEXT	SEGMENT
ul$ = 32
val$ = 64
myDoubleToUlong PROC

; 70   : {

  00000	f2 0f 11 44 24
	08		 movsd	 QWORD PTR [rsp+8], xmm0
  00006	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 71   : 	unsigned long ul;
; 72   : 	
; 73   : 	/* cannot cast negative numbers into unsigned longs */
; 74   : 	if(val < 0)	

  0000a	0f 57 c0	 xorps	 xmm0, xmm0
  0000d	66 0f 2f 44 24
	40		 comisd	 xmm0, QWORD PTR val$[rsp]
  00013	76 19		 jbe	 SHORT $LN2@myDoubleTo

; 75   : 	{ 
; 76   : 		fprintf(stderr,"IEEE80:DoubleToUlong: val < 0\n"); 

  00015	b9 02 00 00 00	 mov	 ecx, 2
  0001a	e8 00 00 00 00	 call	 __acrt_iob_func
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7772
  00026	48 8b c8	 mov	 rcx, rax
  00029	e8 00 00 00 00	 call	 fprintf
$LN2@myDoubleTo:

; 77   : 	}
; 78   : 	
; 79   : 	/* in ultrix 4.1's cc, double -> unsigned long loses the top bit, 
; 80   : 	   so we do the conversion only on the bottom 31 bits and set the 
; 81   : 	   last one by hand, if val is truly that big */
; 82   : 	/* should maybe test for val > (double)(unsigned long)0xFFFFFFFF ? */
; 83   : 	if(val < DPOW2TO31)

  0002e	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@41e0000000000000
  00036	66 0f 2f 44 24
	40		 comisd	 xmm0, QWORD PTR val$[rsp]
  0003c	76 0d		 jbe	 SHORT $LN3@myDoubleTo

; 84   : 		ul = (unsigned long)val;

  0003e	f2 48 0f 2c 44
	24 40		 cvttsd2si rax, QWORD PTR val$[rsp]
  00045	89 44 24 20	 mov	 DWORD PTR ul$[rsp], eax
  00049	eb 1b		 jmp	 SHORT $LN4@myDoubleTo
$LN3@myDoubleTo:

; 85   : 	else
; 86   : 		ul = ULPOW2TO31 | (unsigned long)(val-DPOW2TO31);

  0004b	f2 0f 10 44 24
	40		 movsd	 xmm0, QWORD PTR val$[rsp]
  00051	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@41e0000000000000
  00059	f2 48 0f 2c c0	 cvttsd2si rax, xmm0
  0005e	0f ba e8 1f	 bts	 eax, 31
  00062	89 44 24 20	 mov	 DWORD PTR ul$[rsp], eax
$LN4@myDoubleTo:

; 87   : 	return ul;

  00066	8b 44 24 20	 mov	 eax, DWORD PTR ul$[rsp]

; 88   : }

  0006a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006e	c3		 ret	 0
myDoubleToUlong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\ieee80.c
_TEXT	SEGMENT
val$ = 0
ul$ = 32
myUlongToDouble PROC

; 56   : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 57   : 	double val;
; 58   : 	
; 59   : 	/* in THINK_C, ulong -> double apparently goes via long, so can only 
; 60   : 	   apply to 31 bit numbers.  If 32nd bit is set, explicitly add on its
; 61   : 	   value */
; 62   : 	if(ul & ULPOW2TO31)

  00008	8b 44 24 20	 mov	 eax, DWORD PTR ul$[rsp]
  0000c	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00011	85 c0		 test	 eax, eax
  00013	74 25		 je	 SHORT $LN2@myUlongToD

; 63   : 		val = DPOW2TO31 + (ul & (~ULPOW2TO31));

  00015	8b 44 24 20	 mov	 eax, DWORD PTR ul$[rsp]
  00019	0f ba f0 1f	 btr	 eax, 31
  0001d	8b c0		 mov	 eax, eax
  0001f	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  00024	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@41e0000000000000
  0002c	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00030	0f 28 c1	 movaps	 xmm0, xmm1
  00033	f2 0f 11 04 24	 movsd	 QWORD PTR val$[rsp], xmm0
  00038	eb 0e		 jmp	 SHORT $LN3@myUlongToD
$LN2@myUlongToD:

; 64   : 	else
; 65   : 		val = ul;

  0003a	8b 44 24 20	 mov	 eax, DWORD PTR ul$[rsp]
  0003e	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  00043	f2 0f 11 04 24	 movsd	 QWORD PTR val$[rsp], xmm0
$LN3@myUlongToD:

; 66   : 	return val;

  00048	f2 0f 10 04 24	 movsd	 xmm0, QWORD PTR val$[rsp]

; 67   : }

  0004d	48 83 c4 18	 add	 rsp, 24
  00051	c3		 ret	 0
myUlongToDouble ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\ieee80.c
_TEXT	SEGMENT
sign$ = 32
exp$ = 36
mant1$ = 40
mant0$ = 44
tv67 = 48
val$ = 80
p$ = 88
double_to_ieee_80 PROC

; 144  : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	f2 0f 11 44 24
	08		 movsd	 QWORD PTR [rsp+8], xmm0
  0000b	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 145  : 	char sign = 0;

  0000f	c6 44 24 20 00	 mov	 BYTE PTR sign$[rsp], 0

; 146  : 	short exp = 0;

  00014	33 c0		 xor	 eax, eax
  00016	66 89 44 24 24	 mov	 WORD PTR exp$[rsp], ax

; 147  : 	unsigned long mant1 = 0;

  0001b	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR mant1$[rsp], 0

; 148  : 	unsigned long mant0 = 0;

  00023	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR mant0$[rsp], 0

; 149  : 	
; 150  : 	if(val < 0.0)	{  sign = 1;  val = -val; }

  0002b	0f 57 c0	 xorps	 xmm0, xmm0
  0002e	66 0f 2f 44 24
	50		 comisd	 xmm0, QWORD PTR val$[rsp]
  00034	76 18		 jbe	 SHORT $LN2@double_to_
  00036	c6 44 24 20 01	 mov	 BYTE PTR sign$[rsp], 1
  0003b	f2 0f 10 44 24
	50		 movsd	 xmm0, QWORD PTR val$[rsp]
  00041	0f 57 05 00 00
	00 00		 xorps	 xmm0, QWORD PTR __xmm@80000000000000008000000000000000
  00048	f2 0f 11 44 24
	50		 movsd	 QWORD PTR val$[rsp], xmm0
$LN2@double_to_:

; 151  : 	
; 152  : 	if(val != 0.0)	/* val identically zero -> all elements zero */

  0004e	f2 0f 10 44 24
	50		 movsd	 xmm0, QWORD PTR val$[rsp]
  00054	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  0005c	7a 06		 jp	 SHORT $LN5@double_to_
  0005e	0f 84 d9 00 00
	00		 je	 $LN3@double_to_
$LN5@double_to_:

; 153  : 	{
; 154  : 		exp = (short)(log(val)/log(2.0) + 16383.0);

  00064	f2 0f 10 44 24
	50		 movsd	 xmm0, QWORD PTR val$[rsp]
  0006a	e8 00 00 00 00	 call	 log
  0006f	f2 0f 11 44 24
	30		 movsd	 QWORD PTR tv67[rsp], xmm0
  00075	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4000000000000000
  0007d	e8 00 00 00 00	 call	 log
  00082	f2 0f 10 4c 24
	30		 movsd	 xmm1, QWORD PTR tv67[rsp]
  00088	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0008c	0f 28 c1	 movaps	 xmm0, xmm1
  0008f	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@40cfff8000000000
  00097	f2 0f 2c c0	 cvttsd2si eax, xmm0
  0009b	66 89 44 24 24	 mov	 WORD PTR exp$[rsp], ax

; 155  : 		val *= pow(2.0, 31.0+16383.0-(double)exp);

  000a0	0f bf 44 24 24	 movsx	 eax, WORD PTR exp$[rsp]
  000a5	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  000a9	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@40d0078000000000
  000b1	f2 0f 5c c8	 subsd	 xmm1, xmm0
  000b5	0f 28 c1	 movaps	 xmm0, xmm1
  000b8	0f 28 c8	 movaps	 xmm1, xmm0
  000bb	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4000000000000000
  000c3	e8 00 00 00 00	 call	 pow
  000c8	f2 0f 10 4c 24
	50		 movsd	 xmm1, QWORD PTR val$[rsp]
  000ce	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  000d2	0f 28 c1	 movaps	 xmm0, xmm1
  000d5	f2 0f 11 44 24
	50		 movsd	 QWORD PTR val$[rsp], xmm0

; 156  : 		mant1 = myDoubleToUlong(val);

  000db	f2 0f 10 44 24
	50		 movsd	 xmm0, QWORD PTR val$[rsp]
  000e1	e8 00 00 00 00	 call	 myDoubleToUlong
  000e6	89 44 24 28	 mov	 DWORD PTR mant1$[rsp], eax

; 157  : 		val -= myUlongToDouble(mant1);

  000ea	8b 4c 24 28	 mov	 ecx, DWORD PTR mant1$[rsp]
  000ee	e8 00 00 00 00	 call	 myUlongToDouble
  000f3	f2 0f 10 4c 24
	50		 movsd	 xmm1, QWORD PTR val$[rsp]
  000f9	f2 0f 5c c8	 subsd	 xmm1, xmm0
  000fd	0f 28 c1	 movaps	 xmm0, xmm1
  00100	f2 0f 11 44 24
	50		 movsd	 QWORD PTR val$[rsp], xmm0

; 158  : 		val *= pow(2.0, 32.0);

  00106	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4040000000000000
  0010e	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4000000000000000
  00116	e8 00 00 00 00	 call	 pow
  0011b	f2 0f 10 4c 24
	50		 movsd	 xmm1, QWORD PTR val$[rsp]
  00121	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00125	0f 28 c1	 movaps	 xmm0, xmm1
  00128	f2 0f 11 44 24
	50		 movsd	 QWORD PTR val$[rsp], xmm0

; 159  : 		mant0 = myDoubleToUlong(val);

  0012e	f2 0f 10 44 24
	50		 movsd	 xmm0, QWORD PTR val$[rsp]
  00134	e8 00 00 00 00	 call	 myDoubleToUlong
  00139	89 44 24 2c	 mov	 DWORD PTR mant0$[rsp], eax
$LN3@double_to_:

; 160  : 	}
; 161  : 	
; 162  : 	*p++ = ((sign<<7)|(exp>>8));

  0013d	0f be 44 24 20	 movsx	 eax, BYTE PTR sign$[rsp]
  00142	c1 e0 07	 shl	 eax, 7
  00145	0f bf 4c 24 24	 movsx	 ecx, WORD PTR exp$[rsp]
  0014a	c1 f9 08	 sar	 ecx, 8
  0014d	0b c1		 or	 eax, ecx
  0014f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p$[rsp]
  00154	88 01		 mov	 BYTE PTR [rcx], al
  00156	48 8b 44 24 58	 mov	 rax, QWORD PTR p$[rsp]
  0015b	48 ff c0	 inc	 rax
  0015e	48 89 44 24 58	 mov	 QWORD PTR p$[rsp], rax

; 163  : 	*p++ = 0xFF & exp;

  00163	0f bf 44 24 24	 movsx	 eax, WORD PTR exp$[rsp]
  00168	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0016d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p$[rsp]
  00172	88 01		 mov	 BYTE PTR [rcx], al
  00174	48 8b 44 24 58	 mov	 rax, QWORD PTR p$[rsp]
  00179	48 ff c0	 inc	 rax
  0017c	48 89 44 24 58	 mov	 QWORD PTR p$[rsp], rax

; 164  : 	*p++ = (char)(0xFF & (mant1>>24));

  00181	8b 44 24 28	 mov	 eax, DWORD PTR mant1$[rsp]
  00185	c1 e8 18	 shr	 eax, 24
  00188	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0018d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p$[rsp]
  00192	88 01		 mov	 BYTE PTR [rcx], al
  00194	48 8b 44 24 58	 mov	 rax, QWORD PTR p$[rsp]
  00199	48 ff c0	 inc	 rax
  0019c	48 89 44 24 58	 mov	 QWORD PTR p$[rsp], rax

; 165  : 	*p++ = (char)(0xFF & (mant1>>16));

  001a1	8b 44 24 28	 mov	 eax, DWORD PTR mant1$[rsp]
  001a5	c1 e8 10	 shr	 eax, 16
  001a8	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001ad	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p$[rsp]
  001b2	88 01		 mov	 BYTE PTR [rcx], al
  001b4	48 8b 44 24 58	 mov	 rax, QWORD PTR p$[rsp]
  001b9	48 ff c0	 inc	 rax
  001bc	48 89 44 24 58	 mov	 QWORD PTR p$[rsp], rax

; 166  : 	*p++ = (char)(0xFF & (mant1>> 8));

  001c1	8b 44 24 28	 mov	 eax, DWORD PTR mant1$[rsp]
  001c5	c1 e8 08	 shr	 eax, 8
  001c8	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001cd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p$[rsp]
  001d2	88 01		 mov	 BYTE PTR [rcx], al
  001d4	48 8b 44 24 58	 mov	 rax, QWORD PTR p$[rsp]
  001d9	48 ff c0	 inc	 rax
  001dc	48 89 44 24 58	 mov	 QWORD PTR p$[rsp], rax

; 167  : 	*p++ = (char)(0xFF & (mant1));

  001e1	8b 44 24 28	 mov	 eax, DWORD PTR mant1$[rsp]
  001e5	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001ea	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p$[rsp]
  001ef	88 01		 mov	 BYTE PTR [rcx], al
  001f1	48 8b 44 24 58	 mov	 rax, QWORD PTR p$[rsp]
  001f6	48 ff c0	 inc	 rax
  001f9	48 89 44 24 58	 mov	 QWORD PTR p$[rsp], rax

; 168  : 	*p++ = (char)(0xFF & (mant0>>24));

  001fe	8b 44 24 2c	 mov	 eax, DWORD PTR mant0$[rsp]
  00202	c1 e8 18	 shr	 eax, 24
  00205	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0020a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p$[rsp]
  0020f	88 01		 mov	 BYTE PTR [rcx], al
  00211	48 8b 44 24 58	 mov	 rax, QWORD PTR p$[rsp]
  00216	48 ff c0	 inc	 rax
  00219	48 89 44 24 58	 mov	 QWORD PTR p$[rsp], rax

; 169  : 	*p++ = (char)(0xFF & (mant0>>16));

  0021e	8b 44 24 2c	 mov	 eax, DWORD PTR mant0$[rsp]
  00222	c1 e8 10	 shr	 eax, 16
  00225	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0022a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p$[rsp]
  0022f	88 01		 mov	 BYTE PTR [rcx], al
  00231	48 8b 44 24 58	 mov	 rax, QWORD PTR p$[rsp]
  00236	48 ff c0	 inc	 rax
  00239	48 89 44 24 58	 mov	 QWORD PTR p$[rsp], rax

; 170  : 	*p++ = (char)(0xFF & (mant0>> 8));

  0023e	8b 44 24 2c	 mov	 eax, DWORD PTR mant0$[rsp]
  00242	c1 e8 08	 shr	 eax, 8
  00245	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0024a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p$[rsp]
  0024f	88 01		 mov	 BYTE PTR [rcx], al
  00251	48 8b 44 24 58	 mov	 rax, QWORD PTR p$[rsp]
  00256	48 ff c0	 inc	 rax
  00259	48 89 44 24 58	 mov	 QWORD PTR p$[rsp], rax

; 171  : 	*p++ = (char)(0xFF & (mant0));

  0025e	8b 44 24 2c	 mov	 eax, DWORD PTR mant0$[rsp]
  00262	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00267	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p$[rsp]
  0026c	88 01		 mov	 BYTE PTR [rcx], al
  0026e	48 8b 44 24 58	 mov	 rax, QWORD PTR p$[rsp]
  00273	48 ff c0	 inc	 rax
  00276	48 89 44 24 58	 mov	 QWORD PTR p$[rsp], rax

; 172  : 	
; 173  : }

  0027b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0027f	c3		 ret	 0
double_to_ieee_80 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\ieee80.c
_TEXT	SEGMENT
exp$ = 32
mant0$ = 36
mant1$ = 40
sign$ = 44
val$ = 48
tv75 = 56
tv170 = 64
tv146 = 72
tv152 = 80
p$ = 112
ieee_80_to_double PROC

; 96   : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 97   : 	char sign;
; 98   : 	short exp = 0;

  00009	33 c0		 xor	 eax, eax
  0000b	66 89 44 24 20	 mov	 WORD PTR exp$[rsp], ax

; 99   : 	unsigned long mant1 = 0;

  00010	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR mant1$[rsp], 0

; 100  : 	unsigned long mant0 = 0;

  00018	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR mant0$[rsp], 0

; 101  : 	double val;
; 102  : 	
; 103  : 	exp = *p++;

  00020	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  00025	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00028	66 89 44 24 20	 mov	 WORD PTR exp$[rsp], ax
  0002d	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  00032	48 ff c0	 inc	 rax
  00035	48 89 44 24 70	 mov	 QWORD PTR p$[rsp], rax

; 104  : 	exp <<= 8;

  0003a	0f b7 44 24 20	 movzx	 eax, WORD PTR exp$[rsp]
  0003f	66 c1 e0 08	 shl	 ax, 8
  00043	66 89 44 24 20	 mov	 WORD PTR exp$[rsp], ax

; 105  : 	exp |= *p++;

  00048	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  0004d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00050	0f bf 4c 24 20	 movsx	 ecx, WORD PTR exp$[rsp]
  00055	0b c8		 or	 ecx, eax
  00057	8b c1		 mov	 eax, ecx
  00059	66 89 44 24 20	 mov	 WORD PTR exp$[rsp], ax
  0005e	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  00063	48 ff c0	 inc	 rax
  00066	48 89 44 24 70	 mov	 QWORD PTR p$[rsp], rax

; 106  : 	sign = (exp & 0x8000) ? 1 : 0;

  0006b	0f bf 44 24 20	 movsx	 eax, WORD PTR exp$[rsp]
  00070	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00075	85 c0		 test	 eax, eax
  00077	74 0a		 je	 SHORT $LN5@ieee_80_to
  00079	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00081	eb 08		 jmp	 SHORT $LN6@ieee_80_to
$LN5@ieee_80_to:
  00083	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN6@ieee_80_to:
  0008b	0f b6 44 24 38	 movzx	 eax, BYTE PTR tv75[rsp]
  00090	88 44 24 2c	 mov	 BYTE PTR sign$[rsp], al

; 107  : 	exp &= 0x7FFF;

  00094	0f bf 44 24 20	 movsx	 eax, WORD PTR exp$[rsp]
  00099	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH
  0009e	66 89 44 24 20	 mov	 WORD PTR exp$[rsp], ax

; 108  : 	
; 109  : 	mant1 = *p++;

  000a3	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  000a8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ab	89 44 24 28	 mov	 DWORD PTR mant1$[rsp], eax
  000af	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  000b4	48 ff c0	 inc	 rax
  000b7	48 89 44 24 70	 mov	 QWORD PTR p$[rsp], rax

; 110  : 	mant1 <<= 8;

  000bc	8b 44 24 28	 mov	 eax, DWORD PTR mant1$[rsp]
  000c0	c1 e0 08	 shl	 eax, 8
  000c3	89 44 24 28	 mov	 DWORD PTR mant1$[rsp], eax

; 111  : 	mant1 |= *p++;

  000c7	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  000cc	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000cf	8b 4c 24 28	 mov	 ecx, DWORD PTR mant1$[rsp]
  000d3	0b c8		 or	 ecx, eax
  000d5	8b c1		 mov	 eax, ecx
  000d7	89 44 24 28	 mov	 DWORD PTR mant1$[rsp], eax
  000db	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  000e0	48 ff c0	 inc	 rax
  000e3	48 89 44 24 70	 mov	 QWORD PTR p$[rsp], rax

; 112  : 	mant1 <<= 8;

  000e8	8b 44 24 28	 mov	 eax, DWORD PTR mant1$[rsp]
  000ec	c1 e0 08	 shl	 eax, 8
  000ef	89 44 24 28	 mov	 DWORD PTR mant1$[rsp], eax

; 113  : 	mant1 |= *p++;

  000f3	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  000f8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000fb	8b 4c 24 28	 mov	 ecx, DWORD PTR mant1$[rsp]
  000ff	0b c8		 or	 ecx, eax
  00101	8b c1		 mov	 eax, ecx
  00103	89 44 24 28	 mov	 DWORD PTR mant1$[rsp], eax
  00107	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  0010c	48 ff c0	 inc	 rax
  0010f	48 89 44 24 70	 mov	 QWORD PTR p$[rsp], rax

; 114  : 	mant1 <<= 8;

  00114	8b 44 24 28	 mov	 eax, DWORD PTR mant1$[rsp]
  00118	c1 e0 08	 shl	 eax, 8
  0011b	89 44 24 28	 mov	 DWORD PTR mant1$[rsp], eax

; 115  : 	mant1 |= *p++;

  0011f	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  00124	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00127	8b 4c 24 28	 mov	 ecx, DWORD PTR mant1$[rsp]
  0012b	0b c8		 or	 ecx, eax
  0012d	8b c1		 mov	 eax, ecx
  0012f	89 44 24 28	 mov	 DWORD PTR mant1$[rsp], eax
  00133	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  00138	48 ff c0	 inc	 rax
  0013b	48 89 44 24 70	 mov	 QWORD PTR p$[rsp], rax

; 116  : 	
; 117  : 	mant0 = *p++;

  00140	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  00145	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00148	89 44 24 24	 mov	 DWORD PTR mant0$[rsp], eax
  0014c	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  00151	48 ff c0	 inc	 rax
  00154	48 89 44 24 70	 mov	 QWORD PTR p$[rsp], rax

; 118  : 	mant0 <<= 8;

  00159	8b 44 24 24	 mov	 eax, DWORD PTR mant0$[rsp]
  0015d	c1 e0 08	 shl	 eax, 8
  00160	89 44 24 24	 mov	 DWORD PTR mant0$[rsp], eax

; 119  : 	mant0 |= *p++;

  00164	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  00169	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0016c	8b 4c 24 24	 mov	 ecx, DWORD PTR mant0$[rsp]
  00170	0b c8		 or	 ecx, eax
  00172	8b c1		 mov	 eax, ecx
  00174	89 44 24 24	 mov	 DWORD PTR mant0$[rsp], eax
  00178	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  0017d	48 ff c0	 inc	 rax
  00180	48 89 44 24 70	 mov	 QWORD PTR p$[rsp], rax

; 120  : 	mant0 <<= 8;

  00185	8b 44 24 24	 mov	 eax, DWORD PTR mant0$[rsp]
  00189	c1 e0 08	 shl	 eax, 8
  0018c	89 44 24 24	 mov	 DWORD PTR mant0$[rsp], eax

; 121  : 	mant0 |= *p++;

  00190	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  00195	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00198	8b 4c 24 24	 mov	 ecx, DWORD PTR mant0$[rsp]
  0019c	0b c8		 or	 ecx, eax
  0019e	8b c1		 mov	 eax, ecx
  001a0	89 44 24 24	 mov	 DWORD PTR mant0$[rsp], eax
  001a4	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  001a9	48 ff c0	 inc	 rax
  001ac	48 89 44 24 70	 mov	 QWORD PTR p$[rsp], rax

; 122  : 	mant0 <<= 8;

  001b1	8b 44 24 24	 mov	 eax, DWORD PTR mant0$[rsp]
  001b5	c1 e0 08	 shl	 eax, 8
  001b8	89 44 24 24	 mov	 DWORD PTR mant0$[rsp], eax

; 123  : 	mant0 |= *p++;

  001bc	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  001c1	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001c4	8b 4c 24 24	 mov	 ecx, DWORD PTR mant0$[rsp]
  001c8	0b c8		 or	 ecx, eax
  001ca	8b c1		 mov	 eax, ecx
  001cc	89 44 24 24	 mov	 DWORD PTR mant0$[rsp], eax
  001d0	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  001d5	48 ff c0	 inc	 rax
  001d8	48 89 44 24 70	 mov	 QWORD PTR p$[rsp], rax

; 124  : 	
; 125  : 	/* special test for all bits zero meaning zero 
; 126  : 	   - else pow(2,-16383) bombs */
; 127  : 	if(mant1 == 0 && mant0 == 0 && exp == 0 && sign == 0)

  001dd	83 7c 24 28 00	 cmp	 DWORD PTR mant1$[rsp], 0
  001e2	75 26		 jne	 SHORT $LN2@ieee_80_to
  001e4	83 7c 24 24 00	 cmp	 DWORD PTR mant0$[rsp], 0
  001e9	75 1f		 jne	 SHORT $LN2@ieee_80_to
  001eb	0f bf 44 24 20	 movsx	 eax, WORD PTR exp$[rsp]
  001f0	85 c0		 test	 eax, eax
  001f2	75 16		 jne	 SHORT $LN2@ieee_80_to
  001f4	0f be 44 24 2c	 movsx	 eax, BYTE PTR sign$[rsp]
  001f9	85 c0		 test	 eax, eax
  001fb	75 0d		 jne	 SHORT $LN2@ieee_80_to

; 128  : 		return 0.0;

  001fd	0f 57 c0	 xorps	 xmm0, xmm0
  00200	e9 e4 00 00 00	 jmp	 $LN1@ieee_80_to
  00205	e9 df 00 00 00	 jmp	 $LN3@ieee_80_to
$LN2@ieee_80_to:

; 129  : 	else{
; 130  : 		val = myUlongToDouble(mant0) * pow(2.0,-63.0);

  0020a	8b 4c 24 24	 mov	 ecx, DWORD PTR mant0$[rsp]
  0020e	e8 00 00 00 00	 call	 myUlongToDouble
  00213	f2 0f 11 44 24
	48		 movsd	 QWORD PTR tv146[rsp], xmm0
  00219	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@c04f800000000000
  00221	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4000000000000000
  00229	e8 00 00 00 00	 call	 pow
  0022e	f2 0f 10 4c 24
	48		 movsd	 xmm1, QWORD PTR tv146[rsp]
  00234	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00238	0f 28 c1	 movaps	 xmm0, xmm1
  0023b	f2 0f 11 44 24
	30		 movsd	 QWORD PTR val$[rsp], xmm0

; 131  : 		val += myUlongToDouble(mant1) * pow(2.0,-31.0);

  00241	8b 4c 24 28	 mov	 ecx, DWORD PTR mant1$[rsp]
  00245	e8 00 00 00 00	 call	 myUlongToDouble
  0024a	f2 0f 11 44 24
	50		 movsd	 QWORD PTR tv152[rsp], xmm0
  00250	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@c03f000000000000
  00258	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4000000000000000
  00260	e8 00 00 00 00	 call	 pow
  00265	f2 0f 10 4c 24
	50		 movsd	 xmm1, QWORD PTR tv152[rsp]
  0026b	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  0026f	0f 28 c1	 movaps	 xmm0, xmm1
  00272	f2 0f 10 4c 24
	30		 movsd	 xmm1, QWORD PTR val$[rsp]
  00278	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0027c	0f 28 c1	 movaps	 xmm0, xmm1
  0027f	f2 0f 11 44 24
	30		 movsd	 QWORD PTR val$[rsp], xmm0

; 132  : 		val *= pow(2.0,((double) exp) - 16383.0);

  00285	0f bf 44 24 20	 movsx	 eax, WORD PTR exp$[rsp]
  0028a	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  0028e	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@40cfff8000000000
  00296	0f 28 c8	 movaps	 xmm1, xmm0
  00299	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4000000000000000
  002a1	e8 00 00 00 00	 call	 pow
  002a6	f2 0f 10 4c 24
	30		 movsd	 xmm1, QWORD PTR val$[rsp]
  002ac	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  002b0	0f 28 c1	 movaps	 xmm0, xmm1
  002b3	f2 0f 11 44 24
	30		 movsd	 QWORD PTR val$[rsp], xmm0

; 133  : 		return sign ? -val : val;

  002b9	0f be 44 24 2c	 movsx	 eax, BYTE PTR sign$[rsp]
  002be	85 c0		 test	 eax, eax
  002c0	74 15		 je	 SHORT $LN7@ieee_80_to
  002c2	f2 0f 10 44 24
	30		 movsd	 xmm0, QWORD PTR val$[rsp]
  002c8	0f 57 05 00 00
	00 00		 xorps	 xmm0, QWORD PTR __xmm@80000000000000008000000000000000
  002cf	f2 0f 11 44 24
	40		 movsd	 QWORD PTR tv170[rsp], xmm0
  002d5	eb 0c		 jmp	 SHORT $LN8@ieee_80_to
$LN7@ieee_80_to:
  002d7	f2 0f 10 44 24
	30		 movsd	 xmm0, QWORD PTR val$[rsp]
  002dd	f2 0f 11 44 24
	40		 movsd	 QWORD PTR tv170[rsp], xmm0
$LN8@ieee_80_to:
  002e3	f2 0f 10 44 24
	40		 movsd	 xmm0, QWORD PTR tv170[rsp]
$LN3@ieee_80_to:
$LN1@ieee_80_to:

; 134  : 	}
; 135  : }

  002e9	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002ed	c3		 ret	 0
ieee_80_to_double ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Stream$ = 64
_Format$ = 72
fprintf	PROC						; COMDAT

; 833  :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 834  :         int _Result;
; 835  :         va_list _ArgList;
; 836  :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 837  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Stream$[rsp]
  00034	e8 00 00 00 00	 call	 _vfprintf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 838  :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 839  :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 840  :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 640  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 641  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	e8 00 00 00 00	 call	 __stdio_common_vfprintf

; 642  :     }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 86   :         static unsigned __int64 _OptionsStorage;
; 87   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 88   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
