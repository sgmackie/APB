; Listing generated by Microsoft (R) Optimizing Compiler Version 19.11.25547.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG7165	DB	'envelope_extract.exe: Create an evelope breakpoint file '
	DB	'from an audio file', 0aH, 00H
$SG7185	DB	'w', 00H
	ORG $+2
$SG7168	DB	'Error: Missing flag name', 0aH, 00H
	ORG $+6
$SG7171	DB	'Error: Value for window duration argument must be positi'
	DB	've', 0aH, 00H
	ORG $+4
$SG7174	DB	'Error: Insufficient number of arguments', 0aH, 'Usage: e'
	DB	'nvelope_extract.exe, window size [-w], input file, output fil'
	DB	'e', 0aH, 00H
$SG7176	DB	'Error: Unable to start portsf', 0aH, 00H
	ORG $+1
$SG7178	DB	'Error: Unable to open input file %s', 0aH, 00H
	ORG $+3
$SG7180	DB	'Error: Input file (%d channels) must be mono', 0aH, 00H
	ORG $+2
$SG7183	DB	'Error: No memory', 0aH, 00H
	ORG $+6
$SG7187	DB	'Error: Unable to create breakpoint file', 0aH, 00H
	ORG $+3
$SG7191	DB	'%f', 09H, '%f', 0aH, 00H
	ORG $+5
$SG7189	DB	'Info: Processing...', 0aH, 00H
	ORG $+3
$SG7192	DB	'Error: Failed to write breakpoint file', 0aH, 00H
$SG7195	DB	'Info: Copying %ld samples...', 0dH, 00H
	ORG $+2
$SG7202	DB	'Warning: Problem closing input file %s', 0aH, 00H
$SG7198	DB	'Error: Cannot read input file %s, output file %s is inco'
	DB	'mplete', 0aH, 00H
$SG7199	DB	0aH, 'Info: Done.', 0aH, 'Info: %d breakpoints written to'
	DB	' %s', 0aH, 'Info: %d errors', 0aH, 00H
	ORG $+7
$SG7205	DB	'Error: Failed to close breakpoint file', 0aH, 00H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	fprintf
PUBLIC	??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
PUBLIC	printf
PUBLIC	?max_sample_value@@YANPEAMK@Z			; max_sample_value
PUBLIC	main
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	__real@402e000000000000
PUBLIC	__real@408f400000000000
EXTRN	__acrt_iob_func:PROC
EXTRN	fclose:PROC
EXTRN	fopen:PROC
EXTRN	puts:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	free:PROC
EXTRN	malloc:PROC
EXTRN	atof:PROC
EXTRN	fabs:PROC
EXTRN	psf_init:PROC
EXTRN	psf_finish:PROC
EXTRN	psf_sndOpen:PROC
EXTRN	psf_sndClose:PROC
EXTRN	psf_sndReadFloatFrames:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$fprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+92
	DD	imagerel $unwind$printf
pdata	ENDS
pdata	SEGMENT
$pdata$?max_sample_value@@YANPEAMK@Z DD imagerel $LN7
	DD	imagerel $LN7+116
	DD	imagerel $unwind$?max_sample_value@@YANPEAMK@Z
$pdata$main DD	imagerel $LN33
	DD	imagerel $LN33+1442
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@402e000000000000
CONST	SEGMENT
__real@402e000000000000 DQ 0402e000000000000r	; 15
CONST	ENDS
xdata	SEGMENT
$unwind$?max_sample_value@@YANPEAMK@Z DD 010d01H
	DD	0820dH
$unwind$main DD	022219H
	DD	0170110H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\chapter_2\2.4.3\code\envelope_extract.cpp
_TEXT	SEGMENT
ErrorCode$ = 32
CommandFlag$1 = 36
InputFile$ = 40
FramesRead_Total$ = 44
FramesRead$ = 48
NumPoints$ = 52
WindowDuration$ = 56
tv77 = 64
WindowSize$ = 68
BreakpointFile$ = 72
FramesInput$ = 80
BufferSize$ = 88
BreakTime$ = 96
tv152 = 104
Amplitude$2 = 112
tv220 = 120
tv223 = 128
PeakData$ = 136
InputFile_Properties$ = 144
__$ArrayPad$ = 168
argc$ = 192
argv$ = 200
main	PROC

; 16   : {

$LN33:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 17   :     //Stage 1: Declare
; 18   :     PSF_PROPS InputFile_Properties; //File properties struct from portsf
; 19   :     long FramesRead, FramesRead_Total;
; 20   :     unsigned long WindowSize, NumPoints;
; 21   :     double BreakTime;
; 22   : 
; 23   :     //Initialise dyanmic variables to defaults
; 24   :     int InputFile = -1;

  00022	c7 44 24 28 ff
	ff ff ff	 mov	 DWORD PTR InputFile$[rsp], -1

; 25   :     int ErrorCode = 0;

  0002a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ErrorCode$[rsp], 0

; 26   :     double WindowDuration = WINDOW_SIZE_MSECS_DEFAULT;

  00032	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@402e000000000000
  0003a	f2 0f 11 44 24
	38		 movsd	 QWORD PTR WindowDuration$[rsp], xmm0

; 27   :     FILE *BreakpointFile = NULL;

  00040	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR BreakpointFile$[rsp], 0

; 28   :     PSF_CHPEAK *PeakData = NULL; //Peak data struct from portsf

  00049	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR PeakData$[rsp], 0

; 29   :     unsigned long BufferSize = BUFFER_SIZE; //Unsigned, buffer size cannot be a negative number

  00055	c7 44 24 58 00
	04 00 00	 mov	 DWORD PTR BufferSize$[rsp], 1024 ; 00000400H

; 30   :     float *FramesInput;
; 31   : 
; 32   :     printf("envelope_extract.exe: Create an evelope breakpoint file from an audio file\n");

  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7165
  00064	e8 00 00 00 00	 call	 printf

; 33   : 
; 34   :     //Stage 2: Argument check
; 35   :     //Process optional flags
; 36   :     if(argc > 1)

  00069	83 bc 24 c0 00
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  00071	0f 8e 2a 01 00
	00		 jle	 $LN8@main
$LN2@main:

; 37   :     {
; 38   :         char CommandFlag;
; 39   : 
; 40   :         while(argv[1][0] == '-')

  00077	b8 08 00 00 00	 mov	 eax, 8
  0007c	48 6b c0 01	 imul	 rax, rax, 1
  00080	b9 01 00 00 00	 mov	 ecx, 1
  00085	48 6b c9 00	 imul	 rcx, rcx, 0
  00089	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00091	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00095	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00099	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0009c	0f 85 ff 00 00
	00		 jne	 $LN3@main

; 41   :         {
; 42   :             CommandFlag = argv[1][1];

  000a2	b8 08 00 00 00	 mov	 eax, 8
  000a7	48 6b c0 01	 imul	 rax, rax, 1
  000ab	b9 01 00 00 00	 mov	 ecx, 1
  000b0	48 6b c9 01	 imul	 rcx, rcx, 1
  000b4	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  000bc	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  000c0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c4	88 44 24 24	 mov	 BYTE PTR CommandFlag$1[rsp], al

; 43   : 
; 44   :             switch(CommandFlag)

  000c8	0f b6 44 24 24	 movzx	 eax, BYTE PTR CommandFlag$1[rsp]
  000cd	88 44 24 40	 mov	 BYTE PTR tv77[rsp], al
  000d1	80 7c 24 40 00	 cmp	 BYTE PTR tv77[rsp], 0
  000d6	74 0c		 je	 SHORT $LN9@main
  000d8	80 7c 24 40 77	 cmp	 BYTE PTR tv77[rsp], 119	; 00000077H
  000dd	74 32		 je	 SHORT $LN10@main
  000df	e9 94 00 00 00	 jmp	 $LN12@main
$LN9@main:

; 45   :             {
; 46   :                 case('\0'):
; 47   :                     fprintf(stderr, "Error: Missing flag name\n");

  000e4	b9 02 00 00 00	 mov	 ecx, 2
  000e9	e8 00 00 00 00	 call	 __acrt_iob_func
  000ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7168
  000f5	48 8b c8	 mov	 rcx, rax
  000f8	e8 00 00 00 00	 call	 fprintf

; 48   :                     ErrorCode++;

  000fd	8b 44 24 20	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  00101	ff c0		 inc	 eax
  00103	89 44 24 20	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 49   :                     return 1;

  00107	b8 01 00 00 00	 mov	 eax, 1
  0010c	e9 79 04 00 00	 jmp	 $LN1@main
$LN10@main:

; 50   :                 case('w'):
; 51   :                     WindowDuration = atof(&argv[1][2]);

  00111	b8 08 00 00 00	 mov	 eax, 8
  00116	48 6b c0 01	 imul	 rax, rax, 1
  0011a	b9 01 00 00 00	 mov	 ecx, 1
  0011f	48 6b c9 02	 imul	 rcx, rcx, 2
  00123	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0012b	48 03 0c 02	 add	 rcx, QWORD PTR [rdx+rax]
  0012f	48 8b c1	 mov	 rax, rcx
  00132	48 8b c8	 mov	 rcx, rax
  00135	e8 00 00 00 00	 call	 atof
  0013a	f2 0f 11 44 24
	38		 movsd	 QWORD PTR WindowDuration$[rsp], xmm0

; 52   :                     if(WindowDuration <= 0.0)

  00140	0f 57 c0	 xorps	 xmm0, xmm0
  00143	66 0f 2f 44 24
	38		 comisd	 xmm0, QWORD PTR WindowDuration$[rsp]
  00149	72 2d		 jb	 SHORT $LN11@main

; 53   :                     {
; 54   :                         fprintf(stderr, "Error: Value for window duration argument must be positive\n");

  0014b	b9 02 00 00 00	 mov	 ecx, 2
  00150	e8 00 00 00 00	 call	 __acrt_iob_func
  00155	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7171
  0015c	48 8b c8	 mov	 rcx, rax
  0015f	e8 00 00 00 00	 call	 fprintf

; 55   :                         ErrorCode++;

  00164	8b 44 24 20	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  00168	ff c0		 inc	 eax
  0016a	89 44 24 20	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 56   :                         return 1;

  0016e	b8 01 00 00 00	 mov	 eax, 1
  00173	e9 12 04 00 00	 jmp	 $LN1@main
$LN11@main:
$LN12@main:

; 57   :                     }
; 58   :                 default:
; 59   :                     break;
; 60   :             }
; 61   : 
; 62   :             argc--;

  00178	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  0017f	ff c8		 dec	 eax
  00181	89 84 24 c0 00
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 63   :             argv++;

  00188	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00190	48 83 c0 08	 add	 rax, 8
  00194	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 64   :         }

  0019c	e9 d6 fe ff ff	 jmp	 $LN2@main
$LN3@main:
$LN8@main:

; 65   :     }
; 66   : 
; 67   :     //Check command line arguments
; 68   :     if(argc < ARG_NUM_ARGS)

  001a1	83 bc 24 c0 00
	00 00 03	 cmp	 DWORD PTR argc$[rsp], 3
  001a9	7d 23		 jge	 SHORT $LN13@main

; 69   :     {
; 70   :         fprintf(stderr, "Error: Insufficient number of arguments\n"

  001ab	b9 02 00 00 00	 mov	 ecx, 2
  001b0	e8 00 00 00 00	 call	 __acrt_iob_func
  001b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7174
  001bc	48 8b c8	 mov	 rcx, rax
  001bf	e8 00 00 00 00	 call	 fprintf

; 71   :                         "Usage: envelope_extract.exe, window size [-w], input file, output file\n");
; 72   :         return 1;

  001c4	b8 01 00 00 00	 mov	 eax, 1
  001c9	e9 bc 03 00 00	 jmp	 $LN1@main
$LN13@main:

; 73   :     }
; 74   : 
; 75   :     //Start portsf library
; 76   :     if(psf_init())

  001ce	e8 00 00 00 00	 call	 psf_init
  001d3	85 c0		 test	 eax, eax
  001d5	74 23		 je	 SHORT $LN14@main

; 77   :     {
; 78   :         fprintf(stderr, "Error: Unable to start portsf\n");

  001d7	b9 02 00 00 00	 mov	 ecx, 2
  001dc	e8 00 00 00 00	 call	 __acrt_iob_func
  001e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7176
  001e8	48 8b c8	 mov	 rcx, rax
  001eb	e8 00 00 00 00	 call	 fprintf

; 79   :         return 1;

  001f0	b8 01 00 00 00	 mov	 eax, 1
  001f5	e9 90 03 00 00	 jmp	 $LN1@main
$LN14@main:

; 80   :     }
; 81   :     
; 82   :     //Stage 3: Process input file
; 83   :     //Open user input file
; 84   :     InputFile = psf_sndOpen(argv[ARG_INFILE], &InputFile_Properties, 0);

  001fa	b8 08 00 00 00	 mov	 eax, 8
  001ff	48 6b c0 01	 imul	 rax, rax, 1
  00203	45 33 c0	 xor	 r8d, r8d
  00206	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR InputFile_Properties$[rsp]
  0020e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00216	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0021a	e8 00 00 00 00	 call	 psf_sndOpen
  0021f	89 44 24 28	 mov	 DWORD PTR InputFile$[rsp], eax

; 85   : 
; 86   :     if(InputFile < 0)

  00223	83 7c 24 28 00	 cmp	 DWORD PTR InputFile$[rsp], 0
  00228	7d 42		 jge	 SHORT $LN15@main

; 87   :     {
; 88   :         fprintf(stderr, "Error: Unable to open input file %s\n", argv[ARG_INFILE]);

  0022a	b8 08 00 00 00	 mov	 eax, 8
  0022f	48 6b c0 01	 imul	 rax, rax, 1
  00233	48 89 44 24 68	 mov	 QWORD PTR tv152[rsp], rax
  00238	b9 02 00 00 00	 mov	 ecx, 2
  0023d	e8 00 00 00 00	 call	 __acrt_iob_func
  00242	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0024a	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv152[rsp]
  0024f	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  00253	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7178
  0025a	48 8b c8	 mov	 rcx, rax
  0025d	e8 00 00 00 00	 call	 fprintf

; 89   :         return 1;

  00262	b8 01 00 00 00	 mov	 eax, 1
  00267	e9 1e 03 00 00	 jmp	 $LN1@main
$LN15@main:

; 90   :     }
; 91   : 
; 92   :     //Check if input file is mono
; 93   :     if(InputFile_Properties.chans != 1)

  0026c	83 bc 24 94 00
	00 00 01	 cmp	 DWORD PTR InputFile_Properties$[rsp+4], 1
  00274	74 35		 je	 SHORT $LN16@main

; 94   :     {
; 95   :         fprintf(stderr, "Error: Input file (%d channels) must be mono\n", InputFile_Properties.chans);

  00276	b9 02 00 00 00	 mov	 ecx, 2
  0027b	e8 00 00 00 00	 call	 __acrt_iob_func
  00280	44 8b 84 24 94
	00 00 00	 mov	 r8d, DWORD PTR InputFile_Properties$[rsp+4]
  00288	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7180
  0028f	48 8b c8	 mov	 rcx, rax
  00292	e8 00 00 00 00	 call	 fprintf

; 96   :         ErrorCode++;

  00297	8b 44 24 20	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  0029b	ff c0		 inc	 eax
  0029d	89 44 24 20	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 97   :         goto memory_cleanup;

  002a1	e9 69 02 00 00	 jmp	 $LN17@main
  002a6	e9 64 02 00 00	 jmp	 $memory_cleanup$34
$LN16@main:

; 98   :     }
; 99   : 
; 100  :     //Allocate memory for input file samples    
; 101  :     WindowDuration /= 1000; //Convert to seconds

  002ab	f2 0f 10 44 24
	38		 movsd	 xmm0, QWORD PTR WindowDuration$[rsp]
  002b1	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@408f400000000000
  002b9	f2 0f 11 44 24
	38		 movsd	 QWORD PTR WindowDuration$[rsp], xmm0

; 102  :     WindowSize = (unsigned long) (WindowDuration * InputFile_Properties.srate);

  002bf	f2 0f 2a 84 24
	90 00 00 00	 cvtsi2sd xmm0, DWORD PTR InputFile_Properties$[rsp]
  002c8	f2 0f 10 4c 24
	38		 movsd	 xmm1, QWORD PTR WindowDuration$[rsp]
  002ce	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  002d2	0f 28 c1	 movaps	 xmm0, xmm1
  002d5	f2 48 0f 2c c0	 cvttsd2si rax, xmm0
  002da	89 44 24 44	 mov	 DWORD PTR WindowSize$[rsp], eax

; 103  : 
; 104  :     FramesInput = (float*) malloc(WindowSize * sizeof(float));

  002de	8b 44 24 44	 mov	 eax, DWORD PTR WindowSize$[rsp]
  002e2	48 c1 e0 02	 shl	 rax, 2
  002e6	48 8b c8	 mov	 rcx, rax
  002e9	e8 00 00 00 00	 call	 malloc
  002ee	48 89 44 24 50	 mov	 QWORD PTR FramesInput$[rsp], rax

; 105  : 
; 106  :     if(FramesInput == NULL)

  002f3	48 83 7c 24 50
	00		 cmp	 QWORD PTR FramesInput$[rsp], 0
  002f9	75 20		 jne	 SHORT $LN18@main

; 107  :     {
; 108  :         puts("Error: No memory\n"); //Puts uses less system memory than printf, applicable for severe memory errors

  002fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7183
  00302	e8 00 00 00 00	 call	 puts

; 109  :         ErrorCode++;

  00307	8b 44 24 20	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  0030b	ff c0		 inc	 eax
  0030d	89 44 24 20	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 110  :         goto memory_cleanup;

  00311	e9 f9 01 00 00	 jmp	 $LN19@main
  00316	e9 f4 01 00 00	 jmp	 $memory_cleanup$34
$LN18@main:

; 111  :     }
; 112  : 
; 113  :     //Stage 4: Process output file
; 114  :     BreakpointFile = fopen(argv[ARG_OUTFILE], "w");

  0031b	b8 08 00 00 00	 mov	 eax, 8
  00320	48 6b c0 02	 imul	 rax, rax, 2
  00324	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7185
  0032b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00333	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00337	e8 00 00 00 00	 call	 fopen
  0033c	48 89 44 24 48	 mov	 QWORD PTR BreakpointFile$[rsp], rax

; 115  : 
; 116  :     if(BreakpointFile == NULL)

  00341	48 83 7c 24 48
	00		 cmp	 QWORD PTR BreakpointFile$[rsp], 0
  00347	75 2d		 jne	 SHORT $LN20@main

; 117  :     {
; 118  :         fprintf(stderr, "Error: Unable to create breakpoint file\n");

  00349	b9 02 00 00 00	 mov	 ecx, 2
  0034e	e8 00 00 00 00	 call	 __acrt_iob_func
  00353	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7187
  0035a	48 8b c8	 mov	 rcx, rax
  0035d	e8 00 00 00 00	 call	 fprintf

; 119  :         ErrorCode++;

  00362	8b 44 24 20	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  00366	ff c0		 inc	 eax
  00368	89 44 24 20	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 120  :         goto memory_cleanup;

  0036c	e9 9e 01 00 00	 jmp	 $LN21@main
  00371	e9 99 01 00 00	 jmp	 $memory_cleanup$34
$LN20@main:

; 121  :     }
; 122  : 
; 123  :     //Stage 5: Processing loop
; 124  :     printf("Info: Processing...\n");

  00376	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7189
  0037d	e8 00 00 00 00	 call	 printf

; 125  : 
; 126  :     //Initialise counters
; 127  :     FramesRead_Total = 0;

  00382	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR FramesRead_Total$[rsp], 0

; 128  :     BreakTime = 0.0;

  0038a	0f 57 c0	 xorps	 xmm0, xmm0
  0038d	f2 0f 11 44 24
	60		 movsd	 QWORD PTR BreakTime$[rsp], xmm0

; 129  :     NumPoints = 0;

  00393	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR NumPoints$[rsp], 0
$LN6@main:

; 130  : 
; 131  :     //Main loop
; 132  :     while((FramesRead = psf_sndReadFloatFrames(InputFile, FramesInput, WindowSize)) > 0 )

  0039b	44 8b 44 24 44	 mov	 r8d, DWORD PTR WindowSize$[rsp]
  003a0	48 8b 54 24 50	 mov	 rdx, QWORD PTR FramesInput$[rsp]
  003a5	8b 4c 24 28	 mov	 ecx, DWORD PTR InputFile$[rsp]
  003a9	e8 00 00 00 00	 call	 psf_sndReadFloatFrames
  003ae	89 44 24 30	 mov	 DWORD PTR FramesRead$[rsp], eax
  003b2	83 7c 24 30 00	 cmp	 DWORD PTR FramesRead$[rsp], 0
  003b7	0f 8e b8 00 00
	00		 jle	 $LN7@main

; 133  :     {
; 134  :         //Buffer processing
; 135  :         double Amplitude;
; 136  :         Amplitude = max_sample_value(FramesInput, FramesRead);

  003bd	8b 54 24 30	 mov	 edx, DWORD PTR FramesRead$[rsp]
  003c1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR FramesInput$[rsp]
  003c6	e8 00 00 00 00	 call	 ?max_sample_value@@YANPEAMK@Z ; max_sample_value
  003cb	f2 0f 11 44 24
	70		 movsd	 QWORD PTR Amplitude$2[rsp], xmm0

; 137  :         
; 138  :         if(fprintf(BreakpointFile, "%f\t%f\n", BreakTime, Amplitude) < 2)

  003d1	f2 0f 10 5c 24
	70		 movsd	 xmm3, QWORD PTR Amplitude$2[rsp]
  003d7	66 49 0f 7e d9	 movq	 r9, xmm3
  003dc	f2 0f 10 54 24
	60		 movsd	 xmm2, QWORD PTR BreakTime$[rsp]
  003e2	66 49 0f 7e d0	 movq	 r8, xmm2
  003e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7191
  003ee	48 8b 4c 24 48	 mov	 rcx, QWORD PTR BreakpointFile$[rsp]
  003f3	e8 00 00 00 00	 call	 fprintf
  003f8	83 f8 02	 cmp	 eax, 2
  003fb	7d 2d		 jge	 SHORT $LN22@main

; 139  :         {
; 140  :             fprintf(stderr, "Error: Failed to write breakpoint file\n");

  003fd	b9 02 00 00 00	 mov	 ecx, 2
  00402	e8 00 00 00 00	 call	 __acrt_iob_func
  00407	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7192
  0040e	48 8b c8	 mov	 rcx, rax
  00411	e8 00 00 00 00	 call	 fprintf

; 141  :             ErrorCode++;

  00416	8b 44 24 20	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  0041a	ff c0		 inc	 eax
  0041c	89 44 24 20	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 142  :             goto memory_cleanup;

  00420	e9 ea 00 00 00	 jmp	 $LN23@main
  00425	e9 e5 00 00 00	 jmp	 $memory_cleanup$34
$LN22@main:

; 143  :         }
; 144  : 
; 145  :         NumPoints++;

  0042a	8b 44 24 34	 mov	 eax, DWORD PTR NumPoints$[rsp]
  0042e	ff c0		 inc	 eax
  00430	89 44 24 34	 mov	 DWORD PTR NumPoints$[rsp], eax

; 146  :         BreakTime += WindowDuration;

  00434	f2 0f 10 44 24
	60		 movsd	 xmm0, QWORD PTR BreakTime$[rsp]
  0043a	f2 0f 58 44 24
	38		 addsd	 xmm0, QWORD PTR WindowDuration$[rsp]
  00440	f2 0f 11 44 24
	60		 movsd	 QWORD PTR BreakTime$[rsp], xmm0

; 147  : 
; 148  :         //Calculate total amount of frames read from the input file
; 149  :         FramesRead_Total++;

  00446	8b 44 24 2c	 mov	 eax, DWORD PTR FramesRead_Total$[rsp]
  0044a	ff c0		 inc	 eax
  0044c	89 44 24 2c	 mov	 DWORD PTR FramesRead_Total$[rsp], eax

; 150  :         
; 151  :         //Update progress for every X number of samples
; 152  :         if(FramesRead_Total % BufferSize == 0)

  00450	33 d2		 xor	 edx, edx
  00452	8b 44 24 2c	 mov	 eax, DWORD PTR FramesRead_Total$[rsp]
  00456	f7 74 24 58	 div	 DWORD PTR BufferSize$[rsp]
  0045a	8b c2		 mov	 eax, edx
  0045c	85 c0		 test	 eax, eax
  0045e	75 10		 jne	 SHORT $LN24@main

; 153  :         {
; 154  :             printf("Info: Copying %ld samples...\r", FramesRead_Total);

  00460	8b 54 24 2c	 mov	 edx, DWORD PTR FramesRead_Total$[rsp]
  00464	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7195
  0046b	e8 00 00 00 00	 call	 printf
$LN24@main:

; 155  :         }
; 156  : 
; 157  :     }

  00470	e9 26 ff ff ff	 jmp	 $LN6@main
$LN7@main:

; 158  : 
; 159  :     //Stage 6: User reporting
; 160  :     if(FramesRead < 0)

  00475	83 7c 24 30 00	 cmp	 DWORD PTR FramesRead$[rsp], 0
  0047a	7d 69		 jge	 SHORT $LN25@main

; 161  :     {
; 162  :         fprintf(stderr, "Error: Cannot read input file %s, output file %s is incomplete\n", argv[ARG_INFILE], argv[ARG_OUTFILE]);

  0047c	b8 08 00 00 00	 mov	 eax, 8
  00481	48 6b c0 02	 imul	 rax, rax, 2
  00485	48 89 44 24 78	 mov	 QWORD PTR tv220[rsp], rax
  0048a	b9 08 00 00 00	 mov	 ecx, 8
  0048f	48 6b c9 01	 imul	 rcx, rcx, 1
  00493	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR tv223[rsp], rcx
  0049b	b9 02 00 00 00	 mov	 ecx, 2
  004a0	e8 00 00 00 00	 call	 __acrt_iob_func
  004a5	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  004ad	48 8b 54 24 78	 mov	 rdx, QWORD PTR tv220[rsp]
  004b2	4c 8b 0c 11	 mov	 r9, QWORD PTR [rcx+rdx]
  004b6	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  004be	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR tv223[rsp]
  004c6	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  004ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7198
  004d1	48 8b c8	 mov	 rcx, rax
  004d4	e8 00 00 00 00	 call	 fprintf

; 163  :         ErrorCode++;

  004d9	8b 44 24 20	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  004dd	ff c0		 inc	 eax
  004df	89 44 24 20	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 164  :     }
; 165  : 
; 166  :     else

  004e3	eb 2a		 jmp	 SHORT $LN26@main
$LN25@main:

; 167  :     {
; 168  :         printf("\nInfo: Done.\n"

  004e5	b8 08 00 00 00	 mov	 eax, 8
  004ea	48 6b c0 02	 imul	 rax, rax, 2
  004ee	44 8b 4c 24 20	 mov	 r9d, DWORD PTR ErrorCode$[rsp]
  004f3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  004fb	4c 8b 04 01	 mov	 r8, QWORD PTR [rcx+rax]
  004ff	8b 54 24 34	 mov	 edx, DWORD PTR NumPoints$[rsp]
  00503	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7199
  0050a	e8 00 00 00 00	 call	 printf
$LN26@main:
$LN17@main:
$LN19@main:
$LN21@main:
$LN23@main:
$memory_cleanup$34:

; 169  :                "Info: %d breakpoints written to %s\n"
; 170  :                "Info: %d errors\n", NumPoints, argv[ARG_OUTFILE], ErrorCode);
; 171  :     }
; 172  : 
; 173  :     //Stage 7: Cleanup
; 174  :     //Close all files and free all allocated memory
; 175  :     memory_cleanup:
; 176  : 
; 177  :     if(InputFile >= 0)

  0050f	83 7c 24 28 00	 cmp	 DWORD PTR InputFile$[rsp], 0
  00514	7c 2a		 jl	 SHORT $LN27@main

; 178  :     {
; 179  :         if(psf_sndClose(InputFile));

  00516	8b 4c 24 28	 mov	 ecx, DWORD PTR InputFile$[rsp]
  0051a	e8 00 00 00 00	 call	 psf_sndClose

; 180  :         {
; 181  :             printf("Warning: Problem closing input file %s\n", argv[ARG_INFILE]);

  0051f	b8 08 00 00 00	 mov	 eax, 8
  00524	48 6b c0 01	 imul	 rax, rax, 1
  00528	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00530	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  00534	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7202
  0053b	e8 00 00 00 00	 call	 printf
$LN27@main:

; 182  :         }
; 183  :     }
; 184  : 
; 185  :     if(BreakpointFile)

  00540	48 83 7c 24 48
	00		 cmp	 QWORD PTR BreakpointFile$[rsp], 0
  00546	74 27		 je	 SHORT $LN29@main

; 186  :     {
; 187  :         if(fclose(BreakpointFile))

  00548	48 8b 4c 24 48	 mov	 rcx, QWORD PTR BreakpointFile$[rsp]
  0054d	e8 00 00 00 00	 call	 fclose
  00552	85 c0		 test	 eax, eax
  00554	74 19		 je	 SHORT $LN30@main

; 188  :         {
; 189  :             fprintf(stderr, "Error: Failed to close breakpoint file\n");

  00556	b9 02 00 00 00	 mov	 ecx, 2
  0055b	e8 00 00 00 00	 call	 __acrt_iob_func
  00560	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7205
  00567	48 8b c8	 mov	 rcx, rax
  0056a	e8 00 00 00 00	 call	 fprintf
$LN30@main:
$LN29@main:

; 190  :         }
; 191  :     }
; 192  :     
; 193  :     if(FramesInput)

  0056f	48 83 7c 24 50
	00		 cmp	 QWORD PTR FramesInput$[rsp], 0
  00575	74 0a		 je	 SHORT $LN31@main

; 194  :     {
; 195  :         free(FramesInput);

  00577	48 8b 4c 24 50	 mov	 rcx, QWORD PTR FramesInput$[rsp]
  0057c	e8 00 00 00 00	 call	 free
$LN31@main:

; 196  :     }
; 197  : 
; 198  :     //Close portsf library
; 199  :     psf_finish();

  00581	e8 00 00 00 00	 call	 psf_finish

; 200  : 
; 201  :     return ErrorCode;

  00586	8b 44 24 20	 mov	 eax, DWORD PTR ErrorCode$[rsp]
$LN1@main:

; 202  : }

  0058a	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00592	48 33 cc	 xor	 rcx, rsp
  00595	e8 00 00 00 00	 call	 __security_check_cookie
  0059a	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  005a1	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\chapter_2\2.4.3\code\envelope_extract.cpp
_TEXT	SEGMENT
i$1 = 32
PeakValue$ = 40
AbsoluteValue$ = 48
ReadBuffer$ = 80
BlockSize$ = 88
?max_sample_value@@YANPEAMK@Z PROC			; max_sample_value

; 206  : {

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 207  :     double AbsoluteValue;
; 208  :     double PeakValue = 0.0;

  0000d	0f 57 c0	 xorps	 xmm0, xmm0
  00010	f2 0f 11 44 24
	28		 movsd	 QWORD PTR PeakValue$[rsp], xmm0

; 209  :     
; 210  :     for (unsigned long i = 0; i < BlockSize; i++)

  00016	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  0001e	eb 0a		 jmp	 SHORT $LN4@max_sample
$LN2@max_sample:
  00020	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00024	ff c0		 inc	 eax
  00026	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN4@max_sample:
  0002a	8b 44 24 58	 mov	 eax, DWORD PTR BlockSize$[rsp]
  0002e	39 44 24 20	 cmp	 DWORD PTR i$1[rsp], eax
  00032	73 35		 jae	 SHORT $LN3@max_sample

; 211  :     {
; 212  :         AbsoluteValue = fabs(ReadBuffer[i]);

  00034	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00038	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ReadBuffer$[rsp]
  0003d	f3 0f 5a 04 81	 cvtss2sd xmm0, DWORD PTR [rcx+rax*4]
  00042	e8 00 00 00 00	 call	 fabs
  00047	f2 0f 11 44 24
	30		 movsd	 QWORD PTR AbsoluteValue$[rsp], xmm0

; 213  : 
; 214  :         if(AbsoluteValue > PeakValue)

  0004d	f2 0f 10 44 24
	30		 movsd	 xmm0, QWORD PTR AbsoluteValue$[rsp]
  00053	66 0f 2f 44 24
	28		 comisd	 xmm0, QWORD PTR PeakValue$[rsp]
  00059	76 0c		 jbe	 SHORT $LN5@max_sample

; 215  :         {
; 216  :             PeakValue = AbsoluteValue;

  0005b	f2 0f 10 44 24
	30		 movsd	 xmm0, QWORD PTR AbsoluteValue$[rsp]
  00061	f2 0f 11 44 24
	28		 movsd	 QWORD PTR PeakValue$[rsp], xmm0
$LN5@max_sample:

; 217  :         }
; 218  :     }

  00067	eb b7		 jmp	 SHORT $LN2@max_sample
$LN3@max_sample:

; 219  : 
; 220  :     return PeakValue;

  00069	f2 0f 10 44 24
	28		 movsd	 xmm0, QWORD PTR PeakValue$[rsp]

; 221  : }

  0006f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00073	c3		 ret	 0
?max_sample_value@@YANPEAMK@Z ENDP			; max_sample_value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 952  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 953  :         int _Result;
; 954  :         va_list _ArgList;
; 955  :         __crt_va_start(_ArgList, _Format);

  00018	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
  0001d	48 8d 44 24 48	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00022	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 956  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00027	b9 01 00 00 00	 mov	 ecx, 1
  0002c	e8 00 00 00 00	 call	 __acrt_iob_func
  00031	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00036	45 33 c0	 xor	 r8d, r8d
  00039	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Format$[rsp]
  0003e	48 8b c8	 mov	 rcx, rax
  00041	e8 00 00 00 00	 call	 _vfprintf_l
  00046	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 957  :         __crt_va_end(_ArgList);

  0004a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 958  :         return _Result;

  00053	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 959  :     }

  00057	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005b	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.11.25503\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>, COMDAT

; 151  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 152  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Stream$ = 64
_Format$ = 72
fprintf	PROC						; COMDAT

; 833  :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 834  :         int _Result;
; 835  :         va_list _ArgList;
; 836  :         __crt_va_start(_ArgList, _Format);

  00018	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
  0001d	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00022	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 837  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00027	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0002c	45 33 c0	 xor	 r8d, r8d
  0002f	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Stream$[rsp]
  00039	e8 00 00 00 00	 call	 _vfprintf_l
  0003e	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 838  :         __crt_va_end(_ArgList);

  00042	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 839  :         return _Result;

  0004b	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 840  :     }

  0004f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00053	c3		 ret	 0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 640  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 641  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	e8 00 00 00 00	 call	 __stdio_common_vfprintf

; 642  :     }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 86   :         static unsigned __int64 _OptionsStorage;
; 87   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 88   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
