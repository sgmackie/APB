; Listing generated by Microsoft (R) Optimizing Compiler Version 19.11.25547.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
aifc_floatstring DB 08H
	DB	046H
	DB	06cH
	DB	06fH
	DB	061H
	DB	074H
	DB	020H
	DB	033H
	DB	032H
	DB	00H
	ORG $+6
aifc_notcompressed DB 0eH
	DB	06eH
	DB	06fH
	DB	074H
	DB	020H
	DB	063H
	DB	06fH
	DB	06dH
	DB	070H
	DB	072H
	DB	065H
	DB	073H
	DB	073H
	DB	065H
	DB	064H
	DB	00H
KSDATAFORMAT_SUBTYPE_PCM DD 01H
	DW	00H
	DW	010H
	DB	080H
	DB	00H
	DB	00H
	DB	0aaH
	DB	00H
	DB	038H
	DB	09bH
	DB	071H
KSDATAFORMAT_SUBTYPE_IEEE_FLOAT DD 03H
	DW	00H
	DW	010H
	DB	080H
	DB	00H
	DB	00H
	DB	0aaH
	DB	00H
	DB	038H
	DB	09bH
	DB	071H
SUBTYPE_AMBISONIC_B_FORMAT_PCM DD 01H
	DW	0721H
	DW	011d3H
	DB	086H
	DB	044H
	DB	0c8H
	DB	0c1H
	DB	0caH
	DB	00H
	DB	00H
	DB	00H
SUBTYPE_AMBISONIC_B_FORMAT_IEEE_FLOAT DD 03H
	DW	0721H
	DW	011d3H
	DB	086H
	DB	044H
	DB	0c8H
	DB	0c1H
	DB	0caH
	DB	00H
	DB	00H
	DB	00H
CONST	ENDS
_DATA	SEGMENT
$SG10269 DB	'wb+', 00H
$SG10281 DB	'wb', 00H
	ORG $+1
$SG11160 DB	'rb', 00H
	ORG $+1
$SG11460 DB	'.wav', 00H
	ORG $+3
$SG11464 DB	'.aif', 00H
	ORG $+3
$SG11465 DB	'.aiff', 00H
	ORG $+2
$SG11469 DB	'.afc', 00H
	ORG $+3
$SG11470 DB	'.aifc', 00H
	ORG $+2
$SG11473 DB	'.wxyz', 00H
	ORG $+2
$SG11476 DB	'.amb', 00H
	ORG $+7
inv_randmax DQ	03f00002000400080r		; 3.05185e-05
_DATA	ENDS
PUBLIC	stricmp
PUBLIC	strnicmp
PUBLIC	psf_init
PUBLIC	psf_finish
PUBLIC	psf_sndCreate
PUBLIC	psf_sndOpen
PUBLIC	psf_sndClose
PUBLIC	psf_sndSize
PUBLIC	psf_sndWriteFloatFrames
PUBLIC	psf_sndWriteDoubleFrames
PUBLIC	psf_sndWriteShortFrames
PUBLIC	psf_sndTell
PUBLIC	psf_sndSeek
PUBLIC	psf_sndReadFloatFrames
PUBLIC	psf_sndReadDoubleFrames
PUBLIC	psf_sndReadPeaks
PUBLIC	psf_getFormatExt
PUBLIC	psf_sndSetDither
PUBLIC	psf_sndGetDither
PUBLIC	psf_speakermask
PUBLIC	get_speakerlayout
PUBLIC	psf_round
PUBLIC	__real@3f800000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@40dfff8000000000
PUBLIC	__real@40e0000000000000
PUBLIC	__real@41e0000000000000
PUBLIC	__real@bf800000
EXTRN	fclose:PROC
EXTRN	fflush:PROC
EXTRN	fgetpos:PROC
EXTRN	fopen:PROC
EXTRN	fread:PROC
EXTRN	fsetpos:PROC
EXTRN	fseek:PROC
EXTRN	fwrite:PROC
EXTRN	rewind:PROC
EXTRN	free:PROC
EXTRN	malloc:PROC
EXTRN	rand:PROC
EXTRN	memcmp:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	strrchr:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	fabs:PROC
EXTRN	_time64:PROC
EXTRN	ieee_80_to_double:PROC
EXTRN	double_to_ieee_80:PROC
EXTRN	islower:PROC
EXTRN	toupper:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_BSS	SEGMENT
psf_files DQ	040H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$stricmp DD imagerel $LN13
	DD	imagerel $LN13+288
	DD	imagerel $unwind$stricmp
$pdata$strnicmp DD imagerel $LN14
	DD	imagerel $LN14+330
	DD	imagerel $unwind$strnicmp
$pdata$time DD	imagerel time
	DD	imagerel time+24
	DD	imagerel $unwind$time
$pdata$psf_init DD imagerel $LN6
	DD	imagerel $LN6+55
	DD	imagerel $unwind$psf_init
$pdata$psf_finish DD imagerel $LN8
	DD	imagerel $LN8+148
	DD	imagerel $unwind$psf_finish
$pdata$psf_sndCreate DD imagerel $LN29
	DD	imagerel $LN29+688
	DD	imagerel $unwind$psf_sndCreate
$pdata$psf_sndOpen DD imagerel $LN20
	DD	imagerel $LN20+622
	DD	imagerel $unwind$psf_sndOpen
$pdata$psf_sndClose DD imagerel $LN15
	DD	imagerel $LN15+246
	DD	imagerel $unwind$psf_sndClose
$pdata$psf_sndSize DD imagerel $LN6
	DD	imagerel $LN6+75
	DD	imagerel $unwind$psf_sndSize
$pdata$psf_sndWriteFloatFrames DD imagerel $LN143
	DD	imagerel $LN143+4558
	DD	imagerel $unwind$psf_sndWriteFloatFrames
$pdata$psf_sndWriteDoubleFrames DD imagerel $LN143
	DD	imagerel $LN143+4537
	DD	imagerel $unwind$psf_sndWriteDoubleFrames
$pdata$psf_sndWriteShortFrames DD imagerel $LN28
	DD	imagerel $LN28+936
	DD	imagerel $unwind$psf_sndWriteShortFrames
$pdata$psf_sndTell DD imagerel $LN7
	DD	imagerel $LN7+165
	DD	imagerel $unwind$psf_sndTell
$pdata$psf_sndSeek DD imagerel $LN19
	DD	imagerel $LN19+474
	DD	imagerel $unwind$psf_sndSeek
$pdata$psf_sndReadFloatFrames DD imagerel $LN71
	DD	imagerel $LN71+1895
	DD	imagerel $unwind$psf_sndReadFloatFrames
$pdata$psf_sndReadDoubleFrames DD imagerel $LN74
	DD	imagerel $LN74+1946
	DD	imagerel $unwind$psf_sndReadDoubleFrames
$pdata$psf_sndReadPeaks DD imagerel $LN12
	DD	imagerel $LN12+269
	DD	imagerel $unwind$psf_sndReadPeaks
$pdata$psf_getFormatExt DD imagerel $LN18
	DD	imagerel $LN18+280
	DD	imagerel $unwind$psf_getFormatExt
$pdata$psf_sndSetDither DD imagerel $LN8
	DD	imagerel $LN8+119
	DD	imagerel $unwind$psf_sndSetDither
$pdata$psf_sndGetDither DD imagerel $LN6
	DD	imagerel $LN6+78
	DD	imagerel $unwind$psf_sndGetDither
$pdata$psf_speakermask DD imagerel $LN6
	DD	imagerel $LN6+75
	DD	imagerel $unwind$psf_speakermask
$pdata$get_speakerlayout DD imagerel $LN22
	DD	imagerel $LN22+231
	DD	imagerel $unwind$get_speakerlayout
$pdata$trirand DD imagerel trirand
	DD	imagerel trirand+79
	DD	imagerel $unwind$trirand
$pdata$compare_guids DD imagerel compare_guids
	DD	imagerel compare_guids+86
	DD	imagerel $unwind$compare_guids
$pdata$psf_release_file DD imagerel psf_release_file
	DD	imagerel psf_release_file+166
	DD	imagerel $unwind$psf_release_file
$pdata$byte_order DD imagerel byte_order
	DD	imagerel byte_order+33
	DD	imagerel $unwind$byte_order
$pdata$fmtSwapBytes DD imagerel fmtSwapBytes
	DD	imagerel fmtSwapBytes+348
	DD	imagerel $unwind$fmtSwapBytes
$pdata$fmtExSwapBytes DD imagerel fmtExSwapBytes
	DD	imagerel fmtExSwapBytes+701
	DD	imagerel $unwind$fmtExSwapBytes
$pdata$check_guid DD imagerel check_guid
	DD	imagerel check_guid+551
	DD	imagerel $unwind$check_guid
$pdata$psf_bitsize DD imagerel psf_bitsize
	DD	imagerel psf_bitsize+86
	DD	imagerel $unwind$psf_bitsize
$pdata$psf_wordsize DD imagerel psf_wordsize
	DD	imagerel psf_wordsize+86
	DD	imagerel $unwind$psf_wordsize
$pdata$psf_round DD imagerel $LN4
	DD	imagerel $LN4+67
	DD	imagerel $unwind$psf_round
$pdata$psf_newFile DD imagerel psf_newFile
	DD	imagerel psf_newFile+1408
	DD	imagerel $unwind$psf_newFile
$pdata$wavUpdate DD imagerel wavUpdate
	DD	imagerel wavUpdate+908
	DD	imagerel $unwind$wavUpdate
$pdata$aiffUpdate DD imagerel aiffUpdate
	DD	imagerel aiffUpdate+1286
	DD	imagerel $unwind$aiffUpdate
$pdata$wavDoWrite DD imagerel wavDoWrite
	DD	imagerel wavDoWrite+141
	DD	imagerel $unwind$wavDoWrite
$pdata$wavDoRead DD imagerel wavDoRead
	DD	imagerel wavDoRead+141
	DD	imagerel $unwind$wavDoRead
$pdata$wavWriteHeader DD imagerel wavWriteHeader
	DD	imagerel wavWriteHeader+1471
	DD	imagerel $unwind$wavWriteHeader
$pdata$waveExWriteHeader DD imagerel waveExWriteHeader
	DD	imagerel waveExWriteHeader+1668
	DD	imagerel $unwind$waveExWriteHeader
$pdata$aiffWriteHeader DD imagerel aiffWriteHeader
	DD	imagerel aiffWriteHeader+1819
	DD	imagerel $unwind$aiffWriteHeader
$pdata$aifcWriteHeader DD imagerel aifcWriteHeader
	DD	imagerel aifcWriteHeader+2369
	DD	imagerel $unwind$aifcWriteHeader
$pdata$wavReadHeader DD imagerel wavReadHeader
	DD	imagerel wavReadHeader+3275
	DD	imagerel $unwind$wavReadHeader
$pdata$aiffReadHeader DD imagerel aiffReadHeader
	DD	imagerel aiffReadHeader+2973
	DD	imagerel $unwind$aiffReadHeader
$pdata$aifcReadHeader DD imagerel aifcReadHeader
	DD	imagerel aifcReadHeader+3487
	DD	imagerel $unwind$aifcReadHeader
pdata	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@41e0000000000000
CONST	SEGMENT
__real@41e0000000000000 DQ 041e0000000000000r	; 2.14748e+09
CONST	ENDS
;	COMDAT __real@40e0000000000000
CONST	SEGMENT
__real@40e0000000000000 DQ 040e0000000000000r	; 32768
CONST	ENDS
;	COMDAT __real@40dfff8000000000
CONST	SEGMENT
__real@40dfff8000000000 DQ 040dfff8000000000r	; 32766
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
xdata	SEGMENT
$unwind$stricmp DD 010e01H
	DD	0620eH
$unwind$strnicmp DD 011301H
	DD	08213H
$unwind$time DD	010901H
	DD	04209H
$unwind$psf_init DD 010401H
	DD	02204H
$unwind$psf_finish DD 010401H
	DD	06204H
$unwind$psf_sndCreate DD 011801H
	DD	0a218H
$unwind$psf_sndOpen DD 011301H
	DD	0a213H
$unwind$psf_sndClose DD 010801H
	DD	06208H
$unwind$psf_sndSize DD 010801H
	DD	02208H
$unwind$psf_sndWriteFloatFrames DD 021501H
	DD	01b0115H
$unwind$psf_sndWriteDoubleFrames DD 021501H
	DD	01b0115H
$unwind$psf_sndWriteShortFrames DD 011201H
	DD	0e212H
$unwind$psf_sndTell DD 010801H
	DD	08208H
$unwind$psf_sndSeek DD 011101H
	DD	0a211H
$unwind$psf_sndReadFloatFrames DD 011201H
	DD	0e212H
$unwind$psf_sndReadDoubleFrames DD 011201H
	DD	0e212H
$unwind$psf_sndReadPeaks DD 011201H
	DD	02212H
$unwind$psf_getFormatExt DD 010901H
	DD	06209H
$unwind$psf_sndSetDither DD 010c01H
	DD	0220cH
$unwind$psf_sndGetDither DD 010801H
	DD	02208H
$unwind$psf_speakermask DD 010801H
	DD	02208H
$unwind$get_speakerlayout DD 010c01H
	DD	0220cH
$unwind$trirand DD 010401H
	DD	06204H
$unwind$compare_guids DD 010e01H
	DD	0820eH
$unwind$psf_release_file DD 010901H
	DD	06209H
$unwind$byte_order DD 010401H
	DD	02204H
$unwind$fmtSwapBytes DD 010901H
	DD	02209H
$unwind$fmtExSwapBytes DD 010901H
	DD	02209H
$unwind$check_guid DD 010901H
	DD	06209H
$unwind$psf_bitsize DD 010801H
	DD	02208H
$unwind$psf_wordsize DD 010801H
	DD	02208H
$unwind$psf_round DD 010a01H
	DD	0620aH
$unwind$psf_newFile DD 010901H
	DD	0c209H
$unwind$wavUpdate DD 010901H
	DD	0a209H
$unwind$aiffUpdate DD 010901H
	DD	0c209H
$unwind$wavDoWrite DD 011301H
	DD	06213H
$unwind$wavDoRead DD 011301H
	DD	06213H
$unwind$wavWriteHeader DD 010901H
	DD	0a209H
$unwind$waveExWriteHeader DD 010901H
	DD	0a209H
$unwind$aiffWriteHeader DD 011819H
	DD	0e209H
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$aifcWriteHeader DD 021b19H
	DD	011010cH
	DD	imagerel __GSHandlerCheck
	DD	078H
$unwind$wavReadHeader DD 020c01H
	DD	011010cH
$unwind$aiffReadHeader DD 021e19H
	DD	013010cH
	DD	imagerel __GSHandlerCheck
	DD	088H
$unwind$aifcReadHeader DD 021e19H
	DD	015010cH
	DD	imagerel __GSHandlerCheck
	DD	090H
xdata	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
tag$ = 32
remain$ = 36
wData$ = 40
size$ = 44
ID_compression$ = 48
i$1 = 52
aifcver$ = 56
dwData$ = 60
version$ = 64
peaktime$ = 68
offset$ = 72
tv194 = 76
blocksize$ = 80
i$2 = 84
fac$3 = 88
tv289 = 92
have_comm$ = 96
have_ssnd$ = 100
have_fver$ = 104
tv570 = 108
pBlock$4 = 112
bytepos$ = 120
ieee$ = 128
__$ArrayPad$ = 144
sfdat$ = 176
aifcReadHeader PROC

; 2484 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2485 : 	DWORD tag,version,peaktime,remain,offset,blocksize;
; 2486 : 	int have_comm =0,have_ssnd =0,have_fver = 0;	

  0001e	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR have_comm$[rsp], 0
  00026	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR have_ssnd$[rsp], 0
  0002e	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR have_fver$[rsp], 0

; 2487 : 	DWORD dwData,size,aifcver,ID_compression;
; 2488 : 	unsigned char ieee[10];
; 2489 : 	WORD wData;
; 2490 : 	fpos_t bytepos;
; 2491 : 
; 2492 : 	if(sfdat==NULL || sfdat->file == NULL)

  00036	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR sfdat$[rsp], 0
  0003f	74 0e		 je	 SHORT $LN15@aifcReadHe
  00041	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00049	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0004d	75 0a		 jne	 SHORT $LN14@aifcReadHe
$LN15@aifcReadHe:

; 2493 : 		return PSF_E_BADARG;

  0004f	b8 f6 ff ff ff	 mov	 eax, -10
  00054	e9 2e 0d 00 00	 jmp	 $LN1@aifcReadHe
$LN14@aifcReadHe:

; 2494 : 
; 2495 : 	if(wavDoRead(sfdat,(char *)&tag,sizeof(DWORD))
; 2496 : 		|| wavDoRead(sfdat,(char *) &remain,sizeof(DWORD)))

  00059	41 b8 04 00 00
	00		 mov	 r8d, 4
  0005f	48 8d 54 24 20	 lea	 rdx, QWORD PTR tag$[rsp]
  00064	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0006c	e8 00 00 00 00	 call	 wavDoRead
  00071	85 c0		 test	 eax, eax
  00073	75 1c		 jne	 SHORT $LN17@aifcReadHe
  00075	41 b8 04 00 00
	00		 mov	 r8d, 4
  0007b	48 8d 54 24 24	 lea	 rdx, QWORD PTR remain$[rsp]
  00080	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00088	e8 00 00 00 00	 call	 wavDoRead
  0008d	85 c0		 test	 eax, eax
  0008f	74 0a		 je	 SHORT $LN16@aifcReadHe
$LN17@aifcReadHe:

; 2497 : 		return PSF_E_CANT_READ;

  00091	b8 fc ff ff ff	 mov	 eax, -4
  00096	e9 ec 0c 00 00	 jmp	 $LN1@aifcReadHe
$LN16@aifcReadHe:

; 2498 : 	if(sfdat->is_little_endian) {

  0009b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  000a3	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  000a7	74 7a		 je	 SHORT $LN18@aifcReadHe

; 2499 : 		remain = REVDWBYTES(remain);	

  000a9	8b 44 24 24	 mov	 eax, DWORD PTR remain$[rsp]
  000ad	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000b2	c1 e0 18	 shl	 eax, 24
  000b5	8b 4c 24 24	 mov	 ecx, DWORD PTR remain$[rsp]
  000b9	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  000bf	c1 e1 08	 shl	 ecx, 8
  000c2	0b c1		 or	 eax, ecx
  000c4	8b 4c 24 24	 mov	 ecx, DWORD PTR remain$[rsp]
  000c8	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  000ce	c1 e9 08	 shr	 ecx, 8
  000d1	0b c1		 or	 eax, ecx
  000d3	8b 4c 24 24	 mov	 ecx, DWORD PTR remain$[rsp]
  000d7	c1 e9 18	 shr	 ecx, 24
  000da	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000e0	0b c1		 or	 eax, ecx
  000e2	89 44 24 24	 mov	 DWORD PTR remain$[rsp], eax

; 2500 : 		tag = REVDWBYTES(tag);

  000e6	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  000ea	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000ef	c1 e0 18	 shl	 eax, 24
  000f2	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  000f6	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  000fc	c1 e1 08	 shl	 ecx, 8
  000ff	0b c1		 or	 eax, ecx
  00101	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00105	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  0010b	c1 e9 08	 shr	 ecx, 8
  0010e	0b c1		 or	 eax, ecx
  00110	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00114	c1 e9 18	 shr	 ecx, 24
  00117	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0011d	0b c1		 or	 eax, ecx
  0011f	89 44 24 20	 mov	 DWORD PTR tag$[rsp], eax
$LN18@aifcReadHe:

; 2501 : 	}
; 2502 : 	if(tag != TAG('F','O','R','M')){

  00123	81 7c 24 20 4d
	52 4f 46	 cmp	 DWORD PTR tag$[rsp], 1179603533 ; 464f524dH
  0012b	74 0a		 je	 SHORT $LN19@aifcReadHe

; 2503 : 		DBGFPRINTF((stderr, "file is not AIFC: no FORM chunk\n"));
; 2504 : 		return PSF_E_BADARG;

  0012d	b8 f6 ff ff ff	 mov	 eax, -10
  00132	e9 50 0c 00 00	 jmp	 $LN1@aifcReadHe
$LN19@aifcReadHe:

; 2505 : 	}
; 2506 : 	
; 2507 : 	if(wavDoRead(sfdat,(char *)&tag,sizeof(DWORD)))

  00137	41 b8 04 00 00
	00		 mov	 r8d, 4
  0013d	48 8d 54 24 20	 lea	 rdx, QWORD PTR tag$[rsp]
  00142	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0014a	e8 00 00 00 00	 call	 wavDoRead
  0014f	85 c0		 test	 eax, eax
  00151	74 0a		 je	 SHORT $LN20@aifcReadHe

; 2508 : 		return PSF_E_CANT_READ;

  00153	b8 fc ff ff ff	 mov	 eax, -4
  00158	e9 2a 0c 00 00	 jmp	 $LN1@aifcReadHe
$LN20@aifcReadHe:

; 2509 : 	if(sfdat->is_little_endian)

  0015d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00165	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00169	74 3d		 je	 SHORT $LN21@aifcReadHe

; 2510 : 		tag = REVDWBYTES(tag);

  0016b	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  0016f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00174	c1 e0 18	 shl	 eax, 24
  00177	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  0017b	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00181	c1 e1 08	 shl	 ecx, 8
  00184	0b c1		 or	 eax, ecx
  00186	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  0018a	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00190	c1 e9 08	 shr	 ecx, 8
  00193	0b c1		 or	 eax, ecx
  00195	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00199	c1 e9 18	 shr	 ecx, 24
  0019c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  001a2	0b c1		 or	 eax, ecx
  001a4	89 44 24 20	 mov	 DWORD PTR tag$[rsp], eax
$LN21@aifcReadHe:

; 2511 : 	if(tag != TAG('A','I','F','C')){

  001a8	81 7c 24 20 43
	46 49 41	 cmp	 DWORD PTR tag$[rsp], 1095321155 ; 41494643H
  001b0	74 0a		 je	 SHORT $LN22@aifcReadHe

; 2512 : 		DBGFPRINTF((stderr, "file is not AIFC: no AIFC chunk\n"));
; 2513 : 		return PSF_E_BADARG;

  001b2	b8 f6 ff ff ff	 mov	 eax, -10
  001b7	e9 cb 0b 00 00	 jmp	 $LN1@aifcReadHe
$LN22@aifcReadHe:

; 2514 : 	}
; 2515 : 	remain -= sizeof(DWORD);

  001bc	8b 44 24 24	 mov	 eax, DWORD PTR remain$[rsp]
  001c0	48 83 e8 04	 sub	 rax, 4
  001c4	89 44 24 24	 mov	 DWORD PTR remain$[rsp], eax
$LN2@aifcReadHe:

; 2516 : 
; 2517 : 
; 2518 : 	while(remain > 0){

  001c8	83 7c 24 24 00	 cmp	 DWORD PTR remain$[rsp], 0
  001cd	0f 86 55 0a 00
	00		 jbe	 $LN3@aifcReadHe

; 2519 : 		if(wavDoRead(sfdat,(char *)&tag,sizeof(DWORD))
; 2520 : 		|| wavDoRead(sfdat,(char *) &size,sizeof(DWORD)))

  001d3	41 b8 04 00 00
	00		 mov	 r8d, 4
  001d9	48 8d 54 24 20	 lea	 rdx, QWORD PTR tag$[rsp]
  001de	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  001e6	e8 00 00 00 00	 call	 wavDoRead
  001eb	85 c0		 test	 eax, eax
  001ed	75 1c		 jne	 SHORT $LN24@aifcReadHe
  001ef	41 b8 04 00 00
	00		 mov	 r8d, 4
  001f5	48 8d 54 24 2c	 lea	 rdx, QWORD PTR size$[rsp]
  001fa	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00202	e8 00 00 00 00	 call	 wavDoRead
  00207	85 c0		 test	 eax, eax
  00209	74 0a		 je	 SHORT $LN23@aifcReadHe
$LN24@aifcReadHe:

; 2521 : 			return PSF_E_CANT_READ;

  0020b	b8 fc ff ff ff	 mov	 eax, -4
  00210	e9 72 0b 00 00	 jmp	 $LN1@aifcReadHe
$LN23@aifcReadHe:

; 2522 : 		if(sfdat->is_little_endian) {

  00215	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0021d	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00221	74 7a		 je	 SHORT $LN25@aifcReadHe

; 2523 : 			size = REVDWBYTES(size);	

  00223	8b 44 24 2c	 mov	 eax, DWORD PTR size$[rsp]
  00227	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0022c	c1 e0 18	 shl	 eax, 24
  0022f	8b 4c 24 2c	 mov	 ecx, DWORD PTR size$[rsp]
  00233	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00239	c1 e1 08	 shl	 ecx, 8
  0023c	0b c1		 or	 eax, ecx
  0023e	8b 4c 24 2c	 mov	 ecx, DWORD PTR size$[rsp]
  00242	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00248	c1 e9 08	 shr	 ecx, 8
  0024b	0b c1		 or	 eax, ecx
  0024d	8b 4c 24 2c	 mov	 ecx, DWORD PTR size$[rsp]
  00251	c1 e9 18	 shr	 ecx, 24
  00254	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0025a	0b c1		 or	 eax, ecx
  0025c	89 44 24 2c	 mov	 DWORD PTR size$[rsp], eax

; 2524 : 			tag = REVDWBYTES(tag);

  00260	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  00264	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00269	c1 e0 18	 shl	 eax, 24
  0026c	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00270	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00276	c1 e1 08	 shl	 ecx, 8
  00279	0b c1		 or	 eax, ecx
  0027b	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  0027f	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00285	c1 e9 08	 shr	 ecx, 8
  00288	0b c1		 or	 eax, ecx
  0028a	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  0028e	c1 e9 18	 shr	 ecx, 24
  00291	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00297	0b c1		 or	 eax, ecx
  00299	89 44 24 20	 mov	 DWORD PTR tag$[rsp], eax
$LN25@aifcReadHe:

; 2525 : 		}
; 2526 : 		remain -= 2 * sizeof(DWORD);

  0029d	8b 44 24 24	 mov	 eax, DWORD PTR remain$[rsp]
  002a1	48 83 e8 08	 sub	 rax, 8
  002a5	89 44 24 24	 mov	 DWORD PTR remain$[rsp], eax

; 2527 : 		switch(tag){

  002a9	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  002ad	89 44 24 4c	 mov	 DWORD PTR tv194[rsp], eax
  002b1	83 7c 24 4c 00	 cmp	 DWORD PTR tv194[rsp], 0
  002b6	0f 84 19 09 00
	00		 je	 $LN71@aifcReadHe
  002bc	81 7c 24 4c 4d
	4d 4f 43	 cmp	 DWORD PTR tv194[rsp], 1129270605 ; 434f4d4dH
  002c4	0f 84 dd 00 00
	00		 je	 $LN31@aifcReadHe
  002ca	81 7c 24 4c 52
	45 56 46	 cmp	 DWORD PTR tv194[rsp], 1180058962 ; 46564552H
  002d2	74 21		 je	 SHORT $LN26@aifcReadHe
  002d4	81 7c 24 4c 4b
	41 45 50	 cmp	 DWORD PTR tv194[rsp], 1346715979 ; 5045414bH
  002dc	0f 84 9b 04 00
	00		 je	 $LN53@aifcReadHe
  002e2	81 7c 24 4c 44
	4e 53 53	 cmp	 DWORD PTR tv194[rsp], 1397968452 ; 53534e44H
  002ea	0f 84 56 07 00
	00		 je	 $LN65@aifcReadHe
  002f0	e9 ea 08 00 00	 jmp	 $LN72@aifcReadHe
$LN26@aifcReadHe:

; 2528 : 		case(TAG('F','V','E','R')):
; 2529 : 			if(size != sizeof(DWORD)){

  002f5	8b 44 24 2c	 mov	 eax, DWORD PTR size$[rsp]
  002f9	48 83 f8 04	 cmp	 rax, 4
  002fd	74 0a		 je	 SHORT $LN27@aifcReadHe

; 2530 : 				DBGFPRINTF((stderr, "AIFC file has bad size for FVER chunk\n"));
; 2531 : 				return PSF_E_BAD_FORMAT;

  002ff	b8 f9 ff ff ff	 mov	 eax, -7
  00304	e9 7e 0a 00 00	 jmp	 $LN1@aifcReadHe
$LN27@aifcReadHe:

; 2532 : 			}
; 2533 : 			if(wavDoRead(sfdat,(char *) &aifcver,sizeof(DWORD)))

  00309	41 b8 04 00 00
	00		 mov	 r8d, 4
  0030f	48 8d 54 24 38	 lea	 rdx, QWORD PTR aifcver$[rsp]
  00314	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0031c	e8 00 00 00 00	 call	 wavDoRead
  00321	85 c0		 test	 eax, eax
  00323	74 0a		 je	 SHORT $LN28@aifcReadHe

; 2534 : 				return PSF_E_CANT_READ;

  00325	b8 fc ff ff ff	 mov	 eax, -4
  0032a	e9 58 0a 00 00	 jmp	 $LN1@aifcReadHe
$LN28@aifcReadHe:

; 2535 : 			if(sfdat->is_little_endian) 

  0032f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00337	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0033b	74 3d		 je	 SHORT $LN29@aifcReadHe

; 2536 : 				aifcver = REVDWBYTES(aifcver);

  0033d	8b 44 24 38	 mov	 eax, DWORD PTR aifcver$[rsp]
  00341	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00346	c1 e0 18	 shl	 eax, 24
  00349	8b 4c 24 38	 mov	 ecx, DWORD PTR aifcver$[rsp]
  0034d	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00353	c1 e1 08	 shl	 ecx, 8
  00356	0b c1		 or	 eax, ecx
  00358	8b 4c 24 38	 mov	 ecx, DWORD PTR aifcver$[rsp]
  0035c	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00362	c1 e9 08	 shr	 ecx, 8
  00365	0b c1		 or	 eax, ecx
  00367	8b 4c 24 38	 mov	 ecx, DWORD PTR aifcver$[rsp]
  0036b	c1 e9 18	 shr	 ecx, 24
  0036e	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00374	0b c1		 or	 eax, ecx
  00376	89 44 24 38	 mov	 DWORD PTR aifcver$[rsp], eax
$LN29@aifcReadHe:

; 2537 : 			remain-= sizeof(DWORD);

  0037a	8b 44 24 24	 mov	 eax, DWORD PTR remain$[rsp]
  0037e	48 83 e8 04	 sub	 rax, 4
  00382	89 44 24 24	 mov	 DWORD PTR remain$[rsp], eax

; 2538 : 			if(aifcver != AIFC_VERSION_1)

  00386	81 7c 24 38 40
	51 80 a2	 cmp	 DWORD PTR aifcver$[rsp], -1568648896 ; a2805140H
  0038e	74 0a		 je	 SHORT $LN30@aifcReadHe

; 2539 : 				return PSF_E_UNSUPPORTED;

  00390	b8 f8 ff ff ff	 mov	 eax, -8
  00395	e9 ed 09 00 00	 jmp	 $LN1@aifcReadHe
$LN30@aifcReadHe:

; 2540 : 			have_fver = 1;

  0039a	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR have_fver$[rsp], 1

; 2541 : 			break;

  003a2	e9 7c 08 00 00	 jmp	 $LN4@aifcReadHe
$LN31@aifcReadHe:

; 2542 : 		case(TAG('C','O','M','M')):
; 2543 : 			if(size < 22) {

  003a7	83 7c 24 2c 16	 cmp	 DWORD PTR size$[rsp], 22
  003ac	73 0a		 jae	 SHORT $LN32@aifcReadHe

; 2544 : 			   DBGFPRINTF((stderr, "AIFC file has bad size for COMM chunk\n"));
; 2545 : 			   return PSF_E_BAD_FORMAT;

  003ae	b8 f9 ff ff ff	 mov	 eax, -7
  003b3	e9 cf 09 00 00	 jmp	 $LN1@aifcReadHe
$LN32@aifcReadHe:

; 2546 : 			}
; 2547 : 			if(fgetpos(sfdat->file,&sfdat->fmtoffset))

  003b8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  003c0	48 83 c0 40	 add	 rax, 64			; 00000040H
  003c4	48 8b d0	 mov	 rdx, rax
  003c7	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  003cf	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  003d2	e8 00 00 00 00	 call	 fgetpos
  003d7	85 c0		 test	 eax, eax
  003d9	74 0a		 je	 SHORT $LN33@aifcReadHe

; 2548 : 			    return PSF_E_CANT_SEEK;

  003db	b8 f5 ff ff ff	 mov	 eax, -11
  003e0	e9 a2 09 00 00	 jmp	 $LN1@aifcReadHe
$LN33@aifcReadHe:

; 2549 : 			if(wavDoRead(sfdat,(char *)&wData,sizeof(WORD)))

  003e5	41 b8 02 00 00
	00		 mov	 r8d, 2
  003eb	48 8d 54 24 28	 lea	 rdx, QWORD PTR wData$[rsp]
  003f0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  003f8	e8 00 00 00 00	 call	 wavDoRead
  003fd	85 c0		 test	 eax, eax
  003ff	74 0a		 je	 SHORT $LN34@aifcReadHe

; 2550 : 				return PSF_E_CANT_READ;

  00401	b8 fc ff ff ff	 mov	 eax, -4
  00406	e9 7c 09 00 00	 jmp	 $LN1@aifcReadHe
$LN34@aifcReadHe:

; 2551 : 			if(sfdat->is_little_endian)

  0040b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00413	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00417	74 22		 je	 SHORT $LN35@aifcReadHe

; 2552 : 				wData = (WORD) REVWBYTES(wData);

  00419	0f b7 44 24 28	 movzx	 eax, WORD PTR wData$[rsp]
  0041e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00423	c1 e0 08	 shl	 eax, 8
  00426	0f b7 4c 24 28	 movzx	 ecx, WORD PTR wData$[rsp]
  0042b	c1 f9 08	 sar	 ecx, 8
  0042e	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00434	0b c1		 or	 eax, ecx
  00436	66 89 44 24 28	 mov	 WORD PTR wData$[rsp], ax
$LN35@aifcReadHe:

; 2553 : 			sfdat->fmt.Format.nChannels = wData;

  0043b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00443	0f b7 4c 24 28	 movzx	 ecx, WORD PTR wData$[rsp]
  00448	66 89 48 52	 mov	 WORD PTR [rax+82], cx

; 2554 : 			if(wavDoRead(sfdat,(char *)&dwData,sizeof(DWORD)))

  0044c	41 b8 04 00 00
	00		 mov	 r8d, 4
  00452	48 8d 54 24 3c	 lea	 rdx, QWORD PTR dwData$[rsp]
  00457	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0045f	e8 00 00 00 00	 call	 wavDoRead
  00464	85 c0		 test	 eax, eax
  00466	74 0a		 je	 SHORT $LN36@aifcReadHe

; 2555 : 				return PSF_E_CANT_READ;

  00468	b8 fc ff ff ff	 mov	 eax, -4
  0046d	e9 15 09 00 00	 jmp	 $LN1@aifcReadHe
$LN36@aifcReadHe:

; 2556 : 			if(sfdat->is_little_endian)

  00472	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0047a	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0047e	74 3d		 je	 SHORT $LN37@aifcReadHe

; 2557 : 				dwData = REVDWBYTES(dwData);

  00480	8b 44 24 3c	 mov	 eax, DWORD PTR dwData$[rsp]
  00484	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00489	c1 e0 18	 shl	 eax, 24
  0048c	8b 4c 24 3c	 mov	 ecx, DWORD PTR dwData$[rsp]
  00490	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00496	c1 e1 08	 shl	 ecx, 8
  00499	0b c1		 or	 eax, ecx
  0049b	8b 4c 24 3c	 mov	 ecx, DWORD PTR dwData$[rsp]
  0049f	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  004a5	c1 e9 08	 shr	 ecx, 8
  004a8	0b c1		 or	 eax, ecx
  004aa	8b 4c 24 3c	 mov	 ecx, DWORD PTR dwData$[rsp]
  004ae	c1 e9 18	 shr	 ecx, 24
  004b1	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  004b7	0b c1		 or	 eax, ecx
  004b9	89 44 24 3c	 mov	 DWORD PTR dwData$[rsp], eax
$LN37@aifcReadHe:

; 2558 : 			sfdat->nFrames = dwData;

  004bd	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  004c5	8b 4c 24 3c	 mov	 ecx, DWORD PTR dwData$[rsp]
  004c9	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 2559 : 			if(wavDoRead(sfdat,(char *)&wData,sizeof(WORD)))

  004cc	41 b8 02 00 00
	00		 mov	 r8d, 2
  004d2	48 8d 54 24 28	 lea	 rdx, QWORD PTR wData$[rsp]
  004d7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  004df	e8 00 00 00 00	 call	 wavDoRead
  004e4	85 c0		 test	 eax, eax
  004e6	74 0a		 je	 SHORT $LN38@aifcReadHe

; 2560 : 				return PSF_E_CANT_READ;

  004e8	b8 fc ff ff ff	 mov	 eax, -4
  004ed	e9 95 08 00 00	 jmp	 $LN1@aifcReadHe
$LN38@aifcReadHe:

; 2561 : 			if(sfdat->is_little_endian)

  004f2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  004fa	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  004fe	74 22		 je	 SHORT $LN39@aifcReadHe

; 2562 : 				wData = (WORD) REVWBYTES(wData);

  00500	0f b7 44 24 28	 movzx	 eax, WORD PTR wData$[rsp]
  00505	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0050a	c1 e0 08	 shl	 eax, 8
  0050d	0f b7 4c 24 28	 movzx	 ecx, WORD PTR wData$[rsp]
  00512	c1 f9 08	 sar	 ecx, 8
  00515	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0051b	0b c1		 or	 eax, ecx
  0051d	66 89 44 24 28	 mov	 WORD PTR wData$[rsp], ax
$LN39@aifcReadHe:

; 2563 : 			sfdat->fmt.Format.wBitsPerSample = wData;

  00522	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0052a	0f b7 4c 24 28	 movzx	 ecx, WORD PTR wData$[rsp]
  0052f	66 89 48 5e	 mov	 WORD PTR [rax+94], cx

; 2564 : 			if(wavDoRead(sfdat,ieee,10))

  00533	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00539	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR ieee$[rsp]
  00541	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00549	e8 00 00 00 00	 call	 wavDoRead
  0054e	85 c0		 test	 eax, eax
  00550	74 0a		 je	 SHORT $LN40@aifcReadHe

; 2565 : 				return PSF_E_CANT_READ;

  00552	b8 fc ff ff ff	 mov	 eax, -4
  00557	e9 2b 08 00 00	 jmp	 $LN1@aifcReadHe
$LN40@aifcReadHe:

; 2566 : 			sfdat->fmt.Format.nSamplesPerSec = (DWORD)(ieee_80_to_double(ieee));

  0055c	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR ieee$[rsp]
  00564	e8 00 00 00 00	 call	 ieee_80_to_double
  00569	f2 48 0f 2c c0	 cvttsd2si rax, xmm0
  0056e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00576	89 41 54	 mov	 DWORD PTR [rcx+84], eax

; 2567 : 			/*we have to deduce blockalign, and hence containersize*/
; 2568 : 			/* no support for strange wordsizes such as 20 in 24 */
; 2569 : 			switch(sfdat->fmt.Format.wBitsPerSample){

  00579	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00581	0f b7 40 5e	 movzx	 eax, WORD PTR [rax+94]
  00585	89 44 24 5c	 mov	 DWORD PTR tv289[rsp], eax
  00589	83 7c 24 5c 10	 cmp	 DWORD PTR tv289[rsp], 16
  0058e	74 54		 je	 SHORT $LN43@aifcReadHe
  00590	83 7c 24 5c 18	 cmp	 DWORD PTR tv289[rsp], 24
  00595	74 2b		 je	 SHORT $LN42@aifcReadHe
  00597	83 7c 24 5c 20	 cmp	 DWORD PTR tv289[rsp], 32 ; 00000020H
  0059c	74 02		 je	 SHORT $LN41@aifcReadHe
  0059e	eb 66		 jmp	 SHORT $LN44@aifcReadHe
$LN41@aifcReadHe:

; 2570 : 			case(32):
; 2571 : 				sfdat->fmt.Format.nBlockAlign = sizeof(DWORD);

  005a0	b8 04 00 00 00	 mov	 eax, 4
  005a5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  005ad	66 89 41 5c	 mov	 WORD PTR [rcx+92], ax

; 2572 : 				sfdat->samptype = PSF_SAMP_32;

  005b1	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  005b9	c7 40 30 04 00
	00 00		 mov	 DWORD PTR [rax+48], 4

; 2573 : 				break;			

  005c0	eb 4e		 jmp	 SHORT $LN6@aifcReadHe
$LN42@aifcReadHe:

; 2574 : 			case(24):
; 2575 : 				sfdat->fmt.Format.nBlockAlign = 3;

  005c2	b8 03 00 00 00	 mov	 eax, 3
  005c7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  005cf	66 89 41 5c	 mov	 WORD PTR [rcx+92], ax

; 2576 : 				sfdat->samptype = PSF_SAMP_24;

  005d3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  005db	c7 40 30 03 00
	00 00		 mov	 DWORD PTR [rax+48], 3

; 2577 : 				break;

  005e2	eb 2c		 jmp	 SHORT $LN6@aifcReadHe
$LN43@aifcReadHe:

; 2578 : 			case(16):
; 2579 : 				sfdat->fmt.Format.nBlockAlign = sizeof(short);

  005e4	b8 02 00 00 00	 mov	 eax, 2
  005e9	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  005f1	66 89 41 5c	 mov	 WORD PTR [rcx+92], ax

; 2580 : 				sfdat->samptype = PSF_SAMP_16;

  005f5	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  005fd	c7 40 30 02 00
	00 00		 mov	 DWORD PTR [rax+48], 2

; 2581 : 				break;			

  00604	eb 0a		 jmp	 SHORT $LN6@aifcReadHe
$LN44@aifcReadHe:

; 2582 : 			default:
; 2583 : 				DBGFPRINTF((stderr, "unsupported sample format for AIFC file\n"));
; 2584 : 				return PSF_E_UNSUPPORTED;

  00606	b8 f8 ff ff ff	 mov	 eax, -8
  0060b	e9 77 07 00 00	 jmp	 $LN1@aifcReadHe
$LN6@aifcReadHe:

; 2585 : 			}
; 2586 : 			sfdat->fmt.Format.nBlockAlign = (WORD) (sfdat->fmt.Format.nBlockAlign * sfdat->fmt.Format.nChannels);

  00610	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00618	0f b7 40 5c	 movzx	 eax, WORD PTR [rax+92]
  0061c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00624	0f b7 49 52	 movzx	 ecx, WORD PTR [rcx+82]
  00628	0f af c1	 imul	 eax, ecx
  0062b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00633	66 89 41 5c	 mov	 WORD PTR [rcx+92], ax

; 2587 : 			if(wavDoRead(sfdat,(char *)&ID_compression,sizeof(DWORD))){

  00637	41 b8 04 00 00
	00		 mov	 r8d, 4
  0063d	48 8d 54 24 30	 lea	 rdx, QWORD PTR ID_compression$[rsp]
  00642	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0064a	e8 00 00 00 00	 call	 wavDoRead
  0064f	85 c0		 test	 eax, eax
  00651	74 0a		 je	 SHORT $LN45@aifcReadHe

; 2588 : 				return PSF_E_CANT_READ;	

  00653	b8 fc ff ff ff	 mov	 eax, -4
  00658	e9 2a 07 00 00	 jmp	 $LN1@aifcReadHe
$LN45@aifcReadHe:

; 2589 : 			}
; 2590 : 			if(sfdat->is_little_endian)

  0065d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00665	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00669	74 3d		 je	 SHORT $LN46@aifcReadHe

; 2591 : 				ID_compression = REVDWBYTES(ID_compression);

  0066b	8b 44 24 30	 mov	 eax, DWORD PTR ID_compression$[rsp]
  0066f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00674	c1 e0 18	 shl	 eax, 24
  00677	8b 4c 24 30	 mov	 ecx, DWORD PTR ID_compression$[rsp]
  0067b	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00681	c1 e1 08	 shl	 ecx, 8
  00684	0b c1		 or	 eax, ecx
  00686	8b 4c 24 30	 mov	 ecx, DWORD PTR ID_compression$[rsp]
  0068a	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00690	c1 e9 08	 shr	 ecx, 8
  00693	0b c1		 or	 eax, ecx
  00695	8b 4c 24 30	 mov	 ecx, DWORD PTR ID_compression$[rsp]
  00699	c1 e9 18	 shr	 ecx, 24
  0069c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  006a2	0b c1		 or	 eax, ecx
  006a4	89 44 24 30	 mov	 DWORD PTR ID_compression$[rsp], eax
$LN46@aifcReadHe:

; 2592 :             /* TODO: recognize any more pcm quasi-compression formats? */    
; 2593 : 			if(!(    (ID_compression == TAG('N','O','N','E'))

  006a8	81 7c 24 30 45
	4e 4f 4e	 cmp	 DWORD PTR ID_compression$[rsp], 1313820229 ; 4e4f4e45H
  006b0	74 28		 je	 SHORT $LN47@aifcReadHe
  006b2	81 7c 24 30 32
	33 4c 46	 cmp	 DWORD PTR ID_compression$[rsp], 1179398962 ; 464c3332H
  006ba	74 1e		 je	 SHORT $LN47@aifcReadHe
  006bc	81 7c 24 30 32
	33 6c 66	 cmp	 DWORD PTR ID_compression$[rsp], 1718367026 ; 666c3332H
  006c4	74 14		 je	 SHORT $LN47@aifcReadHe
  006c6	81 7c 24 30 34
	32 6e 69	 cmp	 DWORD PTR ID_compression$[rsp], 1768829492 ; 696e3234H
  006ce	74 0a		 je	 SHORT $LN47@aifcReadHe

; 2594 : 				  || (ID_compression == TAG('F','L','3','2'))	
; 2595 : 				  || (ID_compression == TAG('f','l','3','2'))
; 2596 :                   || (ID_compression == TAG('i','n','2','4')))	
; 2597 : 						  ){
; 2598 : 				DBGFPRINTF((stderr, "AIFC file: unsupported compression format\n"));
; 2599 : 				return PSF_E_UNSUPPORTED;

  006d0	b8 f8 ff ff ff	 mov	 eax, -8
  006d5	e9 ad 06 00 00	 jmp	 $LN1@aifcReadHe
$LN47@aifcReadHe:

; 2600 : 			}
; 2601 : 			/*set stype info */
; 2602 : 			if((ID_compression== TAG('F','L','3','2'))		  
; 2603 : 				|| ID_compression == TAG('f','l','3','2')){

  006da	81 7c 24 30 32
	33 4c 46	 cmp	 DWORD PTR ID_compression$[rsp], 1179398962 ; 464c3332H
  006e2	74 0a		 je	 SHORT $LN49@aifcReadHe
  006e4	81 7c 24 30 32
	33 6c 66	 cmp	 DWORD PTR ID_compression$[rsp], 1718367026 ; 666c3332H
  006ec	75 3d		 jne	 SHORT $LN48@aifcReadHe
$LN49@aifcReadHe:

; 2604 : 					if(sfdat->fmt.Format.wBitsPerSample != 32){						

  006ee	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  006f6	0f b7 40 5e	 movzx	 eax, WORD PTR [rax+94]
  006fa	83 f8 20	 cmp	 eax, 32			; 00000020H
  006fd	74 0c		 je	 SHORT $LN50@aifcReadHe

; 2605 : 						DBGFPRINTF((stderr, "AIFC file: samples not 32bit in floats file\n"));
; 2606 : 						return PSF_E_BAD_FORMAT;

  006ff	b8 f9 ff ff ff	 mov	 eax, -7
  00704	e9 7e 06 00 00	 jmp	 $LN1@aifcReadHe

; 2607 : 					}

  00709	eb 20		 jmp	 SHORT $LN51@aifcReadHe
$LN50@aifcReadHe:

; 2608 : 					else {
; 2609 : 						sfdat->fmt.Format.wFormatTag = WAVE_FORMAT_IEEE_FLOAT;			

  0070b	b8 03 00 00 00	 mov	 eax, 3
  00710	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00718	66 89 41 50	 mov	 WORD PTR [rcx+80], ax

; 2610 : 						sfdat->samptype = PSF_SAMP_IEEE_FLOAT;

  0071c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00724	c7 40 30 05 00
	00 00		 mov	 DWORD PTR [rax+48], 5
$LN51@aifcReadHe:
$LN48@aifcReadHe:

; 2611 : 					}
; 2612 : 			}
; 2613 : 			/* yes, lazy! skip past pascal string*/
; 2614 : 			if(fseek(sfdat->file,((size-22)+1)&~1,SEEK_CUR))	/*written for documentation, not terseness!*/

  0072b	8b 44 24 2c	 mov	 eax, DWORD PTR size$[rsp]
  0072f	83 e8 15	 sub	 eax, 21
  00732	83 e0 fe	 and	 eax, -2			; fffffffeH
  00735	41 b8 01 00 00
	00		 mov	 r8d, 1
  0073b	8b d0		 mov	 edx, eax
  0073d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00745	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00748	e8 00 00 00 00	 call	 fseek
  0074d	85 c0		 test	 eax, eax
  0074f	74 0a		 je	 SHORT $LN52@aifcReadHe

; 2615 : 				return PSF_E_CANT_SEEK;

  00751	b8 f5 ff ff ff	 mov	 eax, -11
  00756	e9 2c 06 00 00	 jmp	 $LN1@aifcReadHe
$LN52@aifcReadHe:

; 2616 : 			remain -= (size+1)&~1;

  0075b	8b 44 24 2c	 mov	 eax, DWORD PTR size$[rsp]
  0075f	ff c0		 inc	 eax
  00761	83 e0 fe	 and	 eax, -2			; fffffffeH
  00764	8b 4c 24 24	 mov	 ecx, DWORD PTR remain$[rsp]
  00768	2b c8		 sub	 ecx, eax
  0076a	8b c1		 mov	 eax, ecx
  0076c	89 44 24 24	 mov	 DWORD PTR remain$[rsp], eax

; 2617 : 			have_comm = 1;

  00770	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR have_comm$[rsp], 1

; 2618 : 			break;

  00778	e9 a6 04 00 00	 jmp	 $LN4@aifcReadHe
$LN53@aifcReadHe:

; 2619 : 		case (TAG('P','E','A','K')):
; 2620 : 			if(!have_comm){

  0077d	83 7c 24 60 00	 cmp	 DWORD PTR have_comm$[rsp], 0
  00782	75 0a		 jne	 SHORT $LN54@aifcReadHe

; 2621 : 				DBGFPRINTF((stderr, "\nAIFC file: found PEAK chunk before COMM chunk!\n"));
; 2622 : 				return PSF_E_BAD_FORMAT;

  00784	b8 f9 ff ff ff	 mov	 eax, -7
  00789	e9 f9 05 00 00	 jmp	 $LN1@aifcReadHe
$LN54@aifcReadHe:

; 2623 : 			}
; 2624 : 			if(size != (2 * sizeof(DWORD) + sizeof(PSF_CHPEAK) * sfdat->fmt.Format.nChannels)){

  0078e	8b 44 24 2c	 mov	 eax, DWORD PTR size$[rsp]
  00792	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0079a	0f b7 49 52	 movzx	 ecx, WORD PTR [rcx+82]
  0079e	48 8d 0c cd 08
	00 00 00	 lea	 rcx, QWORD PTR [rcx*8+8]
  007a6	48 3b c1	 cmp	 rax, rcx
  007a9	74 0a		 je	 SHORT $LN55@aifcReadHe

; 2625 : 				DBGFPRINTF((stderr, "\nBad size for PEAK chunk\n"));
; 2626 : 				return PSF_E_BAD_FORMAT;

  007ab	b8 f9 ff ff ff	 mov	 eax, -7
  007b0	e9 d2 05 00 00	 jmp	 $LN1@aifcReadHe
$LN55@aifcReadHe:

; 2627 : 			}
; 2628 : 			if(wavDoRead(sfdat,(char *)&version,sizeof(DWORD)))

  007b5	41 b8 04 00 00
	00		 mov	 r8d, 4
  007bb	48 8d 54 24 40	 lea	 rdx, QWORD PTR version$[rsp]
  007c0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  007c8	e8 00 00 00 00	 call	 wavDoRead
  007cd	85 c0		 test	 eax, eax
  007cf	74 0a		 je	 SHORT $LN56@aifcReadHe

; 2629 : 				return PSF_E_CANT_READ;

  007d1	b8 fc ff ff ff	 mov	 eax, -4
  007d6	e9 ac 05 00 00	 jmp	 $LN1@aifcReadHe
$LN56@aifcReadHe:

; 2630 :             if(sfdat->is_little_endian)				

  007db	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  007e3	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  007e7	74 3d		 je	 SHORT $LN57@aifcReadHe

; 2631 : 				version  = REVDWBYTES(version);	

  007e9	8b 44 24 40	 mov	 eax, DWORD PTR version$[rsp]
  007ed	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  007f2	c1 e0 18	 shl	 eax, 24
  007f5	8b 4c 24 40	 mov	 ecx, DWORD PTR version$[rsp]
  007f9	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  007ff	c1 e1 08	 shl	 ecx, 8
  00802	0b c1		 or	 eax, ecx
  00804	8b 4c 24 40	 mov	 ecx, DWORD PTR version$[rsp]
  00808	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  0080e	c1 e9 08	 shr	 ecx, 8
  00811	0b c1		 or	 eax, ecx
  00813	8b 4c 24 40	 mov	 ecx, DWORD PTR version$[rsp]
  00817	c1 e9 18	 shr	 ecx, 24
  0081a	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00820	0b c1		 or	 eax, ecx
  00822	89 44 24 40	 mov	 DWORD PTR version$[rsp], eax
$LN57@aifcReadHe:

; 2632 :             if(version != 1) {

  00826	83 7c 24 40 01	 cmp	 DWORD PTR version$[rsp], 1
  0082b	74 0a		 je	 SHORT $LN58@aifcReadHe

; 2633 : 				DBGFPRINTF((stderr, "Unexpected version level for PEAK chunk!\n"));
; 2634 : 				return PSF_E_UNSUPPORTED;

  0082d	b8 f8 ff ff ff	 mov	 eax, -8
  00832	e9 50 05 00 00	 jmp	 $LN1@aifcReadHe
$LN58@aifcReadHe:

; 2635 : 			}
; 2636 : 			if(fgetpos(sfdat->file,&bytepos))

  00837	48 8d 54 24 78	 lea	 rdx, QWORD PTR bytepos$[rsp]
  0083c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00844	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00847	e8 00 00 00 00	 call	 fgetpos
  0084c	85 c0		 test	 eax, eax
  0084e	74 0a		 je	 SHORT $LN59@aifcReadHe

; 2637 : 			    return PSF_E_CANT_SEEK;

  00850	b8 f5 ff ff ff	 mov	 eax, -11
  00855	e9 2d 05 00 00	 jmp	 $LN1@aifcReadHe
$LN59@aifcReadHe:

; 2638 : 			sfdat->peakoffset = bytepos;

  0085a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00862	48 8b 4c 24 78	 mov	 rcx, QWORD PTR bytepos$[rsp]
  00867	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 2639 :             if(wavDoRead(sfdat,(char *) &peaktime,sizeof(DWORD))){

  0086b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00871	48 8d 54 24 44	 lea	 rdx, QWORD PTR peaktime$[rsp]
  00876	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0087e	e8 00 00 00 00	 call	 wavDoRead
  00883	85 c0		 test	 eax, eax
  00885	74 0a		 je	 SHORT $LN60@aifcReadHe

; 2640 :                 DBGFPRINTF((stderr,"Error reading PEAK time\n"));
; 2641 : 				return PSF_E_CANT_READ;

  00887	b8 fc ff ff ff	 mov	 eax, -4
  0088c	e9 f6 04 00 00	 jmp	 $LN1@aifcReadHe
$LN60@aifcReadHe:

; 2642 :             }
; 2643 : 			if(sfdat->is_little_endian)							

  00891	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00899	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0089d	74 3d		 je	 SHORT $LN61@aifcReadHe

; 2644 : 				peaktime = REVDWBYTES(peaktime);			

  0089f	8b 44 24 44	 mov	 eax, DWORD PTR peaktime$[rsp]
  008a3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  008a8	c1 e0 18	 shl	 eax, 24
  008ab	8b 4c 24 44	 mov	 ecx, DWORD PTR peaktime$[rsp]
  008af	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  008b5	c1 e1 08	 shl	 ecx, 8
  008b8	0b c1		 or	 eax, ecx
  008ba	8b 4c 24 44	 mov	 ecx, DWORD PTR peaktime$[rsp]
  008be	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  008c4	c1 e9 08	 shr	 ecx, 8
  008c7	0b c1		 or	 eax, ecx
  008c9	8b 4c 24 44	 mov	 ecx, DWORD PTR peaktime$[rsp]
  008cd	c1 e9 18	 shr	 ecx, 24
  008d0	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  008d6	0b c1		 or	 eax, ecx
  008d8	89 44 24 44	 mov	 DWORD PTR peaktime$[rsp], eax
$LN61@aifcReadHe:

; 2645 : 			sfdat->peaktime = (time_t) peaktime;			

  008dc	8b 44 24 44	 mov	 eax, DWORD PTR peaktime$[rsp]
  008e0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  008e8	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 2646 : 			sfdat->pPeaks = (PSF_CHPEAK *)malloc(sizeof(PSF_CHPEAK) * sfdat->fmt.Format.nChannels);

  008ef	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  008f7	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  008fb	48 c1 e0 03	 shl	 rax, 3
  008ff	48 8b c8	 mov	 rcx, rax
  00902	e8 00 00 00 00	 call	 malloc
  00907	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0090f	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 2647 :             if(sfdat->pPeaks==NULL) {

  00916	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0091e	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00926	75 0a		 jne	 SHORT $LN62@aifcReadHe

; 2648 :                 DBGFPRINTF((stderr, "wavOpenWrite: no memory for peak data\n"));
; 2649 : 				return PSF_E_NOMEM;

  00928	b8 f7 ff ff ff	 mov	 eax, -9
  0092d	e9 55 04 00 00	 jmp	 $LN1@aifcReadHe
$LN62@aifcReadHe:

; 2650 :             }
; 2651 :             if(wavDoRead(sfdat,(char *)(sfdat->pPeaks),sizeof(PSF_CHPEAK) * sfdat->fmt.Format.nChannels)) {

  00932	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0093a	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  0093e	48 c1 e0 03	 shl	 rax, 3
  00942	44 8b c0	 mov	 r8d, eax
  00945	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0094d	48 8b 90 80 00
	00 00		 mov	 rdx, QWORD PTR [rax+128]
  00954	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0095c	e8 00 00 00 00	 call	 wavDoRead
  00961	85 c0		 test	 eax, eax
  00963	74 0a		 je	 SHORT $LN63@aifcReadHe

; 2652 :                 DBGFPRINTF((stderr,"Error reading PEAK peak data\n"));
; 2653 : 				return PSF_E_CANT_READ;

  00965	b8 fc ff ff ff	 mov	 eax, -4
  0096a	e9 18 04 00 00	 jmp	 $LN1@aifcReadHe
$LN63@aifcReadHe:

; 2654 :             }
; 2655 : 			if(sfdat->is_little_endian){

  0096f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00977	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0097b	0f 84 ab 00 00
	00		 je	 $LN64@aifcReadHe

; 2656 : 				DWORD *pBlock;
; 2657 : 				int i;
; 2658 : 				pBlock = (DWORD *) (sfdat->pPeaks);

  00981	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00989	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00990	48 89 44 24 70	 mov	 QWORD PTR pBlock$4[rsp], rax

; 2659 : 				for(i=0;i < sfdat->fmt.Format.nChannels * 2; i++)

  00995	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  0099d	eb 0a		 jmp	 SHORT $LN10@aifcReadHe
$LN8@aifcReadHe:
  0099f	8b 44 24 34	 mov	 eax, DWORD PTR i$1[rsp]
  009a3	ff c0		 inc	 eax
  009a5	89 44 24 34	 mov	 DWORD PTR i$1[rsp], eax
$LN10@aifcReadHe:
  009a9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  009b1	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  009b5	d1 e0		 shl	 eax, 1
  009b7	39 44 24 34	 cmp	 DWORD PTR i$1[rsp], eax
  009bb	7d 6f		 jge	 SHORT $LN9@aifcReadHe

; 2660 : 					pBlock[i] = REVDWBYTES(pBlock[i]); 

  009bd	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$1[rsp]
  009c2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pBlock$4[rsp]
  009c7	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  009ca	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  009cf	c1 e0 18	 shl	 eax, 24
  009d2	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR i$1[rsp]
  009d7	48 8b 54 24 70	 mov	 rdx, QWORD PTR pBlock$4[rsp]
  009dc	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  009df	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  009e5	c1 e1 08	 shl	 ecx, 8
  009e8	0b c1		 or	 eax, ecx
  009ea	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR i$1[rsp]
  009ef	48 8b 54 24 70	 mov	 rdx, QWORD PTR pBlock$4[rsp]
  009f4	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  009f7	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  009fd	c1 e9 08	 shr	 ecx, 8
  00a00	0b c1		 or	 eax, ecx
  00a02	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00a07	48 8b 54 24 70	 mov	 rdx, QWORD PTR pBlock$4[rsp]
  00a0c	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  00a0f	c1 e9 18	 shr	 ecx, 24
  00a12	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00a18	0b c1		 or	 eax, ecx
  00a1a	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00a1f	48 8b 54 24 70	 mov	 rdx, QWORD PTR pBlock$4[rsp]
  00a24	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  00a27	e9 73 ff ff ff	 jmp	 $LN8@aifcReadHe
$LN9@aifcReadHe:
$LN64@aifcReadHe:

; 2661 : 			}			
; 2662 : 			remain -= (size+1)&~1;

  00a2c	8b 44 24 2c	 mov	 eax, DWORD PTR size$[rsp]
  00a30	ff c0		 inc	 eax
  00a32	83 e0 fe	 and	 eax, -2			; fffffffeH
  00a35	8b 4c 24 24	 mov	 ecx, DWORD PTR remain$[rsp]
  00a39	2b c8		 sub	 ecx, eax
  00a3b	8b c1		 mov	 eax, ecx
  00a3d	89 44 24 24	 mov	 DWORD PTR remain$[rsp], eax

; 2663 : 			break;

  00a41	e9 dd 01 00 00	 jmp	 $LN4@aifcReadHe
$LN65@aifcReadHe:

; 2664 : 		case(TAG('S','S','N','D')):
; 2665 : 			if(wavDoRead(sfdat,(char *)&offset,sizeof(DWORD))
; 2666 : 					|| wavDoRead(sfdat,(char *) &blocksize,sizeof(DWORD)))

  00a46	41 b8 04 00 00
	00		 mov	 r8d, 4
  00a4c	48 8d 54 24 48	 lea	 rdx, QWORD PTR offset$[rsp]
  00a51	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00a59	e8 00 00 00 00	 call	 wavDoRead
  00a5e	85 c0		 test	 eax, eax
  00a60	75 1c		 jne	 SHORT $LN67@aifcReadHe
  00a62	41 b8 04 00 00
	00		 mov	 r8d, 4
  00a68	48 8d 54 24 50	 lea	 rdx, QWORD PTR blocksize$[rsp]
  00a6d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00a75	e8 00 00 00 00	 call	 wavDoRead
  00a7a	85 c0		 test	 eax, eax
  00a7c	74 0a		 je	 SHORT $LN66@aifcReadHe
$LN67@aifcReadHe:

; 2667 : 			return PSF_E_CANT_READ;

  00a7e	b8 fc ff ff ff	 mov	 eax, -4
  00a83	e9 ff 02 00 00	 jmp	 $LN1@aifcReadHe
$LN66@aifcReadHe:

; 2668 : 			if(sfdat->is_little_endian){				

  00a88	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00a90	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00a94	74 7a		 je	 SHORT $LN68@aifcReadHe

; 2669 : 				offset  = REVDWBYTES(offset);

  00a96	8b 44 24 48	 mov	 eax, DWORD PTR offset$[rsp]
  00a9a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00a9f	c1 e0 18	 shl	 eax, 24
  00aa2	8b 4c 24 48	 mov	 ecx, DWORD PTR offset$[rsp]
  00aa6	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00aac	c1 e1 08	 shl	 ecx, 8
  00aaf	0b c1		 or	 eax, ecx
  00ab1	8b 4c 24 48	 mov	 ecx, DWORD PTR offset$[rsp]
  00ab5	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00abb	c1 e9 08	 shr	 ecx, 8
  00abe	0b c1		 or	 eax, ecx
  00ac0	8b 4c 24 48	 mov	 ecx, DWORD PTR offset$[rsp]
  00ac4	c1 e9 18	 shr	 ecx, 24
  00ac7	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00acd	0b c1		 or	 eax, ecx
  00acf	89 44 24 48	 mov	 DWORD PTR offset$[rsp], eax

; 2670 : 				blocksize = REVDWBYTES(blocksize);

  00ad3	8b 44 24 50	 mov	 eax, DWORD PTR blocksize$[rsp]
  00ad7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00adc	c1 e0 18	 shl	 eax, 24
  00adf	8b 4c 24 50	 mov	 ecx, DWORD PTR blocksize$[rsp]
  00ae3	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00ae9	c1 e1 08	 shl	 ecx, 8
  00aec	0b c1		 or	 eax, ecx
  00aee	8b 4c 24 50	 mov	 ecx, DWORD PTR blocksize$[rsp]
  00af2	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00af8	c1 e9 08	 shr	 ecx, 8
  00afb	0b c1		 or	 eax, ecx
  00afd	8b 4c 24 50	 mov	 ecx, DWORD PTR blocksize$[rsp]
  00b01	c1 e9 18	 shr	 ecx, 24
  00b04	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00b0a	0b c1		 or	 eax, ecx
  00b0c	89 44 24 50	 mov	 DWORD PTR blocksize$[rsp], eax
$LN68@aifcReadHe:

; 2671 : 			}
; 2672 : 			if(fgetpos(sfdat->file,&bytepos))

  00b10	48 8d 54 24 78	 lea	 rdx, QWORD PTR bytepos$[rsp]
  00b15	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00b1d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00b20	e8 00 00 00 00	 call	 fgetpos
  00b25	85 c0		 test	 eax, eax
  00b27	74 0a		 je	 SHORT $LN69@aifcReadHe

; 2673 : 			    return PSF_E_CANT_SEEK;

  00b29	b8 f5 ff ff ff	 mov	 eax, -11
  00b2e	e9 54 02 00 00	 jmp	 $LN1@aifcReadHe
$LN69@aifcReadHe:

; 2674 : 			sfdat->dataoffset = bytepos;

  00b33	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00b3b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR bytepos$[rsp]
  00b40	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 2675 : 			POS64(sfdat->dataoffset) += offset;

  00b44	8b 44 24 48	 mov	 eax, DWORD PTR offset$[rsp]
  00b48	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00b50	48 03 41 38	 add	 rax, QWORD PTR [rcx+56]
  00b54	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00b5c	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 2676 : 			sfdat->nFrames = (size - 2* sizeof(DWORD))/ sfdat->fmt.Format.nBlockAlign;			

  00b60	8b 44 24 2c	 mov	 eax, DWORD PTR size$[rsp]
  00b64	48 83 e8 08	 sub	 rax, 8
  00b68	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00b70	0f b7 49 5c	 movzx	 ecx, WORD PTR [rcx+92]
  00b74	33 d2		 xor	 edx, edx
  00b76	48 f7 f1	 div	 rcx
  00b79	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00b81	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 2677 : 			if(fseek(sfdat->file,((size - 2* sizeof(DWORD))+1)&~1,SEEK_CUR))

  00b84	8b 44 24 2c	 mov	 eax, DWORD PTR size$[rsp]
  00b88	48 83 e8 07	 sub	 rax, 7
  00b8c	48 83 e0 fe	 and	 rax, -2
  00b90	41 b8 01 00 00
	00		 mov	 r8d, 1
  00b96	8b d0		 mov	 edx, eax
  00b98	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00ba0	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00ba3	e8 00 00 00 00	 call	 fseek
  00ba8	85 c0		 test	 eax, eax
  00baa	74 0a		 je	 SHORT $LN70@aifcReadHe

; 2678 : 				return PSF_E_CANT_SEEK;

  00bac	b8 f5 ff ff ff	 mov	 eax, -11
  00bb1	e9 d1 01 00 00	 jmp	 $LN1@aifcReadHe
$LN70@aifcReadHe:

; 2679 : 			have_ssnd = 1;

  00bb6	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR have_ssnd$[rsp], 1

; 2680 : 			remain -= (size+1)&~1;

  00bbe	8b 44 24 2c	 mov	 eax, DWORD PTR size$[rsp]
  00bc2	ff c0		 inc	 eax
  00bc4	83 e0 fe	 and	 eax, -2			; fffffffeH
  00bc7	8b 4c 24 24	 mov	 ecx, DWORD PTR remain$[rsp]
  00bcb	2b c8		 sub	 ecx, eax
  00bcd	8b c1		 mov	 eax, ecx
  00bcf	89 44 24 24	 mov	 DWORD PTR remain$[rsp], eax

; 2681 : 			break;

  00bd3	eb 4e		 jmp	 SHORT $LN4@aifcReadHe
$LN71@aifcReadHe:

; 2682 : 		/* HARSH! as above */
; 2683 : 		case(0):
; 2684 : 			DBGFPRINTF((stderr, "AIFC file has bad main chunksize\n"));
; 2685 : 			return PSF_E_BAD_FORMAT;

  00bd5	b8 f9 ff ff ff	 mov	 eax, -7
  00bda	e9 a8 01 00 00	 jmp	 $LN1@aifcReadHe
$LN72@aifcReadHe:

; 2686 : 		default:
; 2687 : 			/* skip all unknown chunks */
; 2688 : 			if(fseek(sfdat->file,(size+1)&~1,SEEK_CUR))

  00bdf	8b 44 24 2c	 mov	 eax, DWORD PTR size$[rsp]
  00be3	ff c0		 inc	 eax
  00be5	83 e0 fe	 and	 eax, -2			; fffffffeH
  00be8	41 b8 01 00 00
	00		 mov	 r8d, 1
  00bee	8b d0		 mov	 edx, eax
  00bf0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00bf8	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00bfb	e8 00 00 00 00	 call	 fseek
  00c00	85 c0		 test	 eax, eax
  00c02	74 0a		 je	 SHORT $LN73@aifcReadHe

; 2689 : 				return PSF_E_CANT_SEEK;

  00c04	b8 f5 ff ff ff	 mov	 eax, -11
  00c09	e9 79 01 00 00	 jmp	 $LN1@aifcReadHe
$LN73@aifcReadHe:

; 2690 : 			remain -= (size+1)&~1;

  00c0e	8b 44 24 2c	 mov	 eax, DWORD PTR size$[rsp]
  00c12	ff c0		 inc	 eax
  00c14	83 e0 fe	 and	 eax, -2			; fffffffeH
  00c17	8b 4c 24 24	 mov	 ecx, DWORD PTR remain$[rsp]
  00c1b	2b c8		 sub	 ecx, eax
  00c1d	8b c1		 mov	 eax, ecx
  00c1f	89 44 24 24	 mov	 DWORD PTR remain$[rsp], eax
$LN4@aifcReadHe:

; 2691 : 			break;
; 2692 : 		}
; 2693 : 	}

  00c23	e9 a0 f5 ff ff	 jmp	 $LN2@aifcReadHe
$LN3@aifcReadHe:

; 2694 : 	if(!(have_ssnd && have_comm && have_fver)){

  00c28	83 7c 24 64 00	 cmp	 DWORD PTR have_ssnd$[rsp], 0
  00c2d	74 0e		 je	 SHORT $LN75@aifcReadHe
  00c2f	83 7c 24 60 00	 cmp	 DWORD PTR have_comm$[rsp], 0
  00c34	74 07		 je	 SHORT $LN75@aifcReadHe
  00c36	83 7c 24 68 00	 cmp	 DWORD PTR have_fver$[rsp], 0
  00c3b	75 0a		 jne	 SHORT $LN74@aifcReadHe
$LN75@aifcReadHe:

; 2695 : 		DBGFPRINTF((stderr, "AIFC file has bad format\n"));
; 2696 : 		return PSF_E_BAD_FORMAT;

  00c3d	b8 f9 ff ff ff	 mov	 eax, -7
  00c42	e9 40 01 00 00	 jmp	 $LN1@aifcReadHe
$LN74@aifcReadHe:

; 2697 : 	}
; 2698 : 	/* we have seeked (ugh) to EOF, so rewind to start of data */
; 2699 : 	if(fsetpos(sfdat->file,&sfdat->dataoffset))

  00c47	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00c4f	48 83 c0 38	 add	 rax, 56			; 00000038H
  00c53	48 8b d0	 mov	 rdx, rax
  00c56	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00c5e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00c61	e8 00 00 00 00	 call	 fsetpos
  00c66	85 c0		 test	 eax, eax
  00c68	74 0a		 je	 SHORT $LN76@aifcReadHe

; 2700 : 		return PSF_E_CANT_SEEK;			

  00c6a	b8 f5 ff ff ff	 mov	 eax, -11
  00c6f	e9 13 01 00 00	 jmp	 $LN1@aifcReadHe
$LN76@aifcReadHe:

; 2701 : 	sfdat->curframepos = 0;	

  00c74	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00c7c	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 2702 : 	sfdat->riff_format = PSF_AIFC;

  00c83	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00c8b	c7 40 28 04 00
	00 00		 mov	 DWORD PTR [rax+40], 4

; 2703 : 	/* get rescale factor if available */
; 2704 : 	/* NB in correct format, val is always >= 0.0 */
; 2705 : 	if(sfdat->pPeaks &&  POS64(sfdat->peakoffset) != 0){

  00c92	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00c9a	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00ca2	0f 84 cb 00 00
	00		 je	 $LN77@aifcReadHe
  00ca8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00cb0	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  00cb5	0f 84 b8 00 00
	00		 je	 $LN77@aifcReadHe

; 2706 : 		float fac = 0.0f;

  00cbb	0f 57 c0	 xorps	 xmm0, xmm0
  00cbe	f3 0f 11 44 24
	58		 movss	 DWORD PTR fac$3[rsp], xmm0

; 2707 : 		int i;
; 2708 : 		for(i=0;i < sfdat->fmt.Format.nChannels; i++)

  00cc4	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  00ccc	eb 0a		 jmp	 SHORT $LN13@aifcReadHe
$LN11@aifcReadHe:
  00cce	8b 44 24 54	 mov	 eax, DWORD PTR i$2[rsp]
  00cd2	ff c0		 inc	 eax
  00cd4	89 44 24 54	 mov	 DWORD PTR i$2[rsp], eax
$LN13@aifcReadHe:
  00cd8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00ce0	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  00ce4	39 44 24 54	 cmp	 DWORD PTR i$2[rsp], eax
  00ce8	7d 5f		 jge	 SHORT $LN12@aifcReadHe

; 2709 : 			fac = max(fac,sfdat->pPeaks[i].val);

  00cea	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$2[rsp]
  00cef	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00cf7	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00cfe	f3 0f 10 04 c1	 movss	 xmm0, DWORD PTR [rcx+rax*8]
  00d03	f3 0f 10 4c 24
	58		 movss	 xmm1, DWORD PTR fac$3[rsp]
  00d09	0f 2f c8	 comiss	 xmm1, xmm0
  00d0c	76 0e		 jbe	 SHORT $LN80@aifcReadHe
  00d0e	f3 0f 10 44 24
	58		 movss	 xmm0, DWORD PTR fac$3[rsp]
  00d14	f3 0f 11 44 24
	6c		 movss	 DWORD PTR tv570[rsp], xmm0
  00d1a	eb 1f		 jmp	 SHORT $LN81@aifcReadHe
$LN80@aifcReadHe:
  00d1c	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$2[rsp]
  00d21	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00d29	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00d30	f3 0f 10 04 c1	 movss	 xmm0, DWORD PTR [rcx+rax*8]
  00d35	f3 0f 11 44 24
	6c		 movss	 DWORD PTR tv570[rsp], xmm0
$LN81@aifcReadHe:
  00d3b	f3 0f 10 44 24
	6c		 movss	 xmm0, DWORD PTR tv570[rsp]
  00d41	f3 0f 11 44 24
	58		 movss	 DWORD PTR fac$3[rsp], xmm0
  00d47	eb 85		 jmp	 SHORT $LN11@aifcReadHe
$LN12@aifcReadHe:

; 2710 : 		if(fac > 1.0f)

  00d49	f3 0f 10 44 24
	58		 movss	 xmm0, DWORD PTR fac$3[rsp]
  00d4f	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00d56	76 1b		 jbe	 SHORT $LN78@aifcReadHe

; 2711 : 			sfdat->rescale_fac = 1.0f / fac;

  00d58	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00d60	f3 0f 5e 44 24
	58		 divss	 xmm0, DWORD PTR fac$3[rsp]
  00d66	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00d6e	f3 0f 11 40 24	 movss	 DWORD PTR [rax+36], xmm0
$LN78@aifcReadHe:
$LN77@aifcReadHe:

; 2712 : 	}
; 2713 : 	sfdat->lastop  = PSF_OP_READ;

  00d73	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00d7b	c7 80 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+152], 0

; 2714 : 	return PSF_E_NOERROR;

  00d85	33 c0		 xor	 eax, eax
$LN1@aifcReadHe:

; 2715 : }

  00d87	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00d8f	48 33 cc	 xor	 rcx, rsp
  00d92	e8 00 00 00 00	 call	 __security_check_cookie
  00d97	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00d9e	c3		 ret	 0
aifcReadHeader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
tag$ = 32
wData$ = 36
remain$ = 40
size$ = 44
i$1 = 48
dwData$ = 52
version$ = 56
peaktime$ = 60
offset$ = 64
blocksize$ = 68
i$2 = 72
fac$3 = 76
tv192 = 80
tv263 = 84
have_comm$ = 88
have_ssnd$ = 92
tv500 = 96
pBlock$4 = 104
bytepos$ = 112
ieee$ = 120
__$ArrayPad$ = 136
sfdat$ = 160
aiffReadHeader PROC

; 2288 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2289 : 	DWORD tag,version,peaktime,remain,offset,blocksize;
; 2290 : 	int have_comm =0,have_ssnd =0;	

  0001e	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR have_comm$[rsp], 0
  00026	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR have_ssnd$[rsp], 0

; 2291 : 	DWORD dwData,size;
; 2292 : 	unsigned char ieee[10];
; 2293 : 	WORD wData;
; 2294 : 	fpos_t bytepos;
; 2295 : 
; 2296 : 	if(sfdat==NULL || sfdat->file == NULL)

  0002e	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR sfdat$[rsp], 0
  00037	74 0e		 je	 SHORT $LN15@aiffReadHe
  00039	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00041	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00045	75 0a		 jne	 SHORT $LN14@aiffReadHe
$LN15@aiffReadHe:

; 2297 : 		return PSF_E_BADARG;

  00047	b8 f6 ff ff ff	 mov	 eax, -10
  0004c	e9 34 0b 00 00	 jmp	 $LN1@aiffReadHe
$LN14@aiffReadHe:

; 2298 : 
; 2299 : 	if(wavDoRead(sfdat,(char *)&tag,sizeof(DWORD))
; 2300 : 		|| wavDoRead(sfdat,(char *) &remain,sizeof(DWORD)))

  00051	41 b8 04 00 00
	00		 mov	 r8d, 4
  00057	48 8d 54 24 20	 lea	 rdx, QWORD PTR tag$[rsp]
  0005c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00064	e8 00 00 00 00	 call	 wavDoRead
  00069	85 c0		 test	 eax, eax
  0006b	75 1c		 jne	 SHORT $LN17@aiffReadHe
  0006d	41 b8 04 00 00
	00		 mov	 r8d, 4
  00073	48 8d 54 24 28	 lea	 rdx, QWORD PTR remain$[rsp]
  00078	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00080	e8 00 00 00 00	 call	 wavDoRead
  00085	85 c0		 test	 eax, eax
  00087	74 0a		 je	 SHORT $LN16@aiffReadHe
$LN17@aiffReadHe:

; 2301 : 		return PSF_E_CANT_READ;

  00089	b8 fc ff ff ff	 mov	 eax, -4
  0008e	e9 f2 0a 00 00	 jmp	 $LN1@aiffReadHe
$LN16@aiffReadHe:

; 2302 : 	if(sfdat->is_little_endian) {

  00093	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0009b	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0009f	74 7a		 je	 SHORT $LN18@aiffReadHe

; 2303 : 		remain = REVDWBYTES(remain);	

  000a1	8b 44 24 28	 mov	 eax, DWORD PTR remain$[rsp]
  000a5	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000aa	c1 e0 18	 shl	 eax, 24
  000ad	8b 4c 24 28	 mov	 ecx, DWORD PTR remain$[rsp]
  000b1	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  000b7	c1 e1 08	 shl	 ecx, 8
  000ba	0b c1		 or	 eax, ecx
  000bc	8b 4c 24 28	 mov	 ecx, DWORD PTR remain$[rsp]
  000c0	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  000c6	c1 e9 08	 shr	 ecx, 8
  000c9	0b c1		 or	 eax, ecx
  000cb	8b 4c 24 28	 mov	 ecx, DWORD PTR remain$[rsp]
  000cf	c1 e9 18	 shr	 ecx, 24
  000d2	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000d8	0b c1		 or	 eax, ecx
  000da	89 44 24 28	 mov	 DWORD PTR remain$[rsp], eax

; 2304 : 		tag = REVDWBYTES(tag);

  000de	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  000e2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000e7	c1 e0 18	 shl	 eax, 24
  000ea	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  000ee	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  000f4	c1 e1 08	 shl	 ecx, 8
  000f7	0b c1		 or	 eax, ecx
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  000fd	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00103	c1 e9 08	 shr	 ecx, 8
  00106	0b c1		 or	 eax, ecx
  00108	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  0010c	c1 e9 18	 shr	 ecx, 24
  0010f	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00115	0b c1		 or	 eax, ecx
  00117	89 44 24 20	 mov	 DWORD PTR tag$[rsp], eax
$LN18@aiffReadHe:

; 2305 : 	}
; 2306 : 	if(tag != TAG('F','O','R','M')){

  0011b	81 7c 24 20 4d
	52 4f 46	 cmp	 DWORD PTR tag$[rsp], 1179603533 ; 464f524dH
  00123	74 0a		 je	 SHORT $LN19@aiffReadHe

; 2307 : 		DBGFPRINTF((stderr, "file is not AIFF: no PSF chunk\n"));
; 2308 : 		return PSF_E_BADARG;

  00125	b8 f6 ff ff ff	 mov	 eax, -10
  0012a	e9 56 0a 00 00	 jmp	 $LN1@aiffReadHe
$LN19@aiffReadHe:

; 2309 : 	}
; 2310 : 		
; 2311 : 	if(wavDoRead(sfdat,(char *)&tag,sizeof(DWORD)))

  0012f	41 b8 04 00 00
	00		 mov	 r8d, 4
  00135	48 8d 54 24 20	 lea	 rdx, QWORD PTR tag$[rsp]
  0013a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00142	e8 00 00 00 00	 call	 wavDoRead
  00147	85 c0		 test	 eax, eax
  00149	74 0a		 je	 SHORT $LN20@aiffReadHe

; 2312 : 		return PSF_E_CANT_READ;

  0014b	b8 fc ff ff ff	 mov	 eax, -4
  00150	e9 30 0a 00 00	 jmp	 $LN1@aiffReadHe
$LN20@aiffReadHe:

; 2313 : 	if(sfdat->is_little_endian)

  00155	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0015d	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00161	74 3d		 je	 SHORT $LN21@aiffReadHe

; 2314 : 		tag = REVDWBYTES(tag);

  00163	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  00167	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0016c	c1 e0 18	 shl	 eax, 24
  0016f	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00173	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00179	c1 e1 08	 shl	 ecx, 8
  0017c	0b c1		 or	 eax, ecx
  0017e	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00182	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00188	c1 e9 08	 shr	 ecx, 8
  0018b	0b c1		 or	 eax, ecx
  0018d	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00191	c1 e9 18	 shr	 ecx, 24
  00194	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0019a	0b c1		 or	 eax, ecx
  0019c	89 44 24 20	 mov	 DWORD PTR tag$[rsp], eax
$LN21@aiffReadHe:

; 2315 : 	if(tag != TAG('A','I','F','F')){

  001a0	81 7c 24 20 46
	46 49 41	 cmp	 DWORD PTR tag$[rsp], 1095321158 ; 41494646H
  001a8	74 0a		 je	 SHORT $LN22@aiffReadHe

; 2316 : 		DBGFPRINTF((stderr, "file is not AIFF: no AIFF chunk\n"));
; 2317 : 		return PSF_E_BADARG;

  001aa	b8 f6 ff ff ff	 mov	 eax, -10
  001af	e9 d1 09 00 00	 jmp	 $LN1@aiffReadHe
$LN22@aiffReadHe:

; 2318 : 	}
; 2319 : 	remain -= sizeof(int);

  001b4	8b 44 24 28	 mov	 eax, DWORD PTR remain$[rsp]
  001b8	48 83 e8 04	 sub	 rax, 4
  001bc	89 44 24 28	 mov	 DWORD PTR remain$[rsp], eax
$LN2@aiffReadHe:

; 2320 : 
; 2321 : 
; 2322 : 	while(remain > 0){

  001c0	83 7c 24 28 00	 cmp	 DWORD PTR remain$[rsp], 0
  001c5	0f 86 62 08 00
	00		 jbe	 $LN3@aiffReadHe

; 2323 : 		if(wavDoRead(sfdat,(char *)&tag,sizeof(DWORD))
; 2324 : 		|| wavDoRead(sfdat,(char *) &size,sizeof(DWORD)))

  001cb	41 b8 04 00 00
	00		 mov	 r8d, 4
  001d1	48 8d 54 24 20	 lea	 rdx, QWORD PTR tag$[rsp]
  001d6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  001de	e8 00 00 00 00	 call	 wavDoRead
  001e3	85 c0		 test	 eax, eax
  001e5	75 1c		 jne	 SHORT $LN24@aiffReadHe
  001e7	41 b8 04 00 00
	00		 mov	 r8d, 4
  001ed	48 8d 54 24 2c	 lea	 rdx, QWORD PTR size$[rsp]
  001f2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  001fa	e8 00 00 00 00	 call	 wavDoRead
  001ff	85 c0		 test	 eax, eax
  00201	74 0a		 je	 SHORT $LN23@aiffReadHe
$LN24@aiffReadHe:

; 2325 : 			return PSF_E_CANT_READ;

  00203	b8 fc ff ff ff	 mov	 eax, -4
  00208	e9 78 09 00 00	 jmp	 $LN1@aiffReadHe
$LN23@aiffReadHe:

; 2326 : 		if(sfdat->is_little_endian) {

  0020d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00215	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00219	74 7a		 je	 SHORT $LN25@aiffReadHe

; 2327 : 			size = REVDWBYTES(size);	

  0021b	8b 44 24 2c	 mov	 eax, DWORD PTR size$[rsp]
  0021f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00224	c1 e0 18	 shl	 eax, 24
  00227	8b 4c 24 2c	 mov	 ecx, DWORD PTR size$[rsp]
  0022b	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00231	c1 e1 08	 shl	 ecx, 8
  00234	0b c1		 or	 eax, ecx
  00236	8b 4c 24 2c	 mov	 ecx, DWORD PTR size$[rsp]
  0023a	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00240	c1 e9 08	 shr	 ecx, 8
  00243	0b c1		 or	 eax, ecx
  00245	8b 4c 24 2c	 mov	 ecx, DWORD PTR size$[rsp]
  00249	c1 e9 18	 shr	 ecx, 24
  0024c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00252	0b c1		 or	 eax, ecx
  00254	89 44 24 2c	 mov	 DWORD PTR size$[rsp], eax

; 2328 : 			tag = REVDWBYTES(tag);

  00258	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  0025c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00261	c1 e0 18	 shl	 eax, 24
  00264	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00268	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  0026e	c1 e1 08	 shl	 ecx, 8
  00271	0b c1		 or	 eax, ecx
  00273	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00277	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  0027d	c1 e9 08	 shr	 ecx, 8
  00280	0b c1		 or	 eax, ecx
  00282	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00286	c1 e9 18	 shr	 ecx, 24
  00289	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0028f	0b c1		 or	 eax, ecx
  00291	89 44 24 20	 mov	 DWORD PTR tag$[rsp], eax
$LN25@aiffReadHe:

; 2329 : 		}
; 2330 : 		remain -=(int)( 2 * sizeof(DWORD));

  00295	8b 44 24 28	 mov	 eax, DWORD PTR remain$[rsp]
  00299	83 e8 08	 sub	 eax, 8
  0029c	89 44 24 28	 mov	 DWORD PTR remain$[rsp], eax

; 2331 : 		switch(tag){

  002a0	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  002a4	89 44 24 50	 mov	 DWORD PTR tv192[rsp], eax
  002a8	83 7c 24 50 00	 cmp	 DWORD PTR tv192[rsp], 0
  002ad	0f 84 27 07 00
	00		 je	 $LN58@aiffReadHe
  002b3	81 7c 24 50 4d
	4d 4f 43	 cmp	 DWORD PTR tv192[rsp], 1129270605 ; 434f4d4dH
  002bb	74 21		 je	 SHORT $LN26@aiffReadHe
  002bd	81 7c 24 50 4b
	41 45 50	 cmp	 DWORD PTR tv192[rsp], 1346715979 ; 5045414bH
  002c5	0f 84 bc 02 00
	00		 je	 $LN40@aiffReadHe
  002cb	81 7c 24 50 44
	4e 53 53	 cmp	 DWORD PTR tv192[rsp], 1397968452 ; 53534e44H
  002d3	0f 84 72 05 00
	00		 je	 $LN52@aiffReadHe
  002d9	e9 06 07 00 00	 jmp	 $LN59@aiffReadHe
$LN26@aiffReadHe:

; 2332 : 		case(TAG('C','O','M','M')):
; 2333 : 			if(size != 18){

  002de	83 7c 24 2c 12	 cmp	 DWORD PTR size$[rsp], 18
  002e3	74 0a		 je	 SHORT $LN27@aiffReadHe

; 2334 : 				DBGFPRINTF((stderr,"AIFF file has bad size for COMM chunk\n")); 
; 2335 : 			    return PSF_E_BAD_FORMAT;

  002e5	b8 f9 ff ff ff	 mov	 eax, -7
  002ea	e9 96 08 00 00	 jmp	 $LN1@aiffReadHe
$LN27@aiffReadHe:

; 2336 : 			}
; 2337 : 			if(fgetpos(sfdat->file,&bytepos))

  002ef	48 8d 54 24 70	 lea	 rdx, QWORD PTR bytepos$[rsp]
  002f4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  002fc	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  002ff	e8 00 00 00 00	 call	 fgetpos
  00304	85 c0		 test	 eax, eax
  00306	74 0a		 je	 SHORT $LN28@aiffReadHe

; 2338 : 			    return PSF_E_CANT_SEEK;

  00308	b8 f5 ff ff ff	 mov	 eax, -11
  0030d	e9 73 08 00 00	 jmp	 $LN1@aiffReadHe
$LN28@aiffReadHe:

; 2339 : 			sfdat->fmtoffset = bytepos;

  00312	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0031a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bytepos$[rsp]
  0031f	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 2340 : 			if(wavDoRead(sfdat,(char *)&wData,sizeof(WORD)))

  00323	41 b8 02 00 00
	00		 mov	 r8d, 2
  00329	48 8d 54 24 24	 lea	 rdx, QWORD PTR wData$[rsp]
  0032e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00336	e8 00 00 00 00	 call	 wavDoRead
  0033b	85 c0		 test	 eax, eax
  0033d	74 0a		 je	 SHORT $LN29@aiffReadHe

; 2341 : 				return PSF_E_CANT_READ;

  0033f	b8 fc ff ff ff	 mov	 eax, -4
  00344	e9 3c 08 00 00	 jmp	 $LN1@aiffReadHe
$LN29@aiffReadHe:

; 2342 : 			if(sfdat->is_little_endian)

  00349	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00351	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00355	74 22		 je	 SHORT $LN30@aiffReadHe

; 2343 : 				wData = (WORD) REVWBYTES(wData);

  00357	0f b7 44 24 24	 movzx	 eax, WORD PTR wData$[rsp]
  0035c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00361	c1 e0 08	 shl	 eax, 8
  00364	0f b7 4c 24 24	 movzx	 ecx, WORD PTR wData$[rsp]
  00369	c1 f9 08	 sar	 ecx, 8
  0036c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00372	0b c1		 or	 eax, ecx
  00374	66 89 44 24 24	 mov	 WORD PTR wData$[rsp], ax
$LN30@aiffReadHe:

; 2344 : 			sfdat->fmt.Format.nChannels = wData;

  00379	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00381	0f b7 4c 24 24	 movzx	 ecx, WORD PTR wData$[rsp]
  00386	66 89 48 52	 mov	 WORD PTR [rax+82], cx

; 2345 : 			if(wavDoRead(sfdat,(char *)&dwData,sizeof(DWORD)))

  0038a	41 b8 04 00 00
	00		 mov	 r8d, 4
  00390	48 8d 54 24 34	 lea	 rdx, QWORD PTR dwData$[rsp]
  00395	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0039d	e8 00 00 00 00	 call	 wavDoRead
  003a2	85 c0		 test	 eax, eax
  003a4	74 0a		 je	 SHORT $LN31@aiffReadHe

; 2346 : 				return PSF_E_CANT_READ;

  003a6	b8 fc ff ff ff	 mov	 eax, -4
  003ab	e9 d5 07 00 00	 jmp	 $LN1@aiffReadHe
$LN31@aiffReadHe:

; 2347 : 			if(sfdat->is_little_endian)

  003b0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  003b8	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  003bc	74 3d		 je	 SHORT $LN32@aiffReadHe

; 2348 : 				dwData = REVDWBYTES(dwData);

  003be	8b 44 24 34	 mov	 eax, DWORD PTR dwData$[rsp]
  003c2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003c7	c1 e0 18	 shl	 eax, 24
  003ca	8b 4c 24 34	 mov	 ecx, DWORD PTR dwData$[rsp]
  003ce	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  003d4	c1 e1 08	 shl	 ecx, 8
  003d7	0b c1		 or	 eax, ecx
  003d9	8b 4c 24 34	 mov	 ecx, DWORD PTR dwData$[rsp]
  003dd	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  003e3	c1 e9 08	 shr	 ecx, 8
  003e6	0b c1		 or	 eax, ecx
  003e8	8b 4c 24 34	 mov	 ecx, DWORD PTR dwData$[rsp]
  003ec	c1 e9 18	 shr	 ecx, 24
  003ef	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  003f5	0b c1		 or	 eax, ecx
  003f7	89 44 24 34	 mov	 DWORD PTR dwData$[rsp], eax
$LN32@aiffReadHe:

; 2349 : 			sfdat->nFrames = dwData;

  003fb	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00403	8b 4c 24 34	 mov	 ecx, DWORD PTR dwData$[rsp]
  00407	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 2350 : 			if(wavDoRead(sfdat,(char *)&wData,sizeof(WORD)))

  0040a	41 b8 02 00 00
	00		 mov	 r8d, 2
  00410	48 8d 54 24 24	 lea	 rdx, QWORD PTR wData$[rsp]
  00415	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0041d	e8 00 00 00 00	 call	 wavDoRead
  00422	85 c0		 test	 eax, eax
  00424	74 0a		 je	 SHORT $LN33@aiffReadHe

; 2351 : 				return PSF_E_CANT_READ;

  00426	b8 fc ff ff ff	 mov	 eax, -4
  0042b	e9 55 07 00 00	 jmp	 $LN1@aiffReadHe
$LN33@aiffReadHe:

; 2352 : 			if(sfdat->is_little_endian)

  00430	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00438	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0043c	74 22		 je	 SHORT $LN34@aiffReadHe

; 2353 : 				wData = (WORD) REVWBYTES(wData);

  0043e	0f b7 44 24 24	 movzx	 eax, WORD PTR wData$[rsp]
  00443	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00448	c1 e0 08	 shl	 eax, 8
  0044b	0f b7 4c 24 24	 movzx	 ecx, WORD PTR wData$[rsp]
  00450	c1 f9 08	 sar	 ecx, 8
  00453	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00459	0b c1		 or	 eax, ecx
  0045b	66 89 44 24 24	 mov	 WORD PTR wData$[rsp], ax
$LN34@aiffReadHe:

; 2354 : 			sfdat->fmt.Format.wBitsPerSample = wData;

  00460	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00468	0f b7 4c 24 24	 movzx	 ecx, WORD PTR wData$[rsp]
  0046d	66 89 48 5e	 mov	 WORD PTR [rax+94], cx

; 2355 : 			if(wavDoRead(sfdat,ieee,10))

  00471	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00477	48 8d 54 24 78	 lea	 rdx, QWORD PTR ieee$[rsp]
  0047c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00484	e8 00 00 00 00	 call	 wavDoRead
  00489	85 c0		 test	 eax, eax
  0048b	74 0a		 je	 SHORT $LN35@aiffReadHe

; 2356 : 				return PSF_E_CANT_READ;

  0048d	b8 fc ff ff ff	 mov	 eax, -4
  00492	e9 ee 06 00 00	 jmp	 $LN1@aiffReadHe
$LN35@aiffReadHe:

; 2357 : 			sfdat->fmt.Format.nSamplesPerSec = (DWORD)(ieee_80_to_double(ieee));

  00497	48 8d 4c 24 78	 lea	 rcx, QWORD PTR ieee$[rsp]
  0049c	e8 00 00 00 00	 call	 ieee_80_to_double
  004a1	f2 48 0f 2c c0	 cvttsd2si rax, xmm0
  004a6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  004ae	89 41 54	 mov	 DWORD PTR [rcx+84], eax

; 2358 : 			/*we have to deduce blockalign, and hence containersize*/
; 2359 : 			/* no support (yet) for strange wordsizes such as 20 in 24 */
; 2360 : 			switch(sfdat->fmt.Format.wBitsPerSample){

  004b1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  004b9	0f b7 40 5e	 movzx	 eax, WORD PTR [rax+94]
  004bd	89 44 24 54	 mov	 DWORD PTR tv263[rsp], eax
  004c1	83 7c 24 54 10	 cmp	 DWORD PTR tv263[rsp], 16
  004c6	74 54		 je	 SHORT $LN38@aiffReadHe
  004c8	83 7c 24 54 18	 cmp	 DWORD PTR tv263[rsp], 24
  004cd	74 2b		 je	 SHORT $LN37@aiffReadHe
  004cf	83 7c 24 54 20	 cmp	 DWORD PTR tv263[rsp], 32 ; 00000020H
  004d4	74 02		 je	 SHORT $LN36@aiffReadHe
  004d6	eb 66		 jmp	 SHORT $LN39@aiffReadHe
$LN36@aiffReadHe:

; 2361 : 			case(32):
; 2362 : 				sfdat->fmt.Format.nBlockAlign = sizeof(int);

  004d8	b8 04 00 00 00	 mov	 eax, 4
  004dd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  004e5	66 89 41 5c	 mov	 WORD PTR [rcx+92], ax

; 2363 : 				sfdat->samptype = PSF_SAMP_32;

  004e9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  004f1	c7 40 30 04 00
	00 00		 mov	 DWORD PTR [rax+48], 4

; 2364 : 				break;			

  004f8	eb 4e		 jmp	 SHORT $LN6@aiffReadHe
$LN37@aiffReadHe:

; 2365 : 			case(24):
; 2366 : 				sfdat->fmt.Format.nBlockAlign = 3;

  004fa	b8 03 00 00 00	 mov	 eax, 3
  004ff	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00507	66 89 41 5c	 mov	 WORD PTR [rcx+92], ax

; 2367 : 				sfdat->samptype = PSF_SAMP_24;

  0050b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00513	c7 40 30 03 00
	00 00		 mov	 DWORD PTR [rax+48], 3

; 2368 : 				break;

  0051a	eb 2c		 jmp	 SHORT $LN6@aiffReadHe
$LN38@aiffReadHe:

; 2369 : 			case(16):
; 2370 : 				sfdat->fmt.Format.nBlockAlign = sizeof(short);

  0051c	b8 02 00 00 00	 mov	 eax, 2
  00521	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00529	66 89 41 5c	 mov	 WORD PTR [rcx+92], ax

; 2371 : 				sfdat->samptype = PSF_SAMP_16;

  0052d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00535	c7 40 30 02 00
	00 00		 mov	 DWORD PTR [rax+48], 2

; 2372 : 				break;

  0053c	eb 0a		 jmp	 SHORT $LN6@aiffReadHe
$LN39@aiffReadHe:

; 2373 : 			default:
; 2374 : 				DBGFPRINTF((stderr, "unsupported sample format for AIFF file\n"));
; 2375 : 				return PSF_E_UNSUPPORTED;

  0053e	b8 f8 ff ff ff	 mov	 eax, -8
  00543	e9 3d 06 00 00	 jmp	 $LN1@aiffReadHe
$LN6@aiffReadHe:

; 2376 : 			}
; 2377 : 			sfdat->fmt.Format.nBlockAlign = (WORD) (sfdat->fmt.Format.nBlockAlign * sfdat->fmt.Format.nChannels);

  00548	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00550	0f b7 40 5c	 movzx	 eax, WORD PTR [rax+92]
  00554	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0055c	0f b7 49 52	 movzx	 ecx, WORD PTR [rcx+82]
  00560	0f af c1	 imul	 eax, ecx
  00563	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0056b	66 89 41 5c	 mov	 WORD PTR [rcx+92], ax

; 2378 : 			remain -= 18;

  0056f	8b 44 24 28	 mov	 eax, DWORD PTR remain$[rsp]
  00573	83 e8 12	 sub	 eax, 18
  00576	89 44 24 28	 mov	 DWORD PTR remain$[rsp], eax

; 2379 : 			have_comm = 1;

  0057a	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR have_comm$[rsp], 1

; 2380 : 			break;

  00582	e9 a1 04 00 00	 jmp	 $LN4@aiffReadHe
$LN40@aiffReadHe:

; 2381 : 		case (TAG('P','E','A','K')):
; 2382 : 			if(!have_comm){

  00587	83 7c 24 58 00	 cmp	 DWORD PTR have_comm$[rsp], 0
  0058c	75 0a		 jne	 SHORT $LN41@aiffReadHe

; 2383 : 				DBGFPRINTF((stderr, "AIFF file: found PEAK chunk before COMM chunk!\n"));
; 2384 : 				return PSF_E_BAD_FORMAT;

  0058e	b8 f9 ff ff ff	 mov	 eax, -7
  00593	e9 ed 05 00 00	 jmp	 $LN1@aiffReadHe
$LN41@aiffReadHe:

; 2385 : 			}
; 2386 : 			if(size != (2 * sizeof(DWORD) + sizeof(PSF_CHPEAK) * sfdat->fmt.Format.nChannels)){

  00598	8b 44 24 2c	 mov	 eax, DWORD PTR size$[rsp]
  0059c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  005a4	0f b7 49 52	 movzx	 ecx, WORD PTR [rcx+82]
  005a8	48 8d 0c cd 08
	00 00 00	 lea	 rcx, QWORD PTR [rcx*8+8]
  005b0	48 3b c1	 cmp	 rax, rcx
  005b3	74 0a		 je	 SHORT $LN42@aiffReadHe

; 2387 : 				DBGFPRINTF((stderr, "AIFF file has bad size for PEAK chunk\n"));
; 2388 : 				return PSF_E_BAD_FORMAT;

  005b5	b8 f9 ff ff ff	 mov	 eax, -7
  005ba	e9 c6 05 00 00	 jmp	 $LN1@aiffReadHe
$LN42@aiffReadHe:

; 2389 : 			}
; 2390 :             if(wavDoRead(sfdat,(char *)&version,sizeof(DWORD))) {

  005bf	41 b8 04 00 00
	00		 mov	 r8d, 4
  005c5	48 8d 54 24 38	 lea	 rdx, QWORD PTR version$[rsp]
  005ca	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  005d2	e8 00 00 00 00	 call	 wavDoRead
  005d7	85 c0		 test	 eax, eax
  005d9	74 0a		 je	 SHORT $LN43@aiffReadHe

; 2391 :                 DBGFPRINTF((stderr,"Error reading PEAK version\n"));
; 2392 :                 return PSF_E_CANT_READ;

  005db	b8 fc ff ff ff	 mov	 eax, -4
  005e0	e9 a0 05 00 00	 jmp	 $LN1@aiffReadHe
$LN43@aiffReadHe:

; 2393 :             }
; 2394 :             if(sfdat->is_little_endian)				

  005e5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  005ed	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  005f1	74 3d		 je	 SHORT $LN44@aiffReadHe

; 2395 : 				version  = REVDWBYTES(version);

  005f3	8b 44 24 38	 mov	 eax, DWORD PTR version$[rsp]
  005f7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  005fc	c1 e0 18	 shl	 eax, 24
  005ff	8b 4c 24 38	 mov	 ecx, DWORD PTR version$[rsp]
  00603	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00609	c1 e1 08	 shl	 ecx, 8
  0060c	0b c1		 or	 eax, ecx
  0060e	8b 4c 24 38	 mov	 ecx, DWORD PTR version$[rsp]
  00612	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00618	c1 e9 08	 shr	 ecx, 8
  0061b	0b c1		 or	 eax, ecx
  0061d	8b 4c 24 38	 mov	 ecx, DWORD PTR version$[rsp]
  00621	c1 e9 18	 shr	 ecx, 24
  00624	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0062a	0b c1		 or	 eax, ecx
  0062c	89 44 24 38	 mov	 DWORD PTR version$[rsp], eax
$LN44@aiffReadHe:

; 2396 :             if(version != 1){

  00630	83 7c 24 38 01	 cmp	 DWORD PTR version$[rsp], 1
  00635	74 0a		 je	 SHORT $LN45@aiffReadHe

; 2397 : 				DBGFPRINTF((stderr, "AIFF file has unexpected version level for PEAK chunk!\n"));
; 2398 : 				return PSF_E_UNSUPPORTED;

  00637	b8 f8 ff ff ff	 mov	 eax, -8
  0063c	e9 44 05 00 00	 jmp	 $LN1@aiffReadHe
$LN45@aiffReadHe:

; 2399 : 			}
; 2400 : 		    if(fgetpos(sfdat->file,&bytepos))

  00641	48 8d 54 24 70	 lea	 rdx, QWORD PTR bytepos$[rsp]
  00646	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0064e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00651	e8 00 00 00 00	 call	 fgetpos
  00656	85 c0		 test	 eax, eax
  00658	74 0a		 je	 SHORT $LN46@aiffReadHe

; 2401 : 			return PSF_E_CANT_SEEK;

  0065a	b8 f5 ff ff ff	 mov	 eax, -11
  0065f	e9 21 05 00 00	 jmp	 $LN1@aiffReadHe
$LN46@aiffReadHe:

; 2402 : 		    sfdat->peakoffset = bytepos;

  00664	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0066c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bytepos$[rsp]
  00671	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 2403 :             if(wavDoRead(sfdat,(char *) &peaktime,sizeof(DWORD))) {

  00675	41 b8 04 00 00
	00		 mov	 r8d, 4
  0067b	48 8d 54 24 3c	 lea	 rdx, QWORD PTR peaktime$[rsp]
  00680	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00688	e8 00 00 00 00	 call	 wavDoRead
  0068d	85 c0		 test	 eax, eax
  0068f	74 0a		 je	 SHORT $LN47@aiffReadHe

; 2404 :                 DBGFPRINTF((stderr,"Error reading PEAK time\n"));
; 2405 : 				return PSF_E_CANT_READ;

  00691	b8 fc ff ff ff	 mov	 eax, -4
  00696	e9 ea 04 00 00	 jmp	 $LN1@aiffReadHe
$LN47@aiffReadHe:

; 2406 :             }
; 2407 : 			if(sfdat->is_little_endian)								

  0069b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  006a3	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  006a7	74 3d		 je	 SHORT $LN48@aiffReadHe

; 2408 : 				peaktime = REVDWBYTES(peaktime);						

  006a9	8b 44 24 3c	 mov	 eax, DWORD PTR peaktime$[rsp]
  006ad	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006b2	c1 e0 18	 shl	 eax, 24
  006b5	8b 4c 24 3c	 mov	 ecx, DWORD PTR peaktime$[rsp]
  006b9	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  006bf	c1 e1 08	 shl	 ecx, 8
  006c2	0b c1		 or	 eax, ecx
  006c4	8b 4c 24 3c	 mov	 ecx, DWORD PTR peaktime$[rsp]
  006c8	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  006ce	c1 e9 08	 shr	 ecx, 8
  006d1	0b c1		 or	 eax, ecx
  006d3	8b 4c 24 3c	 mov	 ecx, DWORD PTR peaktime$[rsp]
  006d7	c1 e9 18	 shr	 ecx, 24
  006da	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  006e0	0b c1		 or	 eax, ecx
  006e2	89 44 24 3c	 mov	 DWORD PTR peaktime$[rsp], eax
$LN48@aiffReadHe:

; 2409 : 			sfdat->peaktime = (time_t) peaktime;			

  006e6	8b 44 24 3c	 mov	 eax, DWORD PTR peaktime$[rsp]
  006ea	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  006f2	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 2410 : 			sfdat->pPeaks = (PSF_CHPEAK *)malloc(sizeof(PSF_CHPEAK) * sfdat->fmt.Format.nChannels);

  006f9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00701	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  00705	48 c1 e0 03	 shl	 rax, 3
  00709	48 8b c8	 mov	 rcx, rax
  0070c	e8 00 00 00 00	 call	 malloc
  00711	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00719	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 2411 :             if(sfdat->pPeaks==NULL){

  00720	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00728	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00730	75 0a		 jne	 SHORT $LN49@aiffReadHe

; 2412 : 			    DBGFPRINTF((stderr, "wavOpenWrite: no memory for peak data\n"));
; 2413 :                 return PSF_E_NOMEM;

  00732	b8 f7 ff ff ff	 mov	 eax, -9
  00737	e9 49 04 00 00	 jmp	 $LN1@aiffReadHe
$LN49@aiffReadHe:

; 2414 :             }
; 2415 :             if(wavDoRead(sfdat,(char *)(sfdat->pPeaks),sizeof(PSF_CHPEAK) * sfdat->fmt.Format.nChannels)){

  0073c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00744	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  00748	48 c1 e0 03	 shl	 rax, 3
  0074c	44 8b c0	 mov	 r8d, eax
  0074f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00757	48 8b 90 80 00
	00 00		 mov	 rdx, QWORD PTR [rax+128]
  0075e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00766	e8 00 00 00 00	 call	 wavDoRead
  0076b	85 c0		 test	 eax, eax
  0076d	74 0a		 je	 SHORT $LN50@aiffReadHe

; 2416 :                 DBGFPRINTF((stderr,"Error reading PEAK peak data\n"));   
; 2417 : 				return PSF_E_CANT_READ;

  0076f	b8 fc ff ff ff	 mov	 eax, -4
  00774	e9 0c 04 00 00	 jmp	 $LN1@aiffReadHe
$LN50@aiffReadHe:

; 2418 :              }
; 2419 : 			if(sfdat->is_little_endian){

  00779	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00781	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00785	0f 84 ab 00 00
	00		 je	 $LN51@aiffReadHe

; 2420 : 				DWORD *pBlock;
; 2421 : 				int i;
; 2422 : 				pBlock = (DWORD *) (sfdat->pPeaks);

  0078b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00793	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0079a	48 89 44 24 68	 mov	 QWORD PTR pBlock$4[rsp], rax

; 2423 : 				for(i=0;i < sfdat->fmt.Format.nChannels * 2; i++)

  0079f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  007a7	eb 0a		 jmp	 SHORT $LN10@aiffReadHe
$LN8@aiffReadHe:
  007a9	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  007ad	ff c0		 inc	 eax
  007af	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
$LN10@aiffReadHe:
  007b3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  007bb	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  007bf	d1 e0		 shl	 eax, 1
  007c1	39 44 24 30	 cmp	 DWORD PTR i$1[rsp], eax
  007c5	7d 6f		 jge	 SHORT $LN9@aiffReadHe

; 2424 : 					pBlock[i] = REVDWBYTES(pBlock[i]); 

  007c7	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$1[rsp]
  007cc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pBlock$4[rsp]
  007d1	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  007d4	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  007d9	c1 e0 18	 shl	 eax, 24
  007dc	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$1[rsp]
  007e1	48 8b 54 24 68	 mov	 rdx, QWORD PTR pBlock$4[rsp]
  007e6	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  007e9	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  007ef	c1 e1 08	 shl	 ecx, 8
  007f2	0b c1		 or	 eax, ecx
  007f4	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$1[rsp]
  007f9	48 8b 54 24 68	 mov	 rdx, QWORD PTR pBlock$4[rsp]
  007fe	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  00801	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00807	c1 e9 08	 shr	 ecx, 8
  0080a	0b c1		 or	 eax, ecx
  0080c	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00811	48 8b 54 24 68	 mov	 rdx, QWORD PTR pBlock$4[rsp]
  00816	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  00819	c1 e9 18	 shr	 ecx, 24
  0081c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00822	0b c1		 or	 eax, ecx
  00824	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00829	48 8b 54 24 68	 mov	 rdx, QWORD PTR pBlock$4[rsp]
  0082e	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  00831	e9 73 ff ff ff	 jmp	 $LN8@aiffReadHe
$LN9@aiffReadHe:
$LN51@aiffReadHe:

; 2425 : 			}			
; 2426 : 			remain -= size;

  00836	8b 44 24 2c	 mov	 eax, DWORD PTR size$[rsp]
  0083a	8b 4c 24 28	 mov	 ecx, DWORD PTR remain$[rsp]
  0083e	2b c8		 sub	 ecx, eax
  00840	8b c1		 mov	 eax, ecx
  00842	89 44 24 28	 mov	 DWORD PTR remain$[rsp], eax

; 2427 : 			break;

  00846	e9 dd 01 00 00	 jmp	 $LN4@aiffReadHe
$LN52@aiffReadHe:

; 2428 : 		case(TAG('S','S','N','D')):
; 2429 : 			if(wavDoRead(sfdat,(char *)&offset,sizeof(DWORD))
; 2430 : 					|| wavDoRead(sfdat,(char *) &blocksize,sizeof(DWORD)))

  0084b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00851	48 8d 54 24 40	 lea	 rdx, QWORD PTR offset$[rsp]
  00856	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0085e	e8 00 00 00 00	 call	 wavDoRead
  00863	85 c0		 test	 eax, eax
  00865	75 1c		 jne	 SHORT $LN54@aiffReadHe
  00867	41 b8 04 00 00
	00		 mov	 r8d, 4
  0086d	48 8d 54 24 44	 lea	 rdx, QWORD PTR blocksize$[rsp]
  00872	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0087a	e8 00 00 00 00	 call	 wavDoRead
  0087f	85 c0		 test	 eax, eax
  00881	74 0a		 je	 SHORT $LN53@aiffReadHe
$LN54@aiffReadHe:

; 2431 : 			return PSF_E_CANT_READ;

  00883	b8 fc ff ff ff	 mov	 eax, -4
  00888	e9 f8 02 00 00	 jmp	 $LN1@aiffReadHe
$LN53@aiffReadHe:

; 2432 : 			if(sfdat->is_little_endian){				

  0088d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00895	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00899	74 7a		 je	 SHORT $LN55@aiffReadHe

; 2433 : 				offset  = REVDWBYTES(offset);

  0089b	8b 44 24 40	 mov	 eax, DWORD PTR offset$[rsp]
  0089f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  008a4	c1 e0 18	 shl	 eax, 24
  008a7	8b 4c 24 40	 mov	 ecx, DWORD PTR offset$[rsp]
  008ab	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  008b1	c1 e1 08	 shl	 ecx, 8
  008b4	0b c1		 or	 eax, ecx
  008b6	8b 4c 24 40	 mov	 ecx, DWORD PTR offset$[rsp]
  008ba	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  008c0	c1 e9 08	 shr	 ecx, 8
  008c3	0b c1		 or	 eax, ecx
  008c5	8b 4c 24 40	 mov	 ecx, DWORD PTR offset$[rsp]
  008c9	c1 e9 18	 shr	 ecx, 24
  008cc	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  008d2	0b c1		 or	 eax, ecx
  008d4	89 44 24 40	 mov	 DWORD PTR offset$[rsp], eax

; 2434 : 				blocksize = REVDWBYTES(blocksize);

  008d8	8b 44 24 44	 mov	 eax, DWORD PTR blocksize$[rsp]
  008dc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  008e1	c1 e0 18	 shl	 eax, 24
  008e4	8b 4c 24 44	 mov	 ecx, DWORD PTR blocksize$[rsp]
  008e8	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  008ee	c1 e1 08	 shl	 ecx, 8
  008f1	0b c1		 or	 eax, ecx
  008f3	8b 4c 24 44	 mov	 ecx, DWORD PTR blocksize$[rsp]
  008f7	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  008fd	c1 e9 08	 shr	 ecx, 8
  00900	0b c1		 or	 eax, ecx
  00902	8b 4c 24 44	 mov	 ecx, DWORD PTR blocksize$[rsp]
  00906	c1 e9 18	 shr	 ecx, 24
  00909	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0090f	0b c1		 or	 eax, ecx
  00911	89 44 24 44	 mov	 DWORD PTR blocksize$[rsp], eax
$LN55@aiffReadHe:

; 2435 : 			}
; 2436 : 			if(fgetpos(sfdat->file,&bytepos))

  00915	48 8d 54 24 70	 lea	 rdx, QWORD PTR bytepos$[rsp]
  0091a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00922	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00925	e8 00 00 00 00	 call	 fgetpos
  0092a	85 c0		 test	 eax, eax
  0092c	74 0a		 je	 SHORT $LN56@aiffReadHe

; 2437 : 			    return PSF_E_CANT_SEEK;

  0092e	b8 f5 ff ff ff	 mov	 eax, -11
  00933	e9 4d 02 00 00	 jmp	 $LN1@aiffReadHe
$LN56@aiffReadHe:

; 2438 : 			sfdat->dataoffset = bytepos;

  00938	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00940	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bytepos$[rsp]
  00945	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 2439 : 			POS64(sfdat->dataoffset) += offset;

  00949	8b 44 24 40	 mov	 eax, DWORD PTR offset$[rsp]
  0094d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00955	48 03 41 38	 add	 rax, QWORD PTR [rcx+56]
  00959	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00961	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 2440 : 			sfdat->nFrames = (size - 2* sizeof(DWORD))/ sfdat->fmt.Format.nBlockAlign;

  00965	8b 44 24 2c	 mov	 eax, DWORD PTR size$[rsp]
  00969	48 83 e8 08	 sub	 rax, 8
  0096d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00975	0f b7 49 5c	 movzx	 ecx, WORD PTR [rcx+92]
  00979	33 d2		 xor	 edx, edx
  0097b	48 f7 f1	 div	 rcx
  0097e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00986	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 2441 : 			/* NB for seek: we used up 8 bytes with offset and blocksize */
; 2442 : 			/* if we already have COMM, we could finish here! */
; 2443 : 			if(fseek(sfdat->file,((size - 2* sizeof(DWORD))+1)&~1,SEEK_CUR))

  00989	8b 44 24 2c	 mov	 eax, DWORD PTR size$[rsp]
  0098d	48 83 e8 07	 sub	 rax, 7
  00991	48 83 e0 fe	 and	 rax, -2
  00995	41 b8 01 00 00
	00		 mov	 r8d, 1
  0099b	8b d0		 mov	 edx, eax
  0099d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  009a5	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  009a8	e8 00 00 00 00	 call	 fseek
  009ad	85 c0		 test	 eax, eax
  009af	74 0a		 je	 SHORT $LN57@aiffReadHe

; 2444 : 				return PSF_E_CANT_SEEK;				

  009b1	b8 f5 ff ff ff	 mov	 eax, -11
  009b6	e9 ca 01 00 00	 jmp	 $LN1@aiffReadHe
$LN57@aiffReadHe:

; 2445 : 			have_ssnd = 1;

  009bb	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR have_ssnd$[rsp], 1

; 2446 : 			remain -= (size+1)&~1;

  009c3	8b 44 24 2c	 mov	 eax, DWORD PTR size$[rsp]
  009c7	ff c0		 inc	 eax
  009c9	83 e0 fe	 and	 eax, -2			; fffffffeH
  009cc	8b 4c 24 28	 mov	 ecx, DWORD PTR remain$[rsp]
  009d0	2b c8		 sub	 ecx, eax
  009d2	8b c1		 mov	 eax, ecx
  009d4	89 44 24 28	 mov	 DWORD PTR remain$[rsp], eax

; 2447 : 			break;

  009d8	eb 4e		 jmp	 SHORT $LN4@aiffReadHe
$LN58@aiffReadHe:

; 2448 : 		/*HARSH! traps old linux sox error, for example */
; 2449 : 		case(0):
; 2450 : 			DBGFPRINTF((stderr, "AIFF file has bad main chunksize\n"));
; 2451 : 			return PSF_E_BAD_FORMAT;

  009da	b8 f9 ff ff ff	 mov	 eax, -7
  009df	e9 a1 01 00 00	 jmp	 $LN1@aiffReadHe
$LN59@aiffReadHe:

; 2452 : 		default:
; 2453 : 			/* skip all unknown chunks */
; 2454 :             if(fseek(sfdat->file,(size+1)&~1,SEEK_CUR))

  009e4	8b 44 24 2c	 mov	 eax, DWORD PTR size$[rsp]
  009e8	ff c0		 inc	 eax
  009ea	83 e0 fe	 and	 eax, -2			; fffffffeH
  009ed	41 b8 01 00 00
	00		 mov	 r8d, 1
  009f3	8b d0		 mov	 edx, eax
  009f5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  009fd	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00a00	e8 00 00 00 00	 call	 fseek
  00a05	85 c0		 test	 eax, eax
  00a07	74 0a		 je	 SHORT $LN60@aiffReadHe

; 2455 : 				return PSF_E_CANT_SEEK;

  00a09	b8 f5 ff ff ff	 mov	 eax, -11
  00a0e	e9 72 01 00 00	 jmp	 $LN1@aiffReadHe
$LN60@aiffReadHe:

; 2456 : 			remain -= (size+1)&~1;

  00a13	8b 44 24 2c	 mov	 eax, DWORD PTR size$[rsp]
  00a17	ff c0		 inc	 eax
  00a19	83 e0 fe	 and	 eax, -2			; fffffffeH
  00a1c	8b 4c 24 28	 mov	 ecx, DWORD PTR remain$[rsp]
  00a20	2b c8		 sub	 ecx, eax
  00a22	8b c1		 mov	 eax, ecx
  00a24	89 44 24 28	 mov	 DWORD PTR remain$[rsp], eax
$LN4@aiffReadHe:

; 2457 : 			break;
; 2458 : 		}
; 2459 : 	}

  00a28	e9 93 f7 ff ff	 jmp	 $LN2@aiffReadHe
$LN3@aiffReadHe:

; 2460 : 	if(!(have_ssnd && have_comm)){

  00a2d	83 7c 24 5c 00	 cmp	 DWORD PTR have_ssnd$[rsp], 0
  00a32	74 07		 je	 SHORT $LN62@aiffReadHe
  00a34	83 7c 24 58 00	 cmp	 DWORD PTR have_comm$[rsp], 0
  00a39	75 0a		 jne	 SHORT $LN61@aiffReadHe
$LN62@aiffReadHe:

; 2461 : 		DBGFPRINTF((stderr, "AIFF file has missing chunks\n"));
; 2462 : 		return PSF_E_BAD_FORMAT;

  00a3b	b8 f9 ff ff ff	 mov	 eax, -7
  00a40	e9 40 01 00 00	 jmp	 $LN1@aiffReadHe
$LN61@aiffReadHe:

; 2463 : 	}
; 2464 : 	/* we have seeked to EOF, so rewind to start of data */
; 2465 : 	if(fsetpos(sfdat->file,&sfdat->dataoffset))

  00a45	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00a4d	48 83 c0 38	 add	 rax, 56			; 00000038H
  00a51	48 8b d0	 mov	 rdx, rax
  00a54	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00a5c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00a5f	e8 00 00 00 00	 call	 fsetpos
  00a64	85 c0		 test	 eax, eax
  00a66	74 0a		 je	 SHORT $LN63@aiffReadHe

; 2466 : 		return PSF_E_CANT_SEEK;			

  00a68	b8 f5 ff ff ff	 mov	 eax, -11
  00a6d	e9 13 01 00 00	 jmp	 $LN1@aiffReadHe
$LN63@aiffReadHe:

; 2467 : 	sfdat->curframepos = 0;	

  00a72	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00a7a	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 2468 : 	sfdat->riff_format = PSF_AIFF;

  00a81	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00a89	c7 40 28 03 00
	00 00		 mov	 DWORD PTR [rax+40], 3

; 2469 : 	/* get rescale factor if available */
; 2470 : 	/* NB in correct format, val is always >= 0.0 */
; 2471 : 	if(sfdat->pPeaks &&  POS64(sfdat->peakoffset) != 0){

  00a90	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00a98	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00aa0	0f 84 cb 00 00
	00		 je	 $LN64@aiffReadHe
  00aa6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00aae	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  00ab3	0f 84 b8 00 00
	00		 je	 $LN64@aiffReadHe

; 2472 : 		float fac = 0.0f;

  00ab9	0f 57 c0	 xorps	 xmm0, xmm0
  00abc	f3 0f 11 44 24
	4c		 movss	 DWORD PTR fac$3[rsp], xmm0

; 2473 : 		int i;
; 2474 : 		for(i=0;i < sfdat->fmt.Format.nChannels; i++)

  00ac2	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  00aca	eb 0a		 jmp	 SHORT $LN13@aiffReadHe
$LN11@aiffReadHe:
  00acc	8b 44 24 48	 mov	 eax, DWORD PTR i$2[rsp]
  00ad0	ff c0		 inc	 eax
  00ad2	89 44 24 48	 mov	 DWORD PTR i$2[rsp], eax
$LN13@aiffReadHe:
  00ad6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00ade	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  00ae2	39 44 24 48	 cmp	 DWORD PTR i$2[rsp], eax
  00ae6	7d 5f		 jge	 SHORT $LN12@aiffReadHe

; 2475 : 			fac = max(fac,sfdat->pPeaks[i].val);

  00ae8	48 63 44 24 48	 movsxd	 rax, DWORD PTR i$2[rsp]
  00aed	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00af5	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00afc	f3 0f 10 04 c1	 movss	 xmm0, DWORD PTR [rcx+rax*8]
  00b01	f3 0f 10 4c 24
	4c		 movss	 xmm1, DWORD PTR fac$3[rsp]
  00b07	0f 2f c8	 comiss	 xmm1, xmm0
  00b0a	76 0e		 jbe	 SHORT $LN67@aiffReadHe
  00b0c	f3 0f 10 44 24
	4c		 movss	 xmm0, DWORD PTR fac$3[rsp]
  00b12	f3 0f 11 44 24
	60		 movss	 DWORD PTR tv500[rsp], xmm0
  00b18	eb 1f		 jmp	 SHORT $LN68@aiffReadHe
$LN67@aiffReadHe:
  00b1a	48 63 44 24 48	 movsxd	 rax, DWORD PTR i$2[rsp]
  00b1f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00b27	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00b2e	f3 0f 10 04 c1	 movss	 xmm0, DWORD PTR [rcx+rax*8]
  00b33	f3 0f 11 44 24
	60		 movss	 DWORD PTR tv500[rsp], xmm0
$LN68@aiffReadHe:
  00b39	f3 0f 10 44 24
	60		 movss	 xmm0, DWORD PTR tv500[rsp]
  00b3f	f3 0f 11 44 24
	4c		 movss	 DWORD PTR fac$3[rsp], xmm0
  00b45	eb 85		 jmp	 SHORT $LN11@aiffReadHe
$LN12@aiffReadHe:

; 2476 : 		if(fac > 1.0f)

  00b47	f3 0f 10 44 24
	4c		 movss	 xmm0, DWORD PTR fac$3[rsp]
  00b4d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00b54	76 1b		 jbe	 SHORT $LN65@aiffReadHe

; 2477 : 			sfdat->rescale_fac = 1.0f / fac;

  00b56	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00b5e	f3 0f 5e 44 24
	4c		 divss	 xmm0, DWORD PTR fac$3[rsp]
  00b64	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00b6c	f3 0f 11 40 24	 movss	 DWORD PTR [rax+36], xmm0
$LN65@aiffReadHe:
$LN64@aiffReadHe:

; 2478 : 	}
; 2479 : 	sfdat->lastop  = PSF_OP_READ;

  00b71	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00b79	c7 80 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+152], 0

; 2480 : 	return PSF_E_NOERROR;

  00b83	33 c0		 xor	 eax, eax
$LN1@aiffReadHe:

; 2481 : }

  00b85	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00b8d	48 33 cc	 xor	 rcx, rsp
  00b90	e8 00 00 00 00	 call	 __security_check_cookie
  00b95	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00b9c	c3		 ret	 0
aiffReadHeader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
tag$ = 32
size$ = 36
cbSize$ = 40
i$1 = 44
version$ = 48
peaktime$ = 52
validbits$2 = 56
chmask$3 = 60
i$4 = 64
fac$5 = 68
tv502 = 72
dummy$6 = 76
tv189 = 80
fmtsize$7 = 84
tv491 = 88
tv485 = 92
pBlock$8 = 96
bytepos$ = 104
tv462 = 112
sfdat$ = 144
wavReadHeader PROC

; 2067 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 2068 : 	DWORD tag,version,peaktime;
; 2069 : 	DWORD size;
; 2070 : 	WORD cbSize;
; 2071 : 	fpos_t bytepos;
; 2072 : 
; 2073 : 	if(sfdat==NULL || sfdat->file == NULL)

  0000c	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR sfdat$[rsp], 0
  00015	74 0e		 je	 SHORT $LN20@wavReadHea
  00017	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0001f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00023	75 0a		 jne	 SHORT $LN19@wavReadHea
$LN20@wavReadHea:

; 2074 : 		return PSF_E_BADARG;

  00025	b8 f6 ff ff ff	 mov	 eax, -10
  0002a	e9 94 0c 00 00	 jmp	 $LN1@wavReadHea
$LN19@wavReadHea:

; 2075 : 
; 2076 : 	if(wavDoRead(sfdat,(char *)&tag,sizeof(DWORD))
; 2077 : 		|| wavDoRead(sfdat,(char *) &size,sizeof(DWORD)))

  0002f	41 b8 04 00 00
	00		 mov	 r8d, 4
  00035	48 8d 54 24 20	 lea	 rdx, QWORD PTR tag$[rsp]
  0003a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00042	e8 00 00 00 00	 call	 wavDoRead
  00047	85 c0		 test	 eax, eax
  00049	75 1c		 jne	 SHORT $LN22@wavReadHea
  0004b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00051	48 8d 54 24 24	 lea	 rdx, QWORD PTR size$[rsp]
  00056	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0005e	e8 00 00 00 00	 call	 wavDoRead
  00063	85 c0		 test	 eax, eax
  00065	74 0a		 je	 SHORT $LN21@wavReadHea
$LN22@wavReadHea:

; 2078 : 		return PSF_E_CANT_READ;

  00067	b8 fc ff ff ff	 mov	 eax, -4
  0006c	e9 52 0c 00 00	 jmp	 $LN1@wavReadHea
$LN21@wavReadHea:

; 2079 : 	if(!sfdat->is_little_endian)

  00071	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00079	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0007d	75 3f		 jne	 SHORT $LN23@wavReadHea

; 2080 : 		size = REVDWBYTES(size);

  0007f	8b 44 24 24	 mov	 eax, DWORD PTR size$[rsp]
  00083	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00088	c1 e0 18	 shl	 eax, 24
  0008b	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  0008f	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00095	c1 e1 08	 shl	 ecx, 8
  00098	0b c1		 or	 eax, ecx
  0009a	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  0009e	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  000a4	c1 e9 08	 shr	 ecx, 8
  000a7	0b c1		 or	 eax, ecx
  000a9	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  000ad	c1 e9 18	 shr	 ecx, 24
  000b0	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000b6	0b c1		 or	 eax, ecx
  000b8	89 44 24 24	 mov	 DWORD PTR size$[rsp], eax
  000bc	eb 3d		 jmp	 SHORT $LN24@wavReadHea
$LN23@wavReadHea:

; 2081 : 	else
; 2082 : 		tag = REVDWBYTES(tag);

  000be	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  000c2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000c7	c1 e0 18	 shl	 eax, 24
  000ca	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  000ce	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  000d4	c1 e1 08	 shl	 ecx, 8
  000d7	0b c1		 or	 eax, ecx
  000d9	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  000dd	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  000e3	c1 e9 08	 shr	 ecx, 8
  000e6	0b c1		 or	 eax, ecx
  000e8	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  000ec	c1 e9 18	 shr	 ecx, 24
  000ef	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000f5	0b c1		 or	 eax, ecx
  000f7	89 44 24 20	 mov	 DWORD PTR tag$[rsp], eax
$LN24@wavReadHea:

; 2083 : 	if(tag != TAG('R','I','F','F'))

  000fb	81 7c 24 20 46
	46 49 52	 cmp	 DWORD PTR tag$[rsp], 1380533830 ; 52494646H
  00103	74 0a		 je	 SHORT $LN25@wavReadHea

; 2084 : 		return PSF_E_NOT_WAVE;

  00105	b8 fb ff ff ff	 mov	 eax, -5
  0010a	e9 b4 0b 00 00	 jmp	 $LN1@wavReadHea
$LN25@wavReadHea:

; 2085 : 	if(size < (sizeof(WAVEFORMAT) + 3 * sizeof(WORD)))

  0010f	8b 44 24 24	 mov	 eax, DWORD PTR size$[rsp]
  00113	48 83 f8 16	 cmp	 rax, 22
  00117	73 0a		 jae	 SHORT $LN26@wavReadHea

; 2086 : 		return PSF_E_BAD_FORMAT;

  00119	b8 f9 ff ff ff	 mov	 eax, -7
  0011e	e9 a0 0b 00 00	 jmp	 $LN1@wavReadHea
$LN26@wavReadHea:

; 2087 : 
; 2088 : 	if(wavDoRead(sfdat,(char *)&tag,sizeof(DWORD)))

  00123	41 b8 04 00 00
	00		 mov	 r8d, 4
  00129	48 8d 54 24 20	 lea	 rdx, QWORD PTR tag$[rsp]
  0012e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00136	e8 00 00 00 00	 call	 wavDoRead
  0013b	85 c0		 test	 eax, eax
  0013d	74 0a		 je	 SHORT $LN27@wavReadHea

; 2089 : 		return PSF_E_CANT_READ;

  0013f	b8 fc ff ff ff	 mov	 eax, -4
  00144	e9 7a 0b 00 00	 jmp	 $LN1@wavReadHea
$LN27@wavReadHea:

; 2090 : 	if(sfdat->is_little_endian)

  00149	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00151	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00155	74 3d		 je	 SHORT $LN28@wavReadHea

; 2091 : 		tag = REVDWBYTES(tag);

  00157	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  0015b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00160	c1 e0 18	 shl	 eax, 24
  00163	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00167	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  0016d	c1 e1 08	 shl	 ecx, 8
  00170	0b c1		 or	 eax, ecx
  00172	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00176	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  0017c	c1 e9 08	 shr	 ecx, 8
  0017f	0b c1		 or	 eax, ecx
  00181	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00185	c1 e9 18	 shr	 ecx, 24
  00188	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0018e	0b c1		 or	 eax, ecx
  00190	89 44 24 20	 mov	 DWORD PTR tag$[rsp], eax
$LN28@wavReadHea:

; 2092 : 	if(tag != TAG('W','A','V','E'))

  00194	81 7c 24 20 45
	56 41 57	 cmp	 DWORD PTR tag$[rsp], 1463899717 ; 57415645H
  0019c	74 0a		 je	 SHORT $LN29@wavReadHea

; 2093 : 		return PSF_E_NOT_WAVE;

  0019e	b8 fb ff ff ff	 mov	 eax, -5
  001a3	e9 1b 0b 00 00	 jmp	 $LN1@wavReadHea
$LN29@wavReadHea:
$LN2@wavReadHea:

; 2094 : 	for(;;){
; 2095 : 		if(wavDoRead(sfdat,(char *)&tag,sizeof(DWORD))
; 2096 : 				|| wavDoRead(sfdat,(char *) &size,sizeof(DWORD)))

  001a8	41 b8 04 00 00
	00		 mov	 r8d, 4
  001ae	48 8d 54 24 20	 lea	 rdx, QWORD PTR tag$[rsp]
  001b3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  001bb	e8 00 00 00 00	 call	 wavDoRead
  001c0	85 c0		 test	 eax, eax
  001c2	75 1c		 jne	 SHORT $LN31@wavReadHea
  001c4	41 b8 04 00 00
	00		 mov	 r8d, 4
  001ca	48 8d 54 24 24	 lea	 rdx, QWORD PTR size$[rsp]
  001cf	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  001d7	e8 00 00 00 00	 call	 wavDoRead
  001dc	85 c0		 test	 eax, eax
  001de	74 0a		 je	 SHORT $LN30@wavReadHea
$LN31@wavReadHea:

; 2097 : 			return PSF_E_CANT_READ;

  001e0	b8 fc ff ff ff	 mov	 eax, -4
  001e5	e9 d9 0a 00 00	 jmp	 $LN1@wavReadHea
$LN30@wavReadHea:

; 2098 : 		if(!sfdat->is_little_endian)

  001ea	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  001f2	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  001f6	75 3f		 jne	 SHORT $LN32@wavReadHea

; 2099 : 			size = REVDWBYTES(size);

  001f8	8b 44 24 24	 mov	 eax, DWORD PTR size$[rsp]
  001fc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00201	c1 e0 18	 shl	 eax, 24
  00204	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  00208	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  0020e	c1 e1 08	 shl	 ecx, 8
  00211	0b c1		 or	 eax, ecx
  00213	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  00217	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  0021d	c1 e9 08	 shr	 ecx, 8
  00220	0b c1		 or	 eax, ecx
  00222	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  00226	c1 e9 18	 shr	 ecx, 24
  00229	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0022f	0b c1		 or	 eax, ecx
  00231	89 44 24 24	 mov	 DWORD PTR size$[rsp], eax
  00235	eb 3d		 jmp	 SHORT $LN33@wavReadHea
$LN32@wavReadHea:

; 2100 : 		else
; 2101 : 			tag = REVDWBYTES(tag);

  00237	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  0023b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00240	c1 e0 18	 shl	 eax, 24
  00243	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00247	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  0024d	c1 e1 08	 shl	 ecx, 8
  00250	0b c1		 or	 eax, ecx
  00252	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00256	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  0025c	c1 e9 08	 shr	 ecx, 8
  0025f	0b c1		 or	 eax, ecx
  00261	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00265	c1 e9 18	 shr	 ecx, 24
  00268	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0026e	0b c1		 or	 eax, ecx
  00270	89 44 24 20	 mov	 DWORD PTR tag$[rsp], eax
$LN33@wavReadHea:

; 2102 : 		switch(tag){

  00274	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  00278	89 44 24 50	 mov	 DWORD PTR tv189[rsp], eax
  0027c	81 7c 24 50 4b
	41 45 50	 cmp	 DWORD PTR tv189[rsp], 1346715979 ; 5045414bH
  00284	0f 84 76 04 00
	00		 je	 $LN59@wavReadHea
  0028a	81 7c 24 50 61
	74 61 64	 cmp	 DWORD PTR tv189[rsp], 1684108385 ; 64617461H
  00292	0f 84 0b 07 00
	00		 je	 $LN70@wavReadHea
  00298	81 7c 24 50 20
	74 6d 66	 cmp	 DWORD PTR tv189[rsp], 1718449184 ; 666d7420H
  002a0	74 05		 je	 SHORT $LN34@wavReadHea
  002a2	e9 f2 09 00 00	 jmp	 $LN89@wavReadHea
$LN34@wavReadHea:

; 2103 : 		case(TAG('f','m','t',' ')):
; 2104 : 			if( size < sizeof(WAVEFORMAT))

  002a7	8b 44 24 24	 mov	 eax, DWORD PTR size$[rsp]
  002ab	48 83 f8 10	 cmp	 rax, 16
  002af	73 0a		 jae	 SHORT $LN35@wavReadHea

; 2105 : 				return PSF_E_BAD_FORMAT;

  002b1	b8 f9 ff ff ff	 mov	 eax, -7
  002b6	e9 08 0a 00 00	 jmp	 $LN1@wavReadHea
$LN35@wavReadHea:

; 2106 : 			if(size > sizeof_WFMTEX)

  002bb	83 7c 24 24 28	 cmp	 DWORD PTR size$[rsp], 40 ; 00000028H
  002c0	76 0a		 jbe	 SHORT $LN36@wavReadHea

; 2107 : 				return PSF_E_UNSUPPORTED;

  002c2	b8 f8 ff ff ff	 mov	 eax, -8
  002c7	e9 f7 09 00 00	 jmp	 $LN1@wavReadHea
$LN36@wavReadHea:

; 2108 : 			if(fgetpos(sfdat->file,&bytepos))

  002cc	48 8d 54 24 68	 lea	 rdx, QWORD PTR bytepos$[rsp]
  002d1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  002d9	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  002dc	e8 00 00 00 00	 call	 fgetpos
  002e1	85 c0		 test	 eax, eax
  002e3	74 0a		 je	 SHORT $LN37@wavReadHea

; 2109 : 			    return PSF_E_CANT_SEEK;

  002e5	b8 f5 ff ff ff	 mov	 eax, -11
  002ea	e9 d4 09 00 00	 jmp	 $LN1@wavReadHea
$LN37@wavReadHea:

; 2110 : 			sfdat->fmtoffset = bytepos;

  002ef	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  002f7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bytepos$[rsp]
  002fc	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 2111 : 			if(wavDoRead(sfdat,(char *)&(sfdat->fmt.Format),sizeof(WAVEFORMAT))){				

  00300	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00308	48 83 c0 50	 add	 rax, 80			; 00000050H
  0030c	41 b8 10 00 00
	00		 mov	 r8d, 16
  00312	48 8b d0	 mov	 rdx, rax
  00315	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0031d	e8 00 00 00 00	 call	 wavDoRead
  00322	85 c0		 test	 eax, eax
  00324	74 0a		 je	 SHORT $LN38@wavReadHea

; 2112 : 				return PSF_E_CANT_READ;

  00326	b8 fc ff ff ff	 mov	 eax, -4
  0032b	e9 93 09 00 00	 jmp	 $LN1@wavReadHea
$LN38@wavReadHea:

; 2113 : 			}
; 2114 : 			if(!sfdat->is_little_endian)		

  00330	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00338	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0033c	75 0d		 jne	 SHORT $LN39@wavReadHea

; 2115 : 				fmtSwapBytes(sfdat);	

  0033e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00346	e8 00 00 00 00	 call	 fmtSwapBytes
$LN39@wavReadHea:

; 2116 : 			/* calling function decides if format is supported*/
; 2117 : 			if(size > sizeof(WAVEFORMAT)) {

  0034b	8b 44 24 24	 mov	 eax, DWORD PTR size$[rsp]
  0034f	48 83 f8 10	 cmp	 rax, 16
  00353	0f 86 a2 03 00
	00		 jbe	 $LN40@wavReadHea

; 2118 : 				if(wavDoRead(sfdat,(char*)&cbSize,sizeof(WORD)))

  00359	41 b8 02 00 00
	00		 mov	 r8d, 2
  0035f	48 8d 54 24 28	 lea	 rdx, QWORD PTR cbSize$[rsp]
  00364	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0036c	e8 00 00 00 00	 call	 wavDoRead
  00371	85 c0		 test	 eax, eax
  00373	74 0a		 je	 SHORT $LN41@wavReadHea

; 2119 : 					return PSF_E_CANT_READ;

  00375	b8 fc ff ff ff	 mov	 eax, -4
  0037a	e9 44 09 00 00	 jmp	 $LN1@wavReadHea
$LN41@wavReadHea:

; 2120 : 				if(!sfdat->is_little_endian)		

  0037f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00387	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0038b	75 22		 jne	 SHORT $LN42@wavReadHea

; 2121 : 					cbSize = (WORD) REVWBYTES(cbSize);

  0038d	0f b7 44 24 28	 movzx	 eax, WORD PTR cbSize$[rsp]
  00392	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00397	c1 e0 08	 shl	 eax, 8
  0039a	0f b7 4c 24 28	 movzx	 ecx, WORD PTR cbSize$[rsp]
  0039f	c1 f9 08	 sar	 ecx, 8
  003a2	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  003a8	0b c1		 or	 eax, ecx
  003aa	66 89 44 24 28	 mov	 WORD PTR cbSize$[rsp], ax
$LN42@wavReadHea:

; 2122 : 				if(cbSize != (WORD)0) {

  003af	0f b7 44 24 28	 movzx	 eax, WORD PTR cbSize$[rsp]
  003b4	85 c0		 test	 eax, eax
  003b6	74 3b		 je	 SHORT $LN43@wavReadHea

; 2123 : 					if(sfdat->fmt.Format.wFormatTag	== WAVE_FORMAT_EXTENSIBLE){

  003b8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  003c0	0f b7 40 50	 movzx	 eax, WORD PTR [rax+80]
  003c4	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH
  003c9	75 23		 jne	 SHORT $LN45@wavReadHea

; 2124 : 						if(cbSize != 22)

  003cb	0f b7 44 24 28	 movzx	 eax, WORD PTR cbSize$[rsp]
  003d0	83 f8 16	 cmp	 eax, 22
  003d3	74 0a		 je	 SHORT $LN46@wavReadHea

; 2125 : 							return PSF_E_BAD_FORMAT;

  003d5	b8 f9 ff ff ff	 mov	 eax, -7
  003da	e9 e4 08 00 00	 jmp	 $LN1@wavReadHea
$LN46@wavReadHea:

; 2126 : 						sfdat->riff_format = PSF_WAVE_EX;						

  003df	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  003e7	c7 40 28 02 00
	00 00		 mov	 DWORD PTR [rax+40], 2
$LN45@wavReadHea:

; 2127 : 					}
; 2128 : 				}				

  003ee	e9 81 00 00 00	 jmp	 $LN44@wavReadHea
$LN43@wavReadHea:

; 2129 : 				else {
; 2130 :                     int fmtsize = 18;

  003f3	c7 44 24 54 12
	00 00 00	 mov	 DWORD PTR fmtsize$7[rsp], 18

; 2131 : 					/* cbSize = 0: has to be 18-byte WAVEFORMATEX */
; 2132 : 					if((sfdat->fmt.Format.wFormatTag == WAVE_FORMAT_PCM
; 2133 : 						|| sfdat->fmt.Format.wFormatTag	== WAVE_FORMAT_IEEE_FLOAT))

  003fb	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00403	0f b7 40 50	 movzx	 eax, WORD PTR [rax+80]
  00407	83 f8 01	 cmp	 eax, 1
  0040a	74 11		 je	 SHORT $LN49@wavReadHea
  0040c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00414	0f b7 40 50	 movzx	 eax, WORD PTR [rax+80]
  00418	83 f8 03	 cmp	 eax, 3
  0041b	75 11		 jne	 SHORT $LN47@wavReadHea
$LN49@wavReadHea:

; 2134 : 						sfdat->riff_format = PSF_STDWAVE;

  0041d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00425	c7 40 28 01 00
	00 00		 mov	 DWORD PTR [rax+40], 1
  0042c	eb 0a		 jmp	 SHORT $LN48@wavReadHea
$LN47@wavReadHea:

; 2135 : 					else  /* some horribly mangled format! */
; 2136 : 						return PSF_E_BAD_FORMAT;

  0042e	b8 f9 ff ff ff	 mov	 eax, -7
  00433	e9 8b 08 00 00	 jmp	 $LN1@wavReadHea
$LN48@wavReadHea:
$LN7@wavReadHea:

; 2137 :                     /* hack to handle bad files created by company X with overlarge fmt chunk! */
; 2138 :                     while (size > fmtsize){

  00438	8b 44 24 54	 mov	 eax, DWORD PTR fmtsize$7[rsp]
  0043c	39 44 24 24	 cmp	 DWORD PTR size$[rsp], eax
  00440	76 32		 jbe	 SHORT $LN8@wavReadHea

; 2139 :                         char dummy;
; 2140 :                         if(wavDoRead(sfdat,(char*)&dummy,sizeof(char)))

  00442	41 b8 01 00 00
	00		 mov	 r8d, 1
  00448	48 8d 54 24 4c	 lea	 rdx, QWORD PTR dummy$6[rsp]
  0044d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00455	e8 00 00 00 00	 call	 wavDoRead
  0045a	85 c0		 test	 eax, eax
  0045c	74 0a		 je	 SHORT $LN50@wavReadHea

; 2141 : 					        return PSF_E_CANT_READ;

  0045e	b8 fc ff ff ff	 mov	 eax, -4
  00463	e9 5b 08 00 00	 jmp	 $LN1@wavReadHea
$LN50@wavReadHea:

; 2142 :                         fmtsize++;

  00468	8b 44 24 54	 mov	 eax, DWORD PTR fmtsize$7[rsp]
  0046c	ff c0		 inc	 eax
  0046e	89 44 24 54	 mov	 DWORD PTR fmtsize$7[rsp], eax

; 2143 :                         /* TODO: send irate message to user about illformed files*/
; 2144 :                     }

  00472	eb c4		 jmp	 SHORT $LN7@wavReadHea
$LN8@wavReadHea:
$LN44@wavReadHea:

; 2145 : 				}				
; 2146 : 				sfdat->fmt.Format.cbSize = cbSize;

  00474	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0047c	0f b7 4c 24 28	 movzx	 ecx, WORD PTR cbSize$[rsp]
  00481	66 89 48 60	 mov	 WORD PTR [rax+96], cx

; 2147 : 				/* fill in as if basic Format; may change later from WAVE-EX */
; 2148 : 				sfdat->fmt.Samples.wValidBitsPerSample = sfdat->fmt.Format.wBitsPerSample;

  00485	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0048d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00495	0f b7 49 5e	 movzx	 ecx, WORD PTR [rcx+94]
  00499	66 89 48 64	 mov	 WORD PTR [rax+100], cx

; 2149 : 				sfdat->fmt.dwChannelMask = 0;			

  0049d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  004a5	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [rax+104], 0

; 2150 : 				/* get rest of WAVE-EX, if we have it */
; 2151 : 				if(sfdat->fmt.Format.wFormatTag	== WAVE_FORMAT_EXTENSIBLE){

  004ac	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  004b4	0f b7 40 50	 movzx	 eax, WORD PTR [rax+80]
  004b8	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH
  004bd	0f 85 38 02 00
	00		 jne	 $LN51@wavReadHea

; 2152 : 					WORD validbits;
; 2153 : 					DWORD chmask;
; 2154 : 					if(wavDoRead(sfdat,(char *) &validbits,sizeof(WORD)))

  004c3	41 b8 02 00 00
	00		 mov	 r8d, 2
  004c9	48 8d 54 24 38	 lea	 rdx, QWORD PTR validbits$2[rsp]
  004ce	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  004d6	e8 00 00 00 00	 call	 wavDoRead
  004db	85 c0		 test	 eax, eax
  004dd	74 0a		 je	 SHORT $LN52@wavReadHea

; 2155 : 						return PSF_E_CANT_READ;

  004df	b8 fc ff ff ff	 mov	 eax, -4
  004e4	e9 da 07 00 00	 jmp	 $LN1@wavReadHea
$LN52@wavReadHea:

; 2156 : 					if(!sfdat->is_little_endian)		

  004e9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  004f1	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  004f5	75 29		 jne	 SHORT $LN53@wavReadHea

; 2157 : 						sfdat->fmt.Samples.wValidBitsPerSample = (WORD) REVWBYTES(validbits);

  004f7	0f b7 44 24 38	 movzx	 eax, WORD PTR validbits$2[rsp]
  004fc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00501	c1 e0 08	 shl	 eax, 8
  00504	0f b7 4c 24 38	 movzx	 ecx, WORD PTR validbits$2[rsp]
  00509	c1 f9 08	 sar	 ecx, 8
  0050c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00512	0b c1		 or	 eax, ecx
  00514	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0051c	66 89 41 64	 mov	 WORD PTR [rcx+100], ax
$LN53@wavReadHea:

; 2158 : 					if(wavDoRead(sfdat,(char *) &chmask,sizeof(DWORD)))

  00520	41 b8 04 00 00
	00		 mov	 r8d, 4
  00526	48 8d 54 24 3c	 lea	 rdx, QWORD PTR chmask$3[rsp]
  0052b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00533	e8 00 00 00 00	 call	 wavDoRead
  00538	85 c0		 test	 eax, eax
  0053a	74 0a		 je	 SHORT $LN54@wavReadHea

; 2159 : 						return PSF_E_CANT_READ;

  0053c	b8 fc ff ff ff	 mov	 eax, -4
  00541	e9 7d 07 00 00	 jmp	 $LN1@wavReadHea
$LN54@wavReadHea:

; 2160 :                     sfdat->fmt.dwChannelMask = chmask;

  00546	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0054e	8b 4c 24 3c	 mov	 ecx, DWORD PTR chmask$3[rsp]
  00552	89 48 68	 mov	 DWORD PTR [rax+104], ecx

; 2161 : 					if(!sfdat->is_little_endian)		

  00555	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0055d	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00561	75 44		 jne	 SHORT $LN55@wavReadHea

; 2162 : 						sfdat->fmt.dwChannelMask = REVDWBYTES(chmask);

  00563	8b 44 24 3c	 mov	 eax, DWORD PTR chmask$3[rsp]
  00567	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0056c	c1 e0 18	 shl	 eax, 24
  0056f	8b 4c 24 3c	 mov	 ecx, DWORD PTR chmask$3[rsp]
  00573	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00579	c1 e1 08	 shl	 ecx, 8
  0057c	0b c1		 or	 eax, ecx
  0057e	8b 4c 24 3c	 mov	 ecx, DWORD PTR chmask$3[rsp]
  00582	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00588	c1 e9 08	 shr	 ecx, 8
  0058b	0b c1		 or	 eax, ecx
  0058d	8b 4c 24 3c	 mov	 ecx, DWORD PTR chmask$3[rsp]
  00591	c1 e9 18	 shr	 ecx, 24
  00594	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0059a	0b c1		 or	 eax, ecx
  0059c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  005a4	89 41 68	 mov	 DWORD PTR [rcx+104], eax
$LN55@wavReadHea:

; 2163 :                     /* TODO: recognize more speaker layouts! */
; 2164 :                     sfdat->chformat = get_speakerlayout(sfdat->fmt.dwChannelMask,sfdat->fmt.Format.nChannels);

  005a7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  005af	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  005b3	8b d0		 mov	 edx, eax
  005b5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  005bd	8b 48 68	 mov	 ecx, DWORD PTR [rax+104]
  005c0	e8 00 00 00 00	 call	 get_speakerlayout
  005c5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  005cd	89 41 7c	 mov	 DWORD PTR [rcx+124], eax

; 2165 : 					if(wavDoRead(sfdat,(char *) &(sfdat->fmt.SubFormat),sizeof(GUID)))

  005d0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  005d8	48 83 c0 6c	 add	 rax, 108		; 0000006cH
  005dc	41 b8 10 00 00
	00		 mov	 r8d, 16
  005e2	48 8b d0	 mov	 rdx, rax
  005e5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  005ed	e8 00 00 00 00	 call	 wavDoRead
  005f2	85 c0		 test	 eax, eax
  005f4	74 0a		 je	 SHORT $LN56@wavReadHea

; 2166 : 						return PSF_E_CANT_READ;

  005f6	b8 fc ff ff ff	 mov	 eax, -4
  005fb	e9 c3 06 00 00	 jmp	 $LN1@wavReadHea
$LN56@wavReadHea:

; 2167 : 					if(!sfdat->is_little_endian){

  00600	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00608	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0060c	0f 85 ce 00 00
	00		 jne	 $LN57@wavReadHea

; 2168 : 						sfdat->fmt.SubFormat.Data1 = REVDWBYTES(sfdat->fmt.SubFormat.Data1);

  00612	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0061a	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  0061d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00622	c1 e0 18	 shl	 eax, 24
  00625	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0062d	8b 49 6c	 mov	 ecx, DWORD PTR [rcx+108]
  00630	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00636	c1 e1 08	 shl	 ecx, 8
  00639	0b c1		 or	 eax, ecx
  0063b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00643	8b 49 6c	 mov	 ecx, DWORD PTR [rcx+108]
  00646	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  0064c	c1 e9 08	 shr	 ecx, 8
  0064f	0b c1		 or	 eax, ecx
  00651	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00659	8b 49 6c	 mov	 ecx, DWORD PTR [rcx+108]
  0065c	c1 e9 18	 shr	 ecx, 24
  0065f	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00665	0b c1		 or	 eax, ecx
  00667	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0066f	89 41 6c	 mov	 DWORD PTR [rcx+108], eax

; 2169 : 						sfdat->fmt.SubFormat.Data2 = (WORD) REVWBYTES(sfdat->fmt.SubFormat.Data2);

  00672	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0067a	0f b7 40 70	 movzx	 eax, WORD PTR [rax+112]
  0067e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00683	c1 e0 08	 shl	 eax, 8
  00686	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0068e	0f b7 49 70	 movzx	 ecx, WORD PTR [rcx+112]
  00692	c1 f9 08	 sar	 ecx, 8
  00695	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0069b	0b c1		 or	 eax, ecx
  0069d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  006a5	66 89 41 70	 mov	 WORD PTR [rcx+112], ax

; 2170 : 						sfdat->fmt.SubFormat.Data3 = (WORD) REVWBYTES(sfdat->fmt.SubFormat.Data3);	

  006a9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  006b1	0f b7 40 72	 movzx	 eax, WORD PTR [rax+114]
  006b5	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006ba	c1 e0 08	 shl	 eax, 8
  006bd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  006c5	0f b7 49 72	 movzx	 ecx, WORD PTR [rcx+114]
  006c9	c1 f9 08	 sar	 ecx, 8
  006cc	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  006d2	0b c1		 or	 eax, ecx
  006d4	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  006dc	66 89 41 72	 mov	 WORD PTR [rcx+114], ax
$LN57@wavReadHea:

; 2171 : 					}
; 2172 : 					/* if we get a good GUID, this sets up sfdat with samplesize info */
; 2173 : 					if(check_guid(sfdat))											

  006e0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  006e8	e8 00 00 00 00	 call	 check_guid
  006ed	85 c0		 test	 eax, eax
  006ef	74 0a		 je	 SHORT $LN58@wavReadHea

; 2174 : 						return PSF_E_UNSUPPORTED;

  006f1	b8 f8 ff ff ff	 mov	 eax, -8
  006f6	e9 c8 05 00 00	 jmp	 $LN1@wavReadHea
$LN58@wavReadHea:
$LN51@wavReadHea:
$LN40@wavReadHea:

; 2175 : 				}
; 2176 : 			}			
; 2177 : 			break;

  006fb	e9 be 05 00 00	 jmp	 $LN5@wavReadHea
$LN59@wavReadHea:

; 2178 : 		case(TAG('P','E','A','K')):	
; 2179 :             /* I SHOULD  report an error if this is after data chunk; 
; 2180 :                but I suppose innocent users (e.g. of Cubase ) will grumble... */
; 2181 :             if(wavDoRead(sfdat,(char  *) &version,sizeof(DWORD)))

  00700	41 b8 04 00 00
	00		 mov	 r8d, 4
  00706	48 8d 54 24 30	 lea	 rdx, QWORD PTR version$[rsp]
  0070b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00713	e8 00 00 00 00	 call	 wavDoRead
  00718	85 c0		 test	 eax, eax
  0071a	74 0a		 je	 SHORT $LN60@wavReadHea

; 2182 : 				return PSF_E_CANT_READ;

  0071c	b8 fc ff ff ff	 mov	 eax, -4
  00721	e9 9d 05 00 00	 jmp	 $LN1@wavReadHea
$LN60@wavReadHea:

; 2183 :             if(!sfdat->is_little_endian)				

  00726	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0072e	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00732	75 3d		 jne	 SHORT $LN61@wavReadHea

; 2184 : 				version = REVDWBYTES(version);		            

  00734	8b 44 24 30	 mov	 eax, DWORD PTR version$[rsp]
  00738	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0073d	c1 e0 18	 shl	 eax, 24
  00740	8b 4c 24 30	 mov	 ecx, DWORD PTR version$[rsp]
  00744	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  0074a	c1 e1 08	 shl	 ecx, 8
  0074d	0b c1		 or	 eax, ecx
  0074f	8b 4c 24 30	 mov	 ecx, DWORD PTR version$[rsp]
  00753	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00759	c1 e9 08	 shr	 ecx, 8
  0075c	0b c1		 or	 eax, ecx
  0075e	8b 4c 24 30	 mov	 ecx, DWORD PTR version$[rsp]
  00762	c1 e9 18	 shr	 ecx, 24
  00765	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0076b	0b c1		 or	 eax, ecx
  0076d	89 44 24 30	 mov	 DWORD PTR version$[rsp], eax
$LN61@wavReadHea:

; 2185 :             if(version != 1) {

  00771	83 7c 24 30 01	 cmp	 DWORD PTR version$[rsp], 1
  00776	74 0a		 je	 SHORT $LN62@wavReadHea

; 2186 :                 DBGFPRINTF((stderr, "Unexpected version level for PEAK chunk!\n"));
; 2187 : 					return PSF_E_UNSUPPORTED;

  00778	b8 f8 ff ff ff	 mov	 eax, -8
  0077d	e9 41 05 00 00	 jmp	 $LN1@wavReadHea
$LN62@wavReadHea:

; 2188 :             }
; 2189 :             if(size != (2 * sizeof(DWORD) + sizeof(PSF_CHPEAK) * sfdat->fmt.Format.nChannels)) {

  00782	8b 44 24 24	 mov	 eax, DWORD PTR size$[rsp]
  00786	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0078e	0f b7 49 52	 movzx	 ecx, WORD PTR [rcx+82]
  00792	48 8d 0c cd 08
	00 00 00	 lea	 rcx, QWORD PTR [rcx*8+8]
  0079a	48 3b c1	 cmp	 rax, rcx
  0079d	74 0a		 je	 SHORT $LN63@wavReadHea

; 2190 :                 DBGFPRINTF((stderr, "\nBad size for PEAK chunk\n"));
; 2191 : 				return PSF_E_BAD_FORMAT;

  0079f	b8 f9 ff ff ff	 mov	 eax, -7
  007a4	e9 1a 05 00 00	 jmp	 $LN1@wavReadHea
$LN63@wavReadHea:

; 2192 :             }
; 2193 : 			if(fgetpos(sfdat->file,&bytepos))

  007a9	48 8d 54 24 68	 lea	 rdx, QWORD PTR bytepos$[rsp]
  007ae	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  007b6	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  007b9	e8 00 00 00 00	 call	 fgetpos
  007be	85 c0		 test	 eax, eax
  007c0	74 0a		 je	 SHORT $LN64@wavReadHea

; 2194 : 			    return PSF_E_CANT_SEEK;

  007c2	b8 f5 ff ff ff	 mov	 eax, -11
  007c7	e9 f7 04 00 00	 jmp	 $LN1@wavReadHea
$LN64@wavReadHea:

; 2195 : 			sfdat->peakoffset = bytepos;

  007cc	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  007d4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bytepos$[rsp]
  007d9	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 2196 :             if(wavDoRead(sfdat,(char *) &peaktime,sizeof(DWORD))){				

  007dd	41 b8 04 00 00
	00		 mov	 r8d, 4
  007e3	48 8d 54 24 34	 lea	 rdx, QWORD PTR peaktime$[rsp]
  007e8	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  007f0	e8 00 00 00 00	 call	 wavDoRead
  007f5	85 c0		 test	 eax, eax
  007f7	74 0a		 je	 SHORT $LN65@wavReadHea

; 2197 : 			    DBGFPRINTF((stderr,"Error reading PEAK time\n"));
; 2198 :                 return PSF_E_CANT_READ;

  007f9	b8 fc ff ff ff	 mov	 eax, -4
  007fe	e9 c0 04 00 00	 jmp	 $LN1@wavReadHea
$LN65@wavReadHea:

; 2199 :             }
; 2200 :             if(!sfdat->is_little_endian)

  00803	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0080b	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0080f	75 3d		 jne	 SHORT $LN66@wavReadHea

; 2201 :                 peaktime = REVDWBYTES(peaktime);

  00811	8b 44 24 34	 mov	 eax, DWORD PTR peaktime$[rsp]
  00815	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0081a	c1 e0 18	 shl	 eax, 24
  0081d	8b 4c 24 34	 mov	 ecx, DWORD PTR peaktime$[rsp]
  00821	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00827	c1 e1 08	 shl	 ecx, 8
  0082a	0b c1		 or	 eax, ecx
  0082c	8b 4c 24 34	 mov	 ecx, DWORD PTR peaktime$[rsp]
  00830	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00836	c1 e9 08	 shr	 ecx, 8
  00839	0b c1		 or	 eax, ecx
  0083b	8b 4c 24 34	 mov	 ecx, DWORD PTR peaktime$[rsp]
  0083f	c1 e9 18	 shr	 ecx, 24
  00842	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00848	0b c1		 or	 eax, ecx
  0084a	89 44 24 34	 mov	 DWORD PTR peaktime$[rsp], eax
$LN66@wavReadHea:

; 2202 :             sfdat->peaktime = (time_t) peaktime;

  0084e	8b 44 24 34	 mov	 eax, DWORD PTR peaktime$[rsp]
  00852	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0085a	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 2203 :             sfdat->pPeaks = (PSF_CHPEAK *) malloc(sizeof(PSF_CHPEAK) * sfdat->fmt.Format.nChannels);

  00861	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00869	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  0086d	48 c1 e0 03	 shl	 rax, 3
  00871	48 8b c8	 mov	 rcx, rax
  00874	e8 00 00 00 00	 call	 malloc
  00879	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00881	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 2204 : 			if(sfdat->pPeaks==NULL){

  00888	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00890	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00898	75 0a		 jne	 SHORT $LN67@wavReadHea

; 2205 : 				DBGFPRINTF((stderr, "wavOpenWrite: no memory for peak data\n"));
; 2206 : 				return PSF_E_NOMEM;

  0089a	b8 f7 ff ff ff	 mov	 eax, -9
  0089f	e9 1f 04 00 00	 jmp	 $LN1@wavReadHea
$LN67@wavReadHea:

; 2207 : 			}
; 2208 :             if(wavDoRead(sfdat,(char *) sfdat->pPeaks,sizeof(PSF_CHPEAK) * sfdat->fmt.Format.nChannels)) {

  008a4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  008ac	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  008b0	48 c1 e0 03	 shl	 rax, 3
  008b4	44 8b c0	 mov	 r8d, eax
  008b7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  008bf	48 8b 90 80 00
	00 00		 mov	 rdx, QWORD PTR [rax+128]
  008c6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  008ce	e8 00 00 00 00	 call	 wavDoRead
  008d3	85 c0		 test	 eax, eax
  008d5	74 0a		 je	 SHORT $LN68@wavReadHea

; 2209 :                 DBGFPRINTF((stderr,"Error reading PEAK peak data\n"));
; 2210 : 				return PSF_E_CANT_READ;

  008d7	b8 fc ff ff ff	 mov	 eax, -4
  008dc	e9 e2 03 00 00	 jmp	 $LN1@wavReadHea
$LN68@wavReadHea:

; 2211 :             }
; 2212 : 			if(!sfdat->is_little_endian){

  008e1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  008e9	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  008ed	0f 85 ab 00 00
	00		 jne	 $LN69@wavReadHea

; 2213 :                 DWORD *pBlock;
; 2214 : 				int i;			
; 2215 : 				pBlock = (DWORD *) (sfdat->pPeaks);

  008f3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  008fb	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00902	48 89 44 24 60	 mov	 QWORD PTR pBlock$8[rsp], rax

; 2216 : 				for(i=0;i < sfdat->fmt.Format.nChannels * 2; i++)

  00907	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  0090f	eb 0a		 jmp	 SHORT $LN11@wavReadHea
$LN9@wavReadHea:
  00911	8b 44 24 2c	 mov	 eax, DWORD PTR i$1[rsp]
  00915	ff c0		 inc	 eax
  00917	89 44 24 2c	 mov	 DWORD PTR i$1[rsp], eax
$LN11@wavReadHea:
  0091b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00923	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  00927	d1 e0		 shl	 eax, 1
  00929	39 44 24 2c	 cmp	 DWORD PTR i$1[rsp], eax
  0092d	7d 6f		 jge	 SHORT $LN10@wavReadHea

; 2217 : 					pBlock[i] = REVDWBYTES(pBlock[i]);

  0092f	48 63 44 24 2c	 movsxd	 rax, DWORD PTR i$1[rsp]
  00934	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pBlock$8[rsp]
  00939	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0093c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00941	c1 e0 18	 shl	 eax, 24
  00944	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00949	48 8b 54 24 60	 mov	 rdx, QWORD PTR pBlock$8[rsp]
  0094e	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  00951	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00957	c1 e1 08	 shl	 ecx, 8
  0095a	0b c1		 or	 eax, ecx
  0095c	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00961	48 8b 54 24 60	 mov	 rdx, QWORD PTR pBlock$8[rsp]
  00966	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  00969	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  0096f	c1 e9 08	 shr	 ecx, 8
  00972	0b c1		 or	 eax, ecx
  00974	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00979	48 8b 54 24 60	 mov	 rdx, QWORD PTR pBlock$8[rsp]
  0097e	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  00981	c1 e9 18	 shr	 ecx, 24
  00984	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0098a	0b c1		 or	 eax, ecx
  0098c	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00991	48 8b 54 24 60	 mov	 rdx, QWORD PTR pBlock$8[rsp]
  00996	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  00999	e9 73 ff ff ff	 jmp	 $LN9@wavReadHea
$LN10@wavReadHea:
$LN69@wavReadHea:

; 2218 : 			}            
; 2219 : 			break;

  0099e	e9 1b 03 00 00	 jmp	 $LN5@wavReadHea
$LN70@wavReadHea:

; 2220 : 		case(TAG('d','a','t','a')):
; 2221 : 			if(fgetpos(sfdat->file,&bytepos))

  009a3	48 8d 54 24 68	 lea	 rdx, QWORD PTR bytepos$[rsp]
  009a8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  009b0	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  009b3	e8 00 00 00 00	 call	 fgetpos
  009b8	85 c0		 test	 eax, eax
  009ba	74 0a		 je	 SHORT $LN71@wavReadHea

; 2222 : 			    return PSF_E_CANT_SEEK;

  009bc	b8 f5 ff ff ff	 mov	 eax, -11
  009c1	e9 fd 02 00 00	 jmp	 $LN1@wavReadHea
$LN71@wavReadHea:

; 2223 : 			sfdat->dataoffset = bytepos;

  009c6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  009ce	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bytepos$[rsp]
  009d3	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 2224 : 			if(POS64(sfdat->fmtoffset)==0)

  009d7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  009df	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  009e4	75 0a		 jne	 SHORT $LN72@wavReadHea

; 2225 : 				return PSF_E_BAD_FORMAT;

  009e6	b8 f9 ff ff ff	 mov	 eax, -7
  009eb	e9 d3 02 00 00	 jmp	 $LN1@wavReadHea
$LN72@wavReadHea:

; 2226 : 			sfdat->nFrames = size / sfdat->fmt.Format.nBlockAlign;			

  009f0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  009f8	0f b7 40 5c	 movzx	 eax, WORD PTR [rax+92]
  009fc	89 44 24 70	 mov	 DWORD PTR tv462[rsp], eax
  00a00	33 d2		 xor	 edx, edx
  00a02	8b 44 24 24	 mov	 eax, DWORD PTR size$[rsp]
  00a06	8b 4c 24 70	 mov	 ecx, DWORD PTR tv462[rsp]
  00a0a	f7 f1		 div	 ecx
  00a0c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00a14	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 2227 : 			/* get rescale factor if available */
; 2228 : 			/* NB in correct format, val is always >= 0.0 */
; 2229 : 			if(sfdat->pPeaks && POS64(sfdat->peakoffset) != 0){

  00a17	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00a1f	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00a27	0f 84 cb 00 00
	00		 je	 $LN73@wavReadHea
  00a2d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00a35	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  00a3a	0f 84 b8 00 00
	00		 je	 $LN73@wavReadHea

; 2230 : 				float fac = 0.0f;

  00a40	0f 57 c0	 xorps	 xmm0, xmm0
  00a43	f3 0f 11 44 24
	44		 movss	 DWORD PTR fac$5[rsp], xmm0

; 2231 : 				int i;
; 2232 : 				for(i=0;i < sfdat->fmt.Format.nChannels; i++)

  00a49	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$4[rsp], 0
  00a51	eb 0a		 jmp	 SHORT $LN14@wavReadHea
$LN12@wavReadHea:
  00a53	8b 44 24 40	 mov	 eax, DWORD PTR i$4[rsp]
  00a57	ff c0		 inc	 eax
  00a59	89 44 24 40	 mov	 DWORD PTR i$4[rsp], eax
$LN14@wavReadHea:
  00a5d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00a65	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  00a69	39 44 24 40	 cmp	 DWORD PTR i$4[rsp], eax
  00a6d	7d 5f		 jge	 SHORT $LN13@wavReadHea

; 2233 : 					fac = max(fac,sfdat->pPeaks[i].val);

  00a6f	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$4[rsp]
  00a74	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00a7c	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00a83	f3 0f 10 04 c1	 movss	 xmm0, DWORD PTR [rcx+rax*8]
  00a88	f3 0f 10 4c 24
	44		 movss	 xmm1, DWORD PTR fac$5[rsp]
  00a8e	0f 2f c8	 comiss	 xmm1, xmm0
  00a91	76 0e		 jbe	 SHORT $LN92@wavReadHea
  00a93	f3 0f 10 44 24
	44		 movss	 xmm0, DWORD PTR fac$5[rsp]
  00a99	f3 0f 11 44 24
	5c		 movss	 DWORD PTR tv485[rsp], xmm0
  00a9f	eb 1f		 jmp	 SHORT $LN93@wavReadHea
$LN92@wavReadHea:
  00aa1	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$4[rsp]
  00aa6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00aae	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00ab5	f3 0f 10 04 c1	 movss	 xmm0, DWORD PTR [rcx+rax*8]
  00aba	f3 0f 11 44 24
	5c		 movss	 DWORD PTR tv485[rsp], xmm0
$LN93@wavReadHea:
  00ac0	f3 0f 10 44 24
	5c		 movss	 xmm0, DWORD PTR tv485[rsp]
  00ac6	f3 0f 11 44 24
	44		 movss	 DWORD PTR fac$5[rsp], xmm0
  00acc	eb 85		 jmp	 SHORT $LN12@wavReadHea
$LN13@wavReadHea:

; 2234 : 				if(fac > 1.0f)

  00ace	f3 0f 10 44 24
	44		 movss	 xmm0, DWORD PTR fac$5[rsp]
  00ad4	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00adb	76 1b		 jbe	 SHORT $LN74@wavReadHea

; 2235 : 					sfdat->rescale_fac = 1.0f / fac;

  00add	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00ae5	f3 0f 5e 44 24
	44		 divss	 xmm0, DWORD PTR fac$5[rsp]
  00aeb	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00af3	f3 0f 11 40 24	 movss	 DWORD PTR [rax+36], xmm0
$LN74@wavReadHea:
$LN73@wavReadHea:

; 2236 : 			}
; 2237 : 			/* set sampletype */
; 2238 : 			switch(sfdat->fmt.Format.wFormatTag){

  00af8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00b00	0f b7 40 50	 movzx	 eax, WORD PTR [rax+80]
  00b04	89 44 24 58	 mov	 DWORD PTR tv491[rsp], eax
  00b08	83 7c 24 58 01	 cmp	 DWORD PTR tv491[rsp], 1
  00b0d	74 77		 je	 SHORT $LN79@wavReadHea
  00b0f	83 7c 24 58 03	 cmp	 DWORD PTR tv491[rsp], 3
  00b14	74 0f		 je	 SHORT $LN75@wavReadHea
  00b16	81 7c 24 58 fe
	ff 00 00	 cmp	 DWORD PTR tv491[rsp], 65534 ; 0000fffeH
  00b1e	74 66		 je	 SHORT $LN79@wavReadHea
  00b20	e9 74 01 00 00	 jmp	 $LN15@wavReadHea
$LN75@wavReadHea:

; 2239 : 			case(WAVE_FORMAT_IEEE_FLOAT):
; 2240 : 				sfdat->samptype = PSF_SAMP_IEEE_FLOAT;

  00b25	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00b2d	c7 40 30 05 00
	00 00		 mov	 DWORD PTR [rax+48], 5

; 2241 : 				if(sfdat->fmt.Format.wBitsPerSample != 32) {

  00b34	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00b3c	0f b7 40 5e	 movzx	 eax, WORD PTR [rax+94]
  00b40	83 f8 20	 cmp	 eax, 32			; 00000020H
  00b43	74 28		 je	 SHORT $LN76@wavReadHea

; 2242 : 					/*return PSF_E_BAD_FORMAT;*/
; 2243 : 					if(sfdat->fmt.Format.wBitsPerSample == sizeof(double))

  00b45	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00b4d	0f b7 40 5e	 movzx	 eax, WORD PTR [rax+94]
  00b51	48 83 f8 08	 cmp	 rax, 8
  00b55	75 0c		 jne	 SHORT $LN77@wavReadHea

; 2244 : 						return PSF_E_UNSUPPORTED;			

  00b57	b8 f8 ff ff ff	 mov	 eax, -8
  00b5c	e9 62 01 00 00	 jmp	 $LN1@wavReadHea
  00b61	eb 0a		 jmp	 SHORT $LN78@wavReadHea
$LN77@wavReadHea:

; 2245 : 					else
; 2246 : 					    return PSF_E_BAD_FORMAT;

  00b63	b8 f9 ff ff ff	 mov	 eax, -7
  00b68	e9 56 01 00 00	 jmp	 $LN1@wavReadHea
$LN78@wavReadHea:
$LN76@wavReadHea:

; 2247 : 				}
; 2248 : 				sfdat->lastop  = PSF_OP_READ;

  00b6d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00b75	c7 80 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+152], 0

; 2249 : 				return PSF_E_NOERROR;

  00b7f	33 c0		 xor	 eax, eax
  00b81	e9 3d 01 00 00	 jmp	 $LN1@wavReadHea
$LN79@wavReadHea:

; 2250 : 			case(WAVE_FORMAT_PCM):
; 2251 : 			case(WAVE_FORMAT_EXTENSIBLE):
; 2252 : 				switch(sfdat->fmt.Format.wBitsPerSample){

  00b86	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00b8e	0f b7 40 5e	 movzx	 eax, WORD PTR [rax+94]
  00b92	89 44 24 48	 mov	 DWORD PTR tv502[rsp], eax
  00b96	83 7c 24 48 08	 cmp	 DWORD PTR tv502[rsp], 8
  00b9b	74 1a		 je	 SHORT $LN80@wavReadHea
  00b9d	83 7c 24 48 10	 cmp	 DWORD PTR tv502[rsp], 16
  00ba2	74 27		 je	 SHORT $LN81@wavReadHea
  00ba4	83 7c 24 48 18	 cmp	 DWORD PTR tv502[rsp], 24
  00ba9	74 34		 je	 SHORT $LN82@wavReadHea
  00bab	83 7c 24 48 20	 cmp	 DWORD PTR tv502[rsp], 32 ; 00000020H
  00bb0	74 3e		 je	 SHORT $LN83@wavReadHea
  00bb2	e9 a8 00 00 00	 jmp	 $LN87@wavReadHea
$LN80@wavReadHea:

; 2253 : 				case(8):
; 2254 : 					sfdat->samptype = PSF_SAMP_8;

  00bb7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00bbf	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [rax+48], 1

; 2255 : 					break;

  00bc6	e9 a3 00 00 00	 jmp	 $LN17@wavReadHea
$LN81@wavReadHea:

; 2256 : 				case(16):
; 2257 : 					sfdat->samptype = PSF_SAMP_16;

  00bcb	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00bd3	c7 40 30 02 00
	00 00		 mov	 DWORD PTR [rax+48], 2

; 2258 : 					break;

  00bda	e9 8f 00 00 00	 jmp	 $LN17@wavReadHea
$LN82@wavReadHea:

; 2259 : 				case(24):
; 2260 : 					sfdat->samptype = PSF_SAMP_24;

  00bdf	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00be7	c7 40 30 03 00
	00 00		 mov	 DWORD PTR [rax+48], 3

; 2261 : 					break;

  00bee	eb 7e		 jmp	 SHORT $LN17@wavReadHea
$LN83@wavReadHea:

; 2262 : 				case(32):
; 2263 : 					sfdat->samptype = PSF_SAMP_32;

  00bf0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00bf8	c7 40 30 04 00
	00 00		 mov	 DWORD PTR [rax+48], 4

; 2264 : 					if(compare_guids(&(sfdat->fmt.SubFormat),&KSDATAFORMAT_SUBTYPE_IEEE_FLOAT))

  00bff	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00c07	48 83 c0 6c	 add	 rax, 108		; 0000006cH
  00c0b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:KSDATAFORMAT_SUBTYPE_IEEE_FLOAT
  00c12	48 8b c8	 mov	 rcx, rax
  00c15	e8 00 00 00 00	 call	 compare_guids
  00c1a	85 c0		 test	 eax, eax
  00c1c	74 11		 je	 SHORT $LN84@wavReadHea

; 2265 : 						sfdat->samptype = PSF_SAMP_IEEE_FLOAT;

  00c1e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00c26	c7 40 30 05 00
	00 00		 mov	 DWORD PTR [rax+48], 5
  00c2d	eb 2e		 jmp	 SHORT $LN85@wavReadHea
$LN84@wavReadHea:

; 2266 : 					else if(!compare_guids(&(sfdat->fmt.SubFormat),&KSDATAFORMAT_SUBTYPE_PCM))

  00c2f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00c37	48 83 c0 6c	 add	 rax, 108		; 0000006cH
  00c3b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:KSDATAFORMAT_SUBTYPE_PCM
  00c42	48 8b c8	 mov	 rcx, rax
  00c45	e8 00 00 00 00	 call	 compare_guids
  00c4a	85 c0		 test	 eax, eax
  00c4c	75 0f		 jne	 SHORT $LN86@wavReadHea

; 2267 : 						sfdat->samptype = PSF_SAMP_UNKNOWN;

  00c4e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00c56	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
$LN86@wavReadHea:
$LN85@wavReadHea:

; 2268 : 					break;

  00c5d	eb 0f		 jmp	 SHORT $LN17@wavReadHea
$LN87@wavReadHea:

; 2269 : 				default:
; 2270 : 					sfdat->samptype = PSF_SAMP_UNKNOWN;

  00c5f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00c67	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
$LN17@wavReadHea:

; 2271 : 					break;					
; 2272 : 				}				
; 2273 : 				if(sfdat->samptype == PSF_SAMP_UNKNOWN)

  00c6e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00c76	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00c7a	75 07		 jne	 SHORT $LN88@wavReadHea

; 2274 : 					return PSF_E_UNSUPPORTED;

  00c7c	b8 f8 ff ff ff	 mov	 eax, -8
  00c81	eb 40		 jmp	 SHORT $LN1@wavReadHea
$LN88@wavReadHea:

; 2275 : 				sfdat->lastop  = PSF_OP_READ;

  00c83	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00c8b	c7 80 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+152], 0

; 2276 : 				return PSF_E_NOERROR;

  00c95	33 c0		 xor	 eax, eax
  00c97	eb 2a		 jmp	 SHORT $LN1@wavReadHea
$LN15@wavReadHea:
$LN89@wavReadHea:

; 2277 : 			}					
; 2278 : 			default:
; 2279 : 			/* unknown chunk - skip */
; 2280 : 			if(fseek(sfdat->file,size,SEEK_CUR))

  00c99	41 b8 01 00 00
	00		 mov	 r8d, 1
  00c9f	8b 54 24 24	 mov	 edx, DWORD PTR size$[rsp]
  00ca3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00cab	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00cae	e8 00 00 00 00	 call	 fseek
  00cb3	85 c0		 test	 eax, eax
  00cb5	74 07		 je	 SHORT $LN90@wavReadHea

; 2281 : 				return PSF_E_CANT_READ;

  00cb7	b8 fc ff ff ff	 mov	 eax, -4
  00cbc	eb 05		 jmp	 SHORT $LN1@wavReadHea
$LN90@wavReadHea:
$LN5@wavReadHea:

; 2282 : 			break;
; 2283 : 		}
; 2284 : 	}

  00cbe	e9 e5 f4 ff ff	 jmp	 $LN2@wavReadHea
$LN1@wavReadHea:

; 2285 : }

  00cc3	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00cca	c3		 ret	 0
wavReadHeader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
tag$ = 32
size$ = 36
wData$ = 40
ID_compression$ = 44
aifcver$ = 48
version$1 = 52
pstring_size$ = 56
offset$ = 60
blocksize$ = 64
bytepos$ = 72
dwData$ = 80
now$2 = 84
str_compressed$ = 88
peaks$ = 96
ieee$ = 104
__$ArrayPad$ = 120
sfdat$ = 144
aifcWriteHeader PROC

; 1207 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 44 24 78	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1208 : 	DWORD tag,size;		
; 1209 : 	PSF_CHPEAK *peaks;	
; 1210 : 	DWORD dwData,offset,blocksize,aifcver = AIFC_VERSION_1,ID_compression;

  0001b	c7 44 24 30 40
	51 80 a2	 mov	 DWORD PTR aifcver$[rsp], -1568648896 ; a2805140H

; 1211 : 	/*assume 32bit floats, but we may be asked to use aifc for integer formats too*/
; 1212 : 	char *str_compressed = (char *) aifc_floatstring;

  00023	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:aifc_floatstring
  0002a	48 89 44 24 58	 mov	 QWORD PTR str_compressed$[rsp], rax

; 1213 : 	int pstring_size = 10;

  0002f	c7 44 24 38 0a
	00 00 00	 mov	 DWORD PTR pstring_size$[rsp], 10

; 1214 : 	unsigned char ieee[10];
; 1215 : 	WORD wData;
; 1216 : 	fpos_t bytepos;
; 1217 : 
; 1218 : #ifdef _DEBUG
; 1219 : 	assert(sfdat);
; 1220 : 	assert(sfdat->file);
; 1221 : 	assert(sfdat->nFrames==0);
; 1222 : 	assert(!sfdat->isRead);
; 1223 : 	assert(sfdat->riff_format == PSF_AIFC);
; 1224 : 	assert(sfdat->fmt.Format.nChannels != 0);
; 1225 : #endif
; 1226 : 
; 1227 : 	if(sfdat->samptype==PSF_SAMP_IEEE_FLOAT)

  00037	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0003f	83 78 30 05	 cmp	 DWORD PTR [rax+48], 5
  00043	75 0a		 jne	 SHORT $LN2@aifcWriteH

; 1228 : 		ID_compression = TAG('f','l','3','2');

  00045	c7 44 24 2c 32
	33 6c 66	 mov	 DWORD PTR ID_compression$[rsp], 1718367026 ; 666c3332H
  0004d	eb 1c		 jmp	 SHORT $LN3@aifcWriteH
$LN2@aifcWriteH:

; 1229 : 	else {
; 1230 : 		ID_compression = TAG('N','O','N','E');

  0004f	c7 44 24 2c 45
	4e 4f 4e	 mov	 DWORD PTR ID_compression$[rsp], 1313820229 ; 4e4f4e45H

; 1231 : 		pstring_size = 16;

  00057	c7 44 24 38 10
	00 00 00	 mov	 DWORD PTR pstring_size$[rsp], 16

; 1232 : 		str_compressed = (char *) aifc_notcompressed;

  0005f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:aifc_notcompressed
  00066	48 89 44 24 58	 mov	 QWORD PTR str_compressed$[rsp], rax
$LN3@aifcWriteH:

; 1233 : 	}
; 1234 : 	/*clear pPeaks array*/
; 1235 : 	if(sfdat->pPeaks)

  0006b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00073	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  0007b	74 29		 je	 SHORT $LN4@aifcWriteH

; 1236 : 		memset((char *)sfdat->pPeaks,0,sizeof(PSF_CHPEAK) * sfdat->fmt.Format.nChannels);

  0007d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00085	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  00089	48 c1 e0 03	 shl	 rax, 3
  0008d	4c 8b c0	 mov	 r8, rax
  00090	33 d2		 xor	 edx, edx
  00092	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0009a	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  000a1	e8 00 00 00 00	 call	 memset
$LN4@aifcWriteH:

; 1237 : 
; 1238 : 	tag = TAG('F','O','R','M');

  000a6	c7 44 24 20 4d
	52 4f 46	 mov	 DWORD PTR tag$[rsp], 1179603533 ; 464f524dH

; 1239 : 	size = 0;

  000ae	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR size$[rsp], 0

; 1240 : 
; 1241 : 	if(sfdat->is_little_endian) {

  000b6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  000be	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  000c2	74 7a		 je	 SHORT $LN5@aifcWriteH

; 1242 : 		size = REVDWBYTES(size);	

  000c4	8b 44 24 24	 mov	 eax, DWORD PTR size$[rsp]
  000c8	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000cd	c1 e0 18	 shl	 eax, 24
  000d0	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  000d4	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  000da	c1 e1 08	 shl	 ecx, 8
  000dd	0b c1		 or	 eax, ecx
  000df	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  000e3	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  000e9	c1 e9 08	 shr	 ecx, 8
  000ec	0b c1		 or	 eax, ecx
  000ee	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  000f2	c1 e9 18	 shr	 ecx, 24
  000f5	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000fb	0b c1		 or	 eax, ecx
  000fd	89 44 24 24	 mov	 DWORD PTR size$[rsp], eax

; 1243 : 		tag = REVDWBYTES(tag);

  00101	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  00105	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0010a	c1 e0 18	 shl	 eax, 24
  0010d	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00111	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00117	c1 e1 08	 shl	 ecx, 8
  0011a	0b c1		 or	 eax, ecx
  0011c	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00120	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00126	c1 e9 08	 shr	 ecx, 8
  00129	0b c1		 or	 eax, ecx
  0012b	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  0012f	c1 e9 18	 shr	 ecx, 24
  00132	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00138	0b c1		 or	 eax, ecx
  0013a	89 44 24 20	 mov	 DWORD PTR tag$[rsp], eax
$LN5@aifcWriteH:

; 1244 : 	}
; 1245 : 	if(wavDoWrite(sfdat,(char *)&tag,sizeof(DWORD))
; 1246 : 		|| wavDoWrite(sfdat,(char *)&size,sizeof(DWORD)))

  0013e	41 b8 04 00 00
	00		 mov	 r8d, 4
  00144	48 8d 54 24 20	 lea	 rdx, QWORD PTR tag$[rsp]
  00149	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00151	e8 00 00 00 00	 call	 wavDoWrite
  00156	85 c0		 test	 eax, eax
  00158	75 1c		 jne	 SHORT $LN7@aifcWriteH
  0015a	41 b8 04 00 00
	00		 mov	 r8d, 4
  00160	48 8d 54 24 24	 lea	 rdx, QWORD PTR size$[rsp]
  00165	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0016d	e8 00 00 00 00	 call	 wavDoWrite
  00172	85 c0		 test	 eax, eax
  00174	74 0a		 je	 SHORT $LN6@aifcWriteH
$LN7@aifcWriteH:

; 1247 : 		return PSF_E_CANT_WRITE;

  00176	b8 fd ff ff ff	 mov	 eax, -3
  0017b	e9 ac 07 00 00	 jmp	 $LN1@aifcWriteH
$LN6@aifcWriteH:

; 1248 : 	tag = TAG('A','I','F','C');

  00180	c7 44 24 20 43
	46 49 41	 mov	 DWORD PTR tag$[rsp], 1095321155 ; 41494643H

; 1249 : 	if(sfdat->is_little_endian)

  00188	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00190	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00194	74 3d		 je	 SHORT $LN8@aifcWriteH

; 1250 : 		tag = REVDWBYTES(tag);

  00196	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  0019a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0019f	c1 e0 18	 shl	 eax, 24
  001a2	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  001a6	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  001ac	c1 e1 08	 shl	 ecx, 8
  001af	0b c1		 or	 eax, ecx
  001b1	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  001b5	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  001bb	c1 e9 08	 shr	 ecx, 8
  001be	0b c1		 or	 eax, ecx
  001c0	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  001c4	c1 e9 18	 shr	 ecx, 24
  001c7	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  001cd	0b c1		 or	 eax, ecx
  001cf	89 44 24 20	 mov	 DWORD PTR tag$[rsp], eax
$LN8@aifcWriteH:

; 1251 : 	if(wavDoWrite(sfdat,(char *)&tag,sizeof(DWORD)))

  001d3	41 b8 04 00 00
	00		 mov	 r8d, 4
  001d9	48 8d 54 24 20	 lea	 rdx, QWORD PTR tag$[rsp]
  001de	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  001e6	e8 00 00 00 00	 call	 wavDoWrite
  001eb	85 c0		 test	 eax, eax
  001ed	74 0a		 je	 SHORT $LN9@aifcWriteH

; 1252 : 		return PSF_E_CANT_WRITE;

  001ef	b8 fd ff ff ff	 mov	 eax, -3
  001f4	e9 33 07 00 00	 jmp	 $LN1@aifcWriteH
$LN9@aifcWriteH:

; 1253 : 
; 1254 : 	tag = TAG('F','V','E','R');

  001f9	c7 44 24 20 52
	45 56 46	 mov	 DWORD PTR tag$[rsp], 1180058962 ; 46564552H

; 1255 : 	size = sizeof(DWORD);

  00201	c7 44 24 24 04
	00 00 00	 mov	 DWORD PTR size$[rsp], 4

; 1256 : 	if(sfdat->is_little_endian){

  00209	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00211	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00215	0f 84 b7 00 00
	00		 je	 $LN10@aifcWriteH

; 1257 : 		size = REVDWBYTES(size);	

  0021b	8b 44 24 24	 mov	 eax, DWORD PTR size$[rsp]
  0021f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00224	c1 e0 18	 shl	 eax, 24
  00227	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  0022b	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00231	c1 e1 08	 shl	 ecx, 8
  00234	0b c1		 or	 eax, ecx
  00236	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  0023a	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00240	c1 e9 08	 shr	 ecx, 8
  00243	0b c1		 or	 eax, ecx
  00245	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  00249	c1 e9 18	 shr	 ecx, 24
  0024c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00252	0b c1		 or	 eax, ecx
  00254	89 44 24 24	 mov	 DWORD PTR size$[rsp], eax

; 1258 : 		tag = REVDWBYTES(tag);

  00258	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  0025c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00261	c1 e0 18	 shl	 eax, 24
  00264	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00268	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  0026e	c1 e1 08	 shl	 ecx, 8
  00271	0b c1		 or	 eax, ecx
  00273	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00277	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  0027d	c1 e9 08	 shr	 ecx, 8
  00280	0b c1		 or	 eax, ecx
  00282	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00286	c1 e9 18	 shr	 ecx, 24
  00289	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0028f	0b c1		 or	 eax, ecx
  00291	89 44 24 20	 mov	 DWORD PTR tag$[rsp], eax

; 1259 : 		aifcver = REVDWBYTES(aifcver);

  00295	8b 44 24 30	 mov	 eax, DWORD PTR aifcver$[rsp]
  00299	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0029e	c1 e0 18	 shl	 eax, 24
  002a1	8b 4c 24 30	 mov	 ecx, DWORD PTR aifcver$[rsp]
  002a5	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  002ab	c1 e1 08	 shl	 ecx, 8
  002ae	0b c1		 or	 eax, ecx
  002b0	8b 4c 24 30	 mov	 ecx, DWORD PTR aifcver$[rsp]
  002b4	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  002ba	c1 e9 08	 shr	 ecx, 8
  002bd	0b c1		 or	 eax, ecx
  002bf	8b 4c 24 30	 mov	 ecx, DWORD PTR aifcver$[rsp]
  002c3	c1 e9 18	 shr	 ecx, 24
  002c6	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  002cc	0b c1		 or	 eax, ecx
  002ce	89 44 24 30	 mov	 DWORD PTR aifcver$[rsp], eax
$LN10@aifcWriteH:

; 1260 : 	}
; 1261 : 	if(wavDoWrite(sfdat,(char *)&tag,sizeof(DWORD))
; 1262 : 		|| wavDoWrite(sfdat,(char *)&size,sizeof(DWORD))
; 1263 : 		|| wavDoWrite(sfdat,(char *)&aifcver,sizeof(DWORD)))

  002d2	41 b8 04 00 00
	00		 mov	 r8d, 4
  002d8	48 8d 54 24 20	 lea	 rdx, QWORD PTR tag$[rsp]
  002dd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  002e5	e8 00 00 00 00	 call	 wavDoWrite
  002ea	85 c0		 test	 eax, eax
  002ec	75 38		 jne	 SHORT $LN12@aifcWriteH
  002ee	41 b8 04 00 00
	00		 mov	 r8d, 4
  002f4	48 8d 54 24 24	 lea	 rdx, QWORD PTR size$[rsp]
  002f9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00301	e8 00 00 00 00	 call	 wavDoWrite
  00306	85 c0		 test	 eax, eax
  00308	75 1c		 jne	 SHORT $LN12@aifcWriteH
  0030a	41 b8 04 00 00
	00		 mov	 r8d, 4
  00310	48 8d 54 24 30	 lea	 rdx, QWORD PTR aifcver$[rsp]
  00315	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0031d	e8 00 00 00 00	 call	 wavDoWrite
  00322	85 c0		 test	 eax, eax
  00324	74 0a		 je	 SHORT $LN11@aifcWriteH
$LN12@aifcWriteH:

; 1264 : 		return PSF_E_CANT_WRITE;

  00326	b8 fd ff ff ff	 mov	 eax, -3
  0032b	e9 fc 05 00 00	 jmp	 $LN1@aifcWriteH
$LN11@aifcWriteH:

; 1265 : 
; 1266 : 	tag = TAG('C','O','M','M');

  00330	c7 44 24 20 4d
	4d 4f 43	 mov	 DWORD PTR tag$[rsp], 1129270605 ; 434f4d4dH

; 1267 : 	size = 22 + pstring_size;

  00338	8b 44 24 38	 mov	 eax, DWORD PTR pstring_size$[rsp]
  0033c	83 c0 16	 add	 eax, 22
  0033f	89 44 24 24	 mov	 DWORD PTR size$[rsp], eax

; 1268 : 	if(sfdat->is_little_endian){

  00343	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0034b	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0034f	74 7a		 je	 SHORT $LN13@aifcWriteH

; 1269 : 		size = REVDWBYTES(size);	

  00351	8b 44 24 24	 mov	 eax, DWORD PTR size$[rsp]
  00355	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0035a	c1 e0 18	 shl	 eax, 24
  0035d	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  00361	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00367	c1 e1 08	 shl	 ecx, 8
  0036a	0b c1		 or	 eax, ecx
  0036c	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  00370	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00376	c1 e9 08	 shr	 ecx, 8
  00379	0b c1		 or	 eax, ecx
  0037b	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  0037f	c1 e9 18	 shr	 ecx, 24
  00382	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00388	0b c1		 or	 eax, ecx
  0038a	89 44 24 24	 mov	 DWORD PTR size$[rsp], eax

; 1270 : 		tag = REVDWBYTES(tag);

  0038e	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  00392	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00397	c1 e0 18	 shl	 eax, 24
  0039a	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  0039e	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  003a4	c1 e1 08	 shl	 ecx, 8
  003a7	0b c1		 or	 eax, ecx
  003a9	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  003ad	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  003b3	c1 e9 08	 shr	 ecx, 8
  003b6	0b c1		 or	 eax, ecx
  003b8	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  003bc	c1 e9 18	 shr	 ecx, 24
  003bf	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  003c5	0b c1		 or	 eax, ecx
  003c7	89 44 24 20	 mov	 DWORD PTR tag$[rsp], eax
$LN13@aifcWriteH:

; 1271 : 	}
; 1272 : 	if(wavDoWrite(sfdat,(char *)&tag,sizeof(DWORD))
; 1273 : 		|| wavDoWrite(sfdat,(char *)&size,sizeof(DWORD)))

  003cb	41 b8 04 00 00
	00		 mov	 r8d, 4
  003d1	48 8d 54 24 20	 lea	 rdx, QWORD PTR tag$[rsp]
  003d6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  003de	e8 00 00 00 00	 call	 wavDoWrite
  003e3	85 c0		 test	 eax, eax
  003e5	75 1c		 jne	 SHORT $LN15@aifcWriteH
  003e7	41 b8 04 00 00
	00		 mov	 r8d, 4
  003ed	48 8d 54 24 24	 lea	 rdx, QWORD PTR size$[rsp]
  003f2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  003fa	e8 00 00 00 00	 call	 wavDoWrite
  003ff	85 c0		 test	 eax, eax
  00401	74 0a		 je	 SHORT $LN14@aifcWriteH
$LN15@aifcWriteH:

; 1274 : 		return PSF_E_CANT_WRITE;

  00403	b8 fd ff ff ff	 mov	 eax, -3
  00408	e9 1f 05 00 00	 jmp	 $LN1@aifcWriteH
$LN14@aifcWriteH:

; 1275 : 	if(fgetpos(sfdat->file,&bytepos))

  0040d	48 8d 54 24 48	 lea	 rdx, QWORD PTR bytepos$[rsp]
  00412	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0041a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0041d	e8 00 00 00 00	 call	 fgetpos
  00422	85 c0		 test	 eax, eax
  00424	74 0a		 je	 SHORT $LN16@aifcWriteH

; 1276 : 	    return PSF_E_CANT_SEEK;

  00426	b8 f5 ff ff ff	 mov	 eax, -11
  0042b	e9 fc 04 00 00	 jmp	 $LN1@aifcWriteH
$LN16@aifcWriteH:

; 1277 : 	sfdat->fmtoffset = bytepos;

  00430	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00438	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bytepos$[rsp]
  0043d	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 1278 : 
; 1279 : 	wData = sfdat->fmt.Format.nChannels;

  00441	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00449	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  0044d	66 89 44 24 28	 mov	 WORD PTR wData$[rsp], ax

; 1280 : 	if(sfdat->is_little_endian)

  00452	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0045a	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0045e	74 22		 je	 SHORT $LN17@aifcWriteH

; 1281 : 		wData = (WORD) REVWBYTES(wData);

  00460	0f b7 44 24 28	 movzx	 eax, WORD PTR wData$[rsp]
  00465	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0046a	c1 e0 08	 shl	 eax, 8
  0046d	0f b7 4c 24 28	 movzx	 ecx, WORD PTR wData$[rsp]
  00472	c1 f9 08	 sar	 ecx, 8
  00475	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0047b	0b c1		 or	 eax, ecx
  0047d	66 89 44 24 28	 mov	 WORD PTR wData$[rsp], ax
$LN17@aifcWriteH:

; 1282 : 	if(wavDoWrite(sfdat,(char *)&wData,sizeof(WORD)))

  00482	41 b8 02 00 00
	00		 mov	 r8d, 2
  00488	48 8d 54 24 28	 lea	 rdx, QWORD PTR wData$[rsp]
  0048d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00495	e8 00 00 00 00	 call	 wavDoWrite
  0049a	85 c0		 test	 eax, eax
  0049c	74 0a		 je	 SHORT $LN18@aifcWriteH

; 1283 : 		return PSF_E_CANT_WRITE;

  0049e	b8 fd ff ff ff	 mov	 eax, -3
  004a3	e9 84 04 00 00	 jmp	 $LN1@aifcWriteH
$LN18@aifcWriteH:

; 1284 : 
; 1285 : 	dwData = 0;			/* nFrames */

  004a8	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR dwData$[rsp], 0

; 1286 : 	if(wavDoWrite(sfdat,(char *)&dwData,sizeof(DWORD)))

  004b0	41 b8 04 00 00
	00		 mov	 r8d, 4
  004b6	48 8d 54 24 50	 lea	 rdx, QWORD PTR dwData$[rsp]
  004bb	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  004c3	e8 00 00 00 00	 call	 wavDoWrite
  004c8	85 c0		 test	 eax, eax
  004ca	74 0a		 je	 SHORT $LN19@aifcWriteH

; 1287 : 		return PSF_E_CANT_WRITE;

  004cc	b8 fd ff ff ff	 mov	 eax, -3
  004d1	e9 56 04 00 00	 jmp	 $LN1@aifcWriteH
$LN19@aifcWriteH:

; 1288 : 
; 1289 : 	wData = sfdat->fmt.Format.wBitsPerSample;

  004d6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  004de	0f b7 40 5e	 movzx	 eax, WORD PTR [rax+94]
  004e2	66 89 44 24 28	 mov	 WORD PTR wData$[rsp], ax

; 1290 : 	if(sfdat->is_little_endian)

  004e7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  004ef	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  004f3	74 22		 je	 SHORT $LN20@aifcWriteH

; 1291 : 		wData = (WORD) REVWBYTES(wData);

  004f5	0f b7 44 24 28	 movzx	 eax, WORD PTR wData$[rsp]
  004fa	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004ff	c1 e0 08	 shl	 eax, 8
  00502	0f b7 4c 24 28	 movzx	 ecx, WORD PTR wData$[rsp]
  00507	c1 f9 08	 sar	 ecx, 8
  0050a	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00510	0b c1		 or	 eax, ecx
  00512	66 89 44 24 28	 mov	 WORD PTR wData$[rsp], ax
$LN20@aifcWriteH:

; 1292 : 	if(wavDoWrite(sfdat,(char *)&wData,sizeof(WORD)))

  00517	41 b8 02 00 00
	00		 mov	 r8d, 2
  0051d	48 8d 54 24 28	 lea	 rdx, QWORD PTR wData$[rsp]
  00522	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0052a	e8 00 00 00 00	 call	 wavDoWrite
  0052f	85 c0		 test	 eax, eax
  00531	74 0a		 je	 SHORT $LN21@aifcWriteH

; 1293 : 		return PSF_E_CANT_WRITE;

  00533	b8 fd ff ff ff	 mov	 eax, -3
  00538	e9 ef 03 00 00	 jmp	 $LN1@aifcWriteH
$LN21@aifcWriteH:

; 1294 : 	double_to_ieee_80((double)sfdat->fmt.Format.nSamplesPerSec,ieee);

  0053d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00545	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  00548	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  0054d	48 8d 54 24 68	 lea	 rdx, QWORD PTR ieee$[rsp]
  00552	e8 00 00 00 00	 call	 double_to_ieee_80

; 1295 : 	
; 1296 : 	if(wavDoWrite(sfdat,ieee,10))

  00557	41 b8 0a 00 00
	00		 mov	 r8d, 10
  0055d	48 8d 54 24 68	 lea	 rdx, QWORD PTR ieee$[rsp]
  00562	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0056a	e8 00 00 00 00	 call	 wavDoWrite
  0056f	85 c0		 test	 eax, eax
  00571	74 0a		 je	 SHORT $LN22@aifcWriteH

; 1297 : 		return PSF_E_CANT_WRITE;

  00573	b8 fd ff ff ff	 mov	 eax, -3
  00578	e9 af 03 00 00	 jmp	 $LN1@aifcWriteH
$LN22@aifcWriteH:

; 1298 : 	/*AIFC bits */
; 1299 : 	if(sfdat->is_little_endian)

  0057d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00585	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00589	74 3d		 je	 SHORT $LN23@aifcWriteH

; 1300 : 		ID_compression = REVDWBYTES(ID_compression);

  0058b	8b 44 24 2c	 mov	 eax, DWORD PTR ID_compression$[rsp]
  0058f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00594	c1 e0 18	 shl	 eax, 24
  00597	8b 4c 24 2c	 mov	 ecx, DWORD PTR ID_compression$[rsp]
  0059b	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  005a1	c1 e1 08	 shl	 ecx, 8
  005a4	0b c1		 or	 eax, ecx
  005a6	8b 4c 24 2c	 mov	 ecx, DWORD PTR ID_compression$[rsp]
  005aa	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  005b0	c1 e9 08	 shr	 ecx, 8
  005b3	0b c1		 or	 eax, ecx
  005b5	8b 4c 24 2c	 mov	 ecx, DWORD PTR ID_compression$[rsp]
  005b9	c1 e9 18	 shr	 ecx, 24
  005bc	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  005c2	0b c1		 or	 eax, ecx
  005c4	89 44 24 2c	 mov	 DWORD PTR ID_compression$[rsp], eax
$LN23@aifcWriteH:

; 1301 : 	if(wavDoWrite(sfdat,(char *)&ID_compression,sizeof(DWORD)))

  005c8	41 b8 04 00 00
	00		 mov	 r8d, 4
  005ce	48 8d 54 24 2c	 lea	 rdx, QWORD PTR ID_compression$[rsp]
  005d3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  005db	e8 00 00 00 00	 call	 wavDoWrite
  005e0	85 c0		 test	 eax, eax
  005e2	74 0a		 je	 SHORT $LN24@aifcWriteH

; 1302 : 		return PSF_E_CANT_WRITE;

  005e4	b8 fd ff ff ff	 mov	 eax, -3
  005e9	e9 3e 03 00 00	 jmp	 $LN1@aifcWriteH
$LN24@aifcWriteH:

; 1303 : 	if(wavDoWrite(sfdat,str_compressed,pstring_size))

  005ee	44 8b 44 24 38	 mov	 r8d, DWORD PTR pstring_size$[rsp]
  005f3	48 8b 54 24 58	 mov	 rdx, QWORD PTR str_compressed$[rsp]
  005f8	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00600	e8 00 00 00 00	 call	 wavDoWrite
  00605	85 c0		 test	 eax, eax
  00607	74 0a		 je	 SHORT $LN25@aifcWriteH

; 1304 : 		return PSF_E_CANT_WRITE;

  00609	b8 fd ff ff ff	 mov	 eax, -3
  0060e	e9 19 03 00 00	 jmp	 $LN1@aifcWriteH
$LN25@aifcWriteH:

; 1305 : 
; 1306 : 	if(sfdat->pPeaks){

  00613	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0061b	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00623	0f 84 ee 01 00
	00		 je	 $LN26@aifcWriteH

; 1307 : 		DWORD version = 1, now = 0;

  00629	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR version$1[rsp], 1
  00631	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR now$2[rsp], 0

; 1308 : 
; 1309 : 		peaks = sfdat->pPeaks;		

  00639	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00641	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00648	48 89 44 24 60	 mov	 QWORD PTR peaks$[rsp], rax

; 1310 : 		tag = TAG('P','E','A','K');		

  0064d	c7 44 24 20 4b
	41 45 50	 mov	 DWORD PTR tag$[rsp], 1346715979 ; 5045414bH

; 1311 : 		size = 2 * sizeof(DWORD) + sizeof(PSF_CHPEAK) * sfdat->fmt.Format.nChannels;

  00655	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0065d	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  00661	48 8d 04 c5 08
	00 00 00	 lea	 rax, QWORD PTR [rax*8+8]
  00669	89 44 24 24	 mov	 DWORD PTR size$[rsp], eax

; 1312 : 		if(sfdat->is_little_endian){

  0066d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00675	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00679	0f 84 b7 00 00
	00		 je	 $LN27@aifcWriteH

; 1313 : 			size = REVDWBYTES(size);

  0067f	8b 44 24 24	 mov	 eax, DWORD PTR size$[rsp]
  00683	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00688	c1 e0 18	 shl	 eax, 24
  0068b	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  0068f	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00695	c1 e1 08	 shl	 ecx, 8
  00698	0b c1		 or	 eax, ecx
  0069a	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  0069e	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  006a4	c1 e9 08	 shr	 ecx, 8
  006a7	0b c1		 or	 eax, ecx
  006a9	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  006ad	c1 e9 18	 shr	 ecx, 24
  006b0	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  006b6	0b c1		 or	 eax, ecx
  006b8	89 44 24 24	 mov	 DWORD PTR size$[rsp], eax

; 1314 : 			version  = REVDWBYTES(version);

  006bc	8b 44 24 34	 mov	 eax, DWORD PTR version$1[rsp]
  006c0	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006c5	c1 e0 18	 shl	 eax, 24
  006c8	8b 4c 24 34	 mov	 ecx, DWORD PTR version$1[rsp]
  006cc	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  006d2	c1 e1 08	 shl	 ecx, 8
  006d5	0b c1		 or	 eax, ecx
  006d7	8b 4c 24 34	 mov	 ecx, DWORD PTR version$1[rsp]
  006db	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  006e1	c1 e9 08	 shr	 ecx, 8
  006e4	0b c1		 or	 eax, ecx
  006e6	8b 4c 24 34	 mov	 ecx, DWORD PTR version$1[rsp]
  006ea	c1 e9 18	 shr	 ecx, 24
  006ed	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  006f3	0b c1		 or	 eax, ecx
  006f5	89 44 24 34	 mov	 DWORD PTR version$1[rsp], eax

; 1315 : 			tag = REVDWBYTES(tag);

  006f9	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  006fd	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00702	c1 e0 18	 shl	 eax, 24
  00705	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00709	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  0070f	c1 e1 08	 shl	 ecx, 8
  00712	0b c1		 or	 eax, ecx
  00714	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00718	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  0071e	c1 e9 08	 shr	 ecx, 8
  00721	0b c1		 or	 eax, ecx
  00723	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00727	c1 e9 18	 shr	 ecx, 24
  0072a	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00730	0b c1		 or	 eax, ecx
  00732	89 44 24 20	 mov	 DWORD PTR tag$[rsp], eax
$LN27@aifcWriteH:

; 1316 : 		}
; 1317 : 		if(wavDoWrite(sfdat,(char *)&tag,sizeof(DWORD))
; 1318 : 			|| wavDoWrite(sfdat,(char *)&size,sizeof(DWORD))
; 1319 : 			|| wavDoWrite(sfdat,(char *)&version,sizeof(DWORD)))

  00736	41 b8 04 00 00
	00		 mov	 r8d, 4
  0073c	48 8d 54 24 20	 lea	 rdx, QWORD PTR tag$[rsp]
  00741	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00749	e8 00 00 00 00	 call	 wavDoWrite
  0074e	85 c0		 test	 eax, eax
  00750	75 38		 jne	 SHORT $LN29@aifcWriteH
  00752	41 b8 04 00 00
	00		 mov	 r8d, 4
  00758	48 8d 54 24 24	 lea	 rdx, QWORD PTR size$[rsp]
  0075d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00765	e8 00 00 00 00	 call	 wavDoWrite
  0076a	85 c0		 test	 eax, eax
  0076c	75 1c		 jne	 SHORT $LN29@aifcWriteH
  0076e	41 b8 04 00 00
	00		 mov	 r8d, 4
  00774	48 8d 54 24 34	 lea	 rdx, QWORD PTR version$1[rsp]
  00779	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00781	e8 00 00 00 00	 call	 wavDoWrite
  00786	85 c0		 test	 eax, eax
  00788	74 0a		 je	 SHORT $LN28@aifcWriteH
$LN29@aifcWriteH:

; 1320 : 			return PSF_E_CANT_WRITE;

  0078a	b8 fd ff ff ff	 mov	 eax, -3
  0078f	e9 98 01 00 00	 jmp	 $LN1@aifcWriteH
$LN28@aifcWriteH:

; 1321 : 		if(fgetpos(sfdat->file,&bytepos))

  00794	48 8d 54 24 48	 lea	 rdx, QWORD PTR bytepos$[rsp]
  00799	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  007a1	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  007a4	e8 00 00 00 00	 call	 fgetpos
  007a9	85 c0		 test	 eax, eax
  007ab	74 0a		 je	 SHORT $LN30@aifcWriteH

; 1322 : 		    return PSF_E_CANT_SEEK;

  007ad	b8 f5 ff ff ff	 mov	 eax, -11
  007b2	e9 75 01 00 00	 jmp	 $LN1@aifcWriteH
$LN30@aifcWriteH:

; 1323 : 		sfdat->peakoffset = bytepos;  /*we need to update time*/

  007b7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  007bf	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bytepos$[rsp]
  007c4	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 1324 : 
; 1325 : 		if(wavDoWrite(sfdat,(char *) &now,sizeof(DWORD))
; 1326 : 			|| wavDoWrite(sfdat,(char *) peaks, sizeof(PSF_CHPEAK) * sfdat->fmt.Format.nChannels))

  007c8	41 b8 04 00 00
	00		 mov	 r8d, 4
  007ce	48 8d 54 24 54	 lea	 rdx, QWORD PTR now$2[rsp]
  007d3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  007db	e8 00 00 00 00	 call	 wavDoWrite
  007e0	85 c0		 test	 eax, eax
  007e2	75 29		 jne	 SHORT $LN32@aifcWriteH
  007e4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  007ec	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  007f0	48 c1 e0 03	 shl	 rax, 3
  007f4	44 8b c0	 mov	 r8d, eax
  007f7	48 8b 54 24 60	 mov	 rdx, QWORD PTR peaks$[rsp]
  007fc	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00804	e8 00 00 00 00	 call	 wavDoWrite
  00809	85 c0		 test	 eax, eax
  0080b	74 0a		 je	 SHORT $LN31@aifcWriteH
$LN32@aifcWriteH:

; 1327 : 			return PSF_E_CANT_WRITE;

  0080d	b8 fd ff ff ff	 mov	 eax, -3
  00812	e9 15 01 00 00	 jmp	 $LN1@aifcWriteH
$LN31@aifcWriteH:
$LN26@aifcWriteH:

; 1328 : 	}
; 1329 : 
; 1330 : 	tag = TAG('S','S','N','D');

  00817	c7 44 24 20 44
	4e 53 53	 mov	 DWORD PTR tag$[rsp], 1397968452 ; 53534e44H

; 1331 : 	size = offset = blocksize = 0;

  0081f	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR blocksize$[rsp], 0
  00827	8b 44 24 40	 mov	 eax, DWORD PTR blocksize$[rsp]
  0082b	89 44 24 3c	 mov	 DWORD PTR offset$[rsp], eax
  0082f	8b 44 24 3c	 mov	 eax, DWORD PTR offset$[rsp]
  00833	89 44 24 24	 mov	 DWORD PTR size$[rsp], eax

; 1332 : 	if(sfdat->is_little_endian)

  00837	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0083f	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00843	74 3d		 je	 SHORT $LN33@aifcWriteH

; 1333 : 	    tag = REVDWBYTES(tag);

  00845	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  00849	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0084e	c1 e0 18	 shl	 eax, 24
  00851	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00855	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  0085b	c1 e1 08	 shl	 ecx, 8
  0085e	0b c1		 or	 eax, ecx
  00860	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00864	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  0086a	c1 e9 08	 shr	 ecx, 8
  0086d	0b c1		 or	 eax, ecx
  0086f	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00873	c1 e9 18	 shr	 ecx, 24
  00876	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0087c	0b c1		 or	 eax, ecx
  0087e	89 44 24 20	 mov	 DWORD PTR tag$[rsp], eax
$LN33@aifcWriteH:

; 1334 : 	if(wavDoWrite(sfdat,(char *)&tag,sizeof(DWORD))
; 1335 : 			|| wavDoWrite(sfdat,(char *)&size,sizeof(DWORD))
; 1336 : 			|| wavDoWrite(sfdat,(char *)&offset,sizeof(DWORD))
; 1337 : 			|| wavDoWrite(sfdat,(char *)&blocksize,sizeof(DWORD)))

  00882	41 b8 04 00 00
	00		 mov	 r8d, 4
  00888	48 8d 54 24 20	 lea	 rdx, QWORD PTR tag$[rsp]
  0088d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00895	e8 00 00 00 00	 call	 wavDoWrite
  0089a	85 c0		 test	 eax, eax
  0089c	75 54		 jne	 SHORT $LN35@aifcWriteH
  0089e	41 b8 04 00 00
	00		 mov	 r8d, 4
  008a4	48 8d 54 24 24	 lea	 rdx, QWORD PTR size$[rsp]
  008a9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  008b1	e8 00 00 00 00	 call	 wavDoWrite
  008b6	85 c0		 test	 eax, eax
  008b8	75 38		 jne	 SHORT $LN35@aifcWriteH
  008ba	41 b8 04 00 00
	00		 mov	 r8d, 4
  008c0	48 8d 54 24 3c	 lea	 rdx, QWORD PTR offset$[rsp]
  008c5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  008cd	e8 00 00 00 00	 call	 wavDoWrite
  008d2	85 c0		 test	 eax, eax
  008d4	75 1c		 jne	 SHORT $LN35@aifcWriteH
  008d6	41 b8 04 00 00
	00		 mov	 r8d, 4
  008dc	48 8d 54 24 40	 lea	 rdx, QWORD PTR blocksize$[rsp]
  008e1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  008e9	e8 00 00 00 00	 call	 wavDoWrite
  008ee	85 c0		 test	 eax, eax
  008f0	74 07		 je	 SHORT $LN34@aifcWriteH
$LN35@aifcWriteH:

; 1338 : 			return PSF_E_CANT_WRITE;

  008f2	b8 fd ff ff ff	 mov	 eax, -3
  008f7	eb 33		 jmp	 SHORT $LN1@aifcWriteH
$LN34@aifcWriteH:

; 1339 : 	if(fgetpos(sfdat->file,&bytepos))

  008f9	48 8d 54 24 48	 lea	 rdx, QWORD PTR bytepos$[rsp]
  008fe	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00906	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00909	e8 00 00 00 00	 call	 fgetpos
  0090e	85 c0		 test	 eax, eax
  00910	74 07		 je	 SHORT $LN36@aifcWriteH

; 1340 : 	    return PSF_E_CANT_SEEK;

  00912	b8 f5 ff ff ff	 mov	 eax, -11
  00917	eb 13		 jmp	 SHORT $LN1@aifcWriteH
$LN36@aifcWriteH:

; 1341 : 	sfdat->dataoffset = bytepos;

  00919	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00921	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bytepos$[rsp]
  00926	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 1342 : 	return PSF_E_NOERROR;

  0092a	33 c0		 xor	 eax, eax
$LN1@aifcWriteH:

; 1343 : }

  0092c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00931	48 33 cc	 xor	 rcx, rsp
  00934	e8 00 00 00 00	 call	 __security_check_cookie
  00939	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00940	c3		 ret	 0
aifcWriteHeader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
tag$ = 32
size$ = 36
wData$ = 40
version$1 = 44
offset$ = 48
blocksize$ = 52
bytepos$ = 56
dwData$ = 64
now$2 = 68
peaks$ = 72
ieee$ = 80
__$ArrayPad$ = 96
sfdat$ = 128
aiffWriteHeader PROC

; 1097 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1098 : 	DWORD tag,size;		
; 1099 : 	PSF_CHPEAK *peaks;	
; 1100 : 	DWORD dwData,offset,blocksize;
; 1101 : 	unsigned char ieee[10];
; 1102 : 	WORD wData;
; 1103 : 	fpos_t bytepos;
; 1104 : #ifdef _DEBUG
; 1105 : 	assert(sfdat);
; 1106 : 	assert(sfdat->file);
; 1107 : 	assert(sfdat->chformat > STDWAVE);
; 1108 : 	assert(sfdat->nFrames==0);
; 1109 : 	assert(!sfdat->isRead);
; 1110 : 	assert(sfdat->riff_format == PSF_AIFF);
; 1111 : 	assert(sfdat->fmt.Format.nChannels != 0);
; 1112 : #endif
; 1113 : 
; 1114 : 	/*clear pPeaks array*/
; 1115 : 	if(sfdat->pPeaks)

  00018	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00020	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00028	74 29		 je	 SHORT $LN2@aiffWriteH

; 1116 : 		memset((char *)sfdat->pPeaks,0,sizeof(PSF_CHPEAK) * sfdat->fmt.Format.nChannels);

  0002a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00032	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  00036	48 c1 e0 03	 shl	 rax, 3
  0003a	4c 8b c0	 mov	 r8, rax
  0003d	33 d2		 xor	 edx, edx
  0003f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00047	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  0004e	e8 00 00 00 00	 call	 memset
$LN2@aiffWriteH:

; 1117 : 
; 1118 : 	tag = TAG('F','O','R','M');

  00053	c7 44 24 20 4d
	52 4f 46	 mov	 DWORD PTR tag$[rsp], 1179603533 ; 464f524dH

; 1119 : 	size = 0;

  0005b	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR size$[rsp], 0

; 1120 : 
; 1121 : 	if(sfdat->is_little_endian) {

  00063	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0006b	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0006f	74 7a		 je	 SHORT $LN3@aiffWriteH

; 1122 : 		size = REVDWBYTES(size);	

  00071	8b 44 24 24	 mov	 eax, DWORD PTR size$[rsp]
  00075	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0007a	c1 e0 18	 shl	 eax, 24
  0007d	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  00081	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00087	c1 e1 08	 shl	 ecx, 8
  0008a	0b c1		 or	 eax, ecx
  0008c	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  00090	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00096	c1 e9 08	 shr	 ecx, 8
  00099	0b c1		 or	 eax, ecx
  0009b	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  0009f	c1 e9 18	 shr	 ecx, 24
  000a2	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000a8	0b c1		 or	 eax, ecx
  000aa	89 44 24 24	 mov	 DWORD PTR size$[rsp], eax

; 1123 : 		tag = REVDWBYTES(tag);

  000ae	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  000b2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000b7	c1 e0 18	 shl	 eax, 24
  000ba	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  000be	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  000c4	c1 e1 08	 shl	 ecx, 8
  000c7	0b c1		 or	 eax, ecx
  000c9	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  000cd	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  000d3	c1 e9 08	 shr	 ecx, 8
  000d6	0b c1		 or	 eax, ecx
  000d8	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  000dc	c1 e9 18	 shr	 ecx, 24
  000df	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000e5	0b c1		 or	 eax, ecx
  000e7	89 44 24 20	 mov	 DWORD PTR tag$[rsp], eax
$LN3@aiffWriteH:

; 1124 : 	}
; 1125 : 	if(wavDoWrite(sfdat,(char *)&tag,sizeof(DWORD))
; 1126 : 		|| wavDoWrite(sfdat,(char *)&size,sizeof(DWORD)))

  000eb	41 b8 04 00 00
	00		 mov	 r8d, 4
  000f1	48 8d 54 24 20	 lea	 rdx, QWORD PTR tag$[rsp]
  000f6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  000fe	e8 00 00 00 00	 call	 wavDoWrite
  00103	85 c0		 test	 eax, eax
  00105	75 1c		 jne	 SHORT $LN5@aiffWriteH
  00107	41 b8 04 00 00
	00		 mov	 r8d, 4
  0010d	48 8d 54 24 24	 lea	 rdx, QWORD PTR size$[rsp]
  00112	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0011a	e8 00 00 00 00	 call	 wavDoWrite
  0011f	85 c0		 test	 eax, eax
  00121	74 0a		 je	 SHORT $LN4@aiffWriteH
$LN5@aiffWriteH:

; 1127 : 		return PSF_E_CANT_WRITE;

  00123	b8 fd ff ff ff	 mov	 eax, -3
  00128	e9 dc 05 00 00	 jmp	 $LN1@aiffWriteH
$LN4@aiffWriteH:

; 1128 : 	tag = TAG('A','I','F','F');

  0012d	c7 44 24 20 46
	46 49 41	 mov	 DWORD PTR tag$[rsp], 1095321158 ; 41494646H

; 1129 : 	if(sfdat->is_little_endian)

  00135	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0013d	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00141	74 3d		 je	 SHORT $LN6@aiffWriteH

; 1130 : 		tag = REVDWBYTES(tag);

  00143	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  00147	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0014c	c1 e0 18	 shl	 eax, 24
  0014f	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00153	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00159	c1 e1 08	 shl	 ecx, 8
  0015c	0b c1		 or	 eax, ecx
  0015e	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00162	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00168	c1 e9 08	 shr	 ecx, 8
  0016b	0b c1		 or	 eax, ecx
  0016d	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00171	c1 e9 18	 shr	 ecx, 24
  00174	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0017a	0b c1		 or	 eax, ecx
  0017c	89 44 24 20	 mov	 DWORD PTR tag$[rsp], eax
$LN6@aiffWriteH:

; 1131 : 	if(wavDoWrite(sfdat,(char *)&tag,sizeof(DWORD)))

  00180	41 b8 04 00 00
	00		 mov	 r8d, 4
  00186	48 8d 54 24 20	 lea	 rdx, QWORD PTR tag$[rsp]
  0018b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00193	e8 00 00 00 00	 call	 wavDoWrite
  00198	85 c0		 test	 eax, eax
  0019a	74 0a		 je	 SHORT $LN7@aiffWriteH

; 1132 : 		return PSF_E_CANT_WRITE;

  0019c	b8 fd ff ff ff	 mov	 eax, -3
  001a1	e9 63 05 00 00	 jmp	 $LN1@aiffWriteH
$LN7@aiffWriteH:

; 1133 : 
; 1134 : 	tag = TAG('C','O','M','M');

  001a6	c7 44 24 20 4d
	4d 4f 43	 mov	 DWORD PTR tag$[rsp], 1129270605 ; 434f4d4dH

; 1135 : 	size = 18;

  001ae	c7 44 24 24 12
	00 00 00	 mov	 DWORD PTR size$[rsp], 18

; 1136 : 	if(sfdat->is_little_endian){

  001b6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  001be	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  001c2	74 7a		 je	 SHORT $LN8@aiffWriteH

; 1137 : 		size = REVDWBYTES(size);	

  001c4	8b 44 24 24	 mov	 eax, DWORD PTR size$[rsp]
  001c8	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001cd	c1 e0 18	 shl	 eax, 24
  001d0	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  001d4	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  001da	c1 e1 08	 shl	 ecx, 8
  001dd	0b c1		 or	 eax, ecx
  001df	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  001e3	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  001e9	c1 e9 08	 shr	 ecx, 8
  001ec	0b c1		 or	 eax, ecx
  001ee	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  001f2	c1 e9 18	 shr	 ecx, 24
  001f5	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  001fb	0b c1		 or	 eax, ecx
  001fd	89 44 24 24	 mov	 DWORD PTR size$[rsp], eax

; 1138 : 		tag = REVDWBYTES(tag);

  00201	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  00205	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0020a	c1 e0 18	 shl	 eax, 24
  0020d	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00211	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00217	c1 e1 08	 shl	 ecx, 8
  0021a	0b c1		 or	 eax, ecx
  0021c	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00220	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00226	c1 e9 08	 shr	 ecx, 8
  00229	0b c1		 or	 eax, ecx
  0022b	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  0022f	c1 e9 18	 shr	 ecx, 24
  00232	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00238	0b c1		 or	 eax, ecx
  0023a	89 44 24 20	 mov	 DWORD PTR tag$[rsp], eax
$LN8@aiffWriteH:

; 1139 : 	}
; 1140 : 	if(wavDoWrite(sfdat,(char *)&tag,sizeof(DWORD))
; 1141 : 		|| wavDoWrite(sfdat,(char *)&size,sizeof(DWORD)))

  0023e	41 b8 04 00 00
	00		 mov	 r8d, 4
  00244	48 8d 54 24 20	 lea	 rdx, QWORD PTR tag$[rsp]
  00249	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00251	e8 00 00 00 00	 call	 wavDoWrite
  00256	85 c0		 test	 eax, eax
  00258	75 1c		 jne	 SHORT $LN10@aiffWriteH
  0025a	41 b8 04 00 00
	00		 mov	 r8d, 4
  00260	48 8d 54 24 24	 lea	 rdx, QWORD PTR size$[rsp]
  00265	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0026d	e8 00 00 00 00	 call	 wavDoWrite
  00272	85 c0		 test	 eax, eax
  00274	74 0a		 je	 SHORT $LN9@aiffWriteH
$LN10@aiffWriteH:

; 1142 : 		return PSF_E_CANT_WRITE;

  00276	b8 fd ff ff ff	 mov	 eax, -3
  0027b	e9 89 04 00 00	 jmp	 $LN1@aiffWriteH
$LN9@aiffWriteH:

; 1143 : 	if(fgetpos(sfdat->file,&bytepos))

  00280	48 8d 54 24 38	 lea	 rdx, QWORD PTR bytepos$[rsp]
  00285	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0028d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00290	e8 00 00 00 00	 call	 fgetpos
  00295	85 c0		 test	 eax, eax
  00297	74 0a		 je	 SHORT $LN11@aiffWriteH

; 1144 : 	    return PSF_E_CANT_SEEK;

  00299	b8 f5 ff ff ff	 mov	 eax, -11
  0029e	e9 66 04 00 00	 jmp	 $LN1@aiffWriteH
$LN11@aiffWriteH:

; 1145 : 	sfdat->fmtoffset = bytepos;

  002a3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  002ab	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bytepos$[rsp]
  002b0	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 1146 : 
; 1147 : 	wData = sfdat->fmt.Format.nChannels;

  002b4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  002bc	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  002c0	66 89 44 24 28	 mov	 WORD PTR wData$[rsp], ax

; 1148 : 	if(sfdat->is_little_endian)

  002c5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  002cd	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  002d1	74 22		 je	 SHORT $LN12@aiffWriteH

; 1149 : 		wData = (WORD) REVWBYTES(wData);

  002d3	0f b7 44 24 28	 movzx	 eax, WORD PTR wData$[rsp]
  002d8	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002dd	c1 e0 08	 shl	 eax, 8
  002e0	0f b7 4c 24 28	 movzx	 ecx, WORD PTR wData$[rsp]
  002e5	c1 f9 08	 sar	 ecx, 8
  002e8	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  002ee	0b c1		 or	 eax, ecx
  002f0	66 89 44 24 28	 mov	 WORD PTR wData$[rsp], ax
$LN12@aiffWriteH:

; 1150 : 	if(wavDoWrite(sfdat,(char *)&wData,sizeof(WORD)))

  002f5	41 b8 02 00 00
	00		 mov	 r8d, 2
  002fb	48 8d 54 24 28	 lea	 rdx, QWORD PTR wData$[rsp]
  00300	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00308	e8 00 00 00 00	 call	 wavDoWrite
  0030d	85 c0		 test	 eax, eax
  0030f	74 0a		 je	 SHORT $LN13@aiffWriteH

; 1151 : 		return PSF_E_CANT_WRITE;

  00311	b8 fd ff ff ff	 mov	 eax, -3
  00316	e9 ee 03 00 00	 jmp	 $LN1@aiffWriteH
$LN13@aiffWriteH:

; 1152 : 
; 1153 : 	dwData = 0;			/* nFrames */

  0031b	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR dwData$[rsp], 0

; 1154 : 	if(wavDoWrite(sfdat,(char *)&dwData,sizeof(DWORD)))

  00323	41 b8 04 00 00
	00		 mov	 r8d, 4
  00329	48 8d 54 24 40	 lea	 rdx, QWORD PTR dwData$[rsp]
  0032e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00336	e8 00 00 00 00	 call	 wavDoWrite
  0033b	85 c0		 test	 eax, eax
  0033d	74 0a		 je	 SHORT $LN14@aiffWriteH

; 1155 : 		return PSF_E_CANT_WRITE;

  0033f	b8 fd ff ff ff	 mov	 eax, -3
  00344	e9 c0 03 00 00	 jmp	 $LN1@aiffWriteH
$LN14@aiffWriteH:

; 1156 : 
; 1157 : 	wData = sfdat->fmt.Format.wBitsPerSample;

  00349	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00351	0f b7 40 5e	 movzx	 eax, WORD PTR [rax+94]
  00355	66 89 44 24 28	 mov	 WORD PTR wData$[rsp], ax

; 1158 : 	if(sfdat->is_little_endian)

  0035a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00362	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00366	74 22		 je	 SHORT $LN15@aiffWriteH

; 1159 : 		wData = (WORD) REVWBYTES(wData);

  00368	0f b7 44 24 28	 movzx	 eax, WORD PTR wData$[rsp]
  0036d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00372	c1 e0 08	 shl	 eax, 8
  00375	0f b7 4c 24 28	 movzx	 ecx, WORD PTR wData$[rsp]
  0037a	c1 f9 08	 sar	 ecx, 8
  0037d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00383	0b c1		 or	 eax, ecx
  00385	66 89 44 24 28	 mov	 WORD PTR wData$[rsp], ax
$LN15@aiffWriteH:

; 1160 : 	if(wavDoWrite(sfdat,(char *)&wData,sizeof(WORD)))

  0038a	41 b8 02 00 00
	00		 mov	 r8d, 2
  00390	48 8d 54 24 28	 lea	 rdx, QWORD PTR wData$[rsp]
  00395	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0039d	e8 00 00 00 00	 call	 wavDoWrite
  003a2	85 c0		 test	 eax, eax
  003a4	74 0a		 je	 SHORT $LN16@aiffWriteH

; 1161 : 		return PSF_E_CANT_WRITE;

  003a6	b8 fd ff ff ff	 mov	 eax, -3
  003ab	e9 59 03 00 00	 jmp	 $LN1@aiffWriteH
$LN16@aiffWriteH:

; 1162 : 	double_to_ieee_80((double)sfdat->fmt.Format.nSamplesPerSec,ieee);

  003b0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  003b8	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  003bb	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  003c0	48 8d 54 24 50	 lea	 rdx, QWORD PTR ieee$[rsp]
  003c5	e8 00 00 00 00	 call	 double_to_ieee_80

; 1163 : 	
; 1164 : 	if(wavDoWrite(sfdat,ieee,10))

  003ca	41 b8 0a 00 00
	00		 mov	 r8d, 10
  003d0	48 8d 54 24 50	 lea	 rdx, QWORD PTR ieee$[rsp]
  003d5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  003dd	e8 00 00 00 00	 call	 wavDoWrite
  003e2	85 c0		 test	 eax, eax
  003e4	74 0a		 je	 SHORT $LN17@aiffWriteH

; 1165 : 		return PSF_E_CANT_WRITE;

  003e6	b8 fd ff ff ff	 mov	 eax, -3
  003eb	e9 19 03 00 00	 jmp	 $LN1@aiffWriteH
$LN17@aiffWriteH:

; 1166 : 	if(sfdat->pPeaks){

  003f0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  003f8	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00400	0f 84 ee 01 00
	00		 je	 $LN18@aiffWriteH

; 1167 : 		DWORD version = 1, now = 0;

  00406	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR version$1[rsp], 1
  0040e	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR now$2[rsp], 0

; 1168 : 		peaks = sfdat->pPeaks;

  00416	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0041e	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00425	48 89 44 24 48	 mov	 QWORD PTR peaks$[rsp], rax

; 1169 : 		
; 1170 : 		tag = TAG('P','E','A','K');		

  0042a	c7 44 24 20 4b
	41 45 50	 mov	 DWORD PTR tag$[rsp], 1346715979 ; 5045414bH

; 1171 : 		size = 2 * sizeof(DWORD) + sizeof(PSF_CHPEAK) * sfdat->fmt.Format.nChannels;

  00432	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0043a	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  0043e	48 8d 04 c5 08
	00 00 00	 lea	 rax, QWORD PTR [rax*8+8]
  00446	89 44 24 24	 mov	 DWORD PTR size$[rsp], eax

; 1172 : 		if(sfdat->is_little_endian){

  0044a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  00452	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00456	0f 84 b7 00 00
	00		 je	 $LN19@aiffWriteH

; 1173 : 			size = REVDWBYTES(size);

  0045c	8b 44 24 24	 mov	 eax, DWORD PTR size$[rsp]
  00460	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00465	c1 e0 18	 shl	 eax, 24
  00468	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  0046c	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00472	c1 e1 08	 shl	 ecx, 8
  00475	0b c1		 or	 eax, ecx
  00477	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  0047b	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00481	c1 e9 08	 shr	 ecx, 8
  00484	0b c1		 or	 eax, ecx
  00486	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  0048a	c1 e9 18	 shr	 ecx, 24
  0048d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00493	0b c1		 or	 eax, ecx
  00495	89 44 24 24	 mov	 DWORD PTR size$[rsp], eax

; 1174 : 			version  = REVDWBYTES(version);

  00499	8b 44 24 2c	 mov	 eax, DWORD PTR version$1[rsp]
  0049d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004a2	c1 e0 18	 shl	 eax, 24
  004a5	8b 4c 24 2c	 mov	 ecx, DWORD PTR version$1[rsp]
  004a9	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  004af	c1 e1 08	 shl	 ecx, 8
  004b2	0b c1		 or	 eax, ecx
  004b4	8b 4c 24 2c	 mov	 ecx, DWORD PTR version$1[rsp]
  004b8	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  004be	c1 e9 08	 shr	 ecx, 8
  004c1	0b c1		 or	 eax, ecx
  004c3	8b 4c 24 2c	 mov	 ecx, DWORD PTR version$1[rsp]
  004c7	c1 e9 18	 shr	 ecx, 24
  004ca	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  004d0	0b c1		 or	 eax, ecx
  004d2	89 44 24 2c	 mov	 DWORD PTR version$1[rsp], eax

; 1175 : 			tag = REVDWBYTES(tag);

  004d6	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  004da	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004df	c1 e0 18	 shl	 eax, 24
  004e2	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  004e6	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  004ec	c1 e1 08	 shl	 ecx, 8
  004ef	0b c1		 or	 eax, ecx
  004f1	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  004f5	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  004fb	c1 e9 08	 shr	 ecx, 8
  004fe	0b c1		 or	 eax, ecx
  00500	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00504	c1 e9 18	 shr	 ecx, 24
  00507	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0050d	0b c1		 or	 eax, ecx
  0050f	89 44 24 20	 mov	 DWORD PTR tag$[rsp], eax
$LN19@aiffWriteH:

; 1176 : 		}
; 1177 : 		if(wavDoWrite(sfdat,(char *)&tag,sizeof(DWORD))
; 1178 : 			|| wavDoWrite(sfdat,(char *)&size,sizeof(DWORD))
; 1179 : 			|| wavDoWrite(sfdat,(char *)&version,sizeof(DWORD)))

  00513	41 b8 04 00 00
	00		 mov	 r8d, 4
  00519	48 8d 54 24 20	 lea	 rdx, QWORD PTR tag$[rsp]
  0051e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00526	e8 00 00 00 00	 call	 wavDoWrite
  0052b	85 c0		 test	 eax, eax
  0052d	75 38		 jne	 SHORT $LN21@aiffWriteH
  0052f	41 b8 04 00 00
	00		 mov	 r8d, 4
  00535	48 8d 54 24 24	 lea	 rdx, QWORD PTR size$[rsp]
  0053a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00542	e8 00 00 00 00	 call	 wavDoWrite
  00547	85 c0		 test	 eax, eax
  00549	75 1c		 jne	 SHORT $LN21@aiffWriteH
  0054b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00551	48 8d 54 24 2c	 lea	 rdx, QWORD PTR version$1[rsp]
  00556	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0055e	e8 00 00 00 00	 call	 wavDoWrite
  00563	85 c0		 test	 eax, eax
  00565	74 0a		 je	 SHORT $LN20@aiffWriteH
$LN21@aiffWriteH:

; 1180 : 			return PSF_E_CANT_WRITE;

  00567	b8 fd ff ff ff	 mov	 eax, -3
  0056c	e9 98 01 00 00	 jmp	 $LN1@aiffWriteH
$LN20@aiffWriteH:

; 1181 : 		if(fgetpos(sfdat->file,&bytepos))

  00571	48 8d 54 24 38	 lea	 rdx, QWORD PTR bytepos$[rsp]
  00576	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0057e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00581	e8 00 00 00 00	 call	 fgetpos
  00586	85 c0		 test	 eax, eax
  00588	74 0a		 je	 SHORT $LN22@aiffWriteH

; 1182 : 		    return PSF_E_CANT_SEEK;

  0058a	b8 f5 ff ff ff	 mov	 eax, -11
  0058f	e9 75 01 00 00	 jmp	 $LN1@aiffWriteH
$LN22@aiffWriteH:

; 1183 : 		sfdat->peakoffset = bytepos;  /*we need to update time*/

  00594	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0059c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bytepos$[rsp]
  005a1	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 1184 : 
; 1185 : 		if(wavDoWrite(sfdat,(char *) &now,sizeof(DWORD))
; 1186 : 			|| wavDoWrite(sfdat,(char *) peaks, sizeof(PSF_CHPEAK) * sfdat->fmt.Format.nChannels))

  005a5	41 b8 04 00 00
	00		 mov	 r8d, 4
  005ab	48 8d 54 24 44	 lea	 rdx, QWORD PTR now$2[rsp]
  005b0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  005b8	e8 00 00 00 00	 call	 wavDoWrite
  005bd	85 c0		 test	 eax, eax
  005bf	75 29		 jne	 SHORT $LN24@aiffWriteH
  005c1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  005c9	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  005cd	48 c1 e0 03	 shl	 rax, 3
  005d1	44 8b c0	 mov	 r8d, eax
  005d4	48 8b 54 24 48	 mov	 rdx, QWORD PTR peaks$[rsp]
  005d9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  005e1	e8 00 00 00 00	 call	 wavDoWrite
  005e6	85 c0		 test	 eax, eax
  005e8	74 0a		 je	 SHORT $LN23@aiffWriteH
$LN24@aiffWriteH:

; 1187 : 			return PSF_E_CANT_WRITE;

  005ea	b8 fd ff ff ff	 mov	 eax, -3
  005ef	e9 15 01 00 00	 jmp	 $LN1@aiffWriteH
$LN23@aiffWriteH:
$LN18@aiffWriteH:

; 1188 : 	}
; 1189 : 
; 1190 : 	tag = TAG('S','S','N','D');

  005f4	c7 44 24 20 44
	4e 53 53	 mov	 DWORD PTR tag$[rsp], 1397968452 ; 53534e44H

; 1191 : 	size = offset = blocksize = 0;

  005fc	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR blocksize$[rsp], 0
  00604	8b 44 24 34	 mov	 eax, DWORD PTR blocksize$[rsp]
  00608	89 44 24 30	 mov	 DWORD PTR offset$[rsp], eax
  0060c	8b 44 24 30	 mov	 eax, DWORD PTR offset$[rsp]
  00610	89 44 24 24	 mov	 DWORD PTR size$[rsp], eax

; 1192 : 	if(sfdat->is_little_endian)

  00614	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  0061c	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00620	74 3d		 je	 SHORT $LN25@aiffWriteH

; 1193 : 			tag = REVDWBYTES(tag);

  00622	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  00626	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0062b	c1 e0 18	 shl	 eax, 24
  0062e	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00632	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00638	c1 e1 08	 shl	 ecx, 8
  0063b	0b c1		 or	 eax, ecx
  0063d	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00641	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00647	c1 e9 08	 shr	 ecx, 8
  0064a	0b c1		 or	 eax, ecx
  0064c	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00650	c1 e9 18	 shr	 ecx, 24
  00653	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00659	0b c1		 or	 eax, ecx
  0065b	89 44 24 20	 mov	 DWORD PTR tag$[rsp], eax
$LN25@aiffWriteH:

; 1194 : 	if(wavDoWrite(sfdat,(char *)&tag,sizeof(DWORD))
; 1195 : 			|| wavDoWrite(sfdat,(char *)&size,sizeof(DWORD))
; 1196 : 			|| wavDoWrite(sfdat,(char *)&offset,sizeof(DWORD))
; 1197 : 			|| wavDoWrite(sfdat,(char *)&blocksize,sizeof(DWORD)))

  0065f	41 b8 04 00 00
	00		 mov	 r8d, 4
  00665	48 8d 54 24 20	 lea	 rdx, QWORD PTR tag$[rsp]
  0066a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00672	e8 00 00 00 00	 call	 wavDoWrite
  00677	85 c0		 test	 eax, eax
  00679	75 54		 jne	 SHORT $LN27@aiffWriteH
  0067b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00681	48 8d 54 24 24	 lea	 rdx, QWORD PTR size$[rsp]
  00686	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0068e	e8 00 00 00 00	 call	 wavDoWrite
  00693	85 c0		 test	 eax, eax
  00695	75 38		 jne	 SHORT $LN27@aiffWriteH
  00697	41 b8 04 00 00
	00		 mov	 r8d, 4
  0069d	48 8d 54 24 30	 lea	 rdx, QWORD PTR offset$[rsp]
  006a2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  006aa	e8 00 00 00 00	 call	 wavDoWrite
  006af	85 c0		 test	 eax, eax
  006b1	75 1c		 jne	 SHORT $LN27@aiffWriteH
  006b3	41 b8 04 00 00
	00		 mov	 r8d, 4
  006b9	48 8d 54 24 34	 lea	 rdx, QWORD PTR blocksize$[rsp]
  006be	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sfdat$[rsp]
  006c6	e8 00 00 00 00	 call	 wavDoWrite
  006cb	85 c0		 test	 eax, eax
  006cd	74 07		 je	 SHORT $LN26@aiffWriteH
$LN27@aiffWriteH:

; 1198 : 			return PSF_E_CANT_WRITE;

  006cf	b8 fd ff ff ff	 mov	 eax, -3
  006d4	eb 33		 jmp	 SHORT $LN1@aiffWriteH
$LN26@aiffWriteH:

; 1199 : 	if(fgetpos(sfdat->file,&bytepos))

  006d6	48 8d 54 24 38	 lea	 rdx, QWORD PTR bytepos$[rsp]
  006db	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  006e3	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  006e6	e8 00 00 00 00	 call	 fgetpos
  006eb	85 c0		 test	 eax, eax
  006ed	74 07		 je	 SHORT $LN28@aiffWriteH

; 1200 : 	    return PSF_E_CANT_SEEK;

  006ef	b8 f5 ff ff ff	 mov	 eax, -11
  006f4	eb 13		 jmp	 SHORT $LN1@aiffWriteH
$LN28@aiffWriteH:

; 1201 : 	sfdat->dataoffset = bytepos;

  006f6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sfdat$[rsp]
  006fe	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bytepos$[rsp]
  00703	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 1202 : 	return PSF_E_NOERROR;

  00707	33 c0		 xor	 eax, eax
$LN1@aiffWriteH:

; 1203 : }

  00709	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0070e	48 33 cc	 xor	 rcx, rsp
  00711	e8 00 00 00 00	 call	 __security_check_cookie
  00716	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0071a	c3		 ret	 0
aiffWriteHeader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
tag$ = 32
size$ = 36
version$1 = 40
now$2 = 44
pfmt$ = 48
pGuid$ = 56
bytepos$ = 64
peaks$ = 72
sfdat$ = 96
waveExWriteHeader PROC

; 978  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 979  : 	DWORD tag,size;	
; 980  : 	WAVEFORMATEXTENSIBLE *pfmt;
; 981  : 	PSF_CHPEAK *peaks;	
; 982  : 	GUID *pGuid = NULL;

  00009	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR pGuid$[rsp], 0

; 983  : 	fpos_t bytepos;
; 984  : #ifdef _DEBUG
; 985  : 	assert(sfdat);
; 986  : 	assert(sfdat->file);
; 987  : 	assert(sfdat->chformat > STDWAVE);
; 988  : 	assert(sfdat->nFrames==0);
; 989  : 	assert(!sfdat->isRead);
; 990  : 	assert(sfdat->fmt.Format.nChannels != 0);
; 991  : #endif
; 992  : 	/*clear pPeaks array*/
; 993  : 	if(sfdat->pPeaks)

  00012	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00017	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  0001f	74 23		 je	 SHORT $LN2@waveExWrit

; 994  : 		memset((char *)sfdat->pPeaks,0,sizeof(PSF_CHPEAK) * sfdat->fmt.Format.nChannels);

  00021	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00026	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  0002a	48 c1 e0 03	 shl	 rax, 3
  0002e	4c 8b c0	 mov	 r8, rax
  00031	33 d2		 xor	 edx, edx
  00033	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00038	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  0003f	e8 00 00 00 00	 call	 memset
$LN2@waveExWrit:

; 995  : 	/* complete WAVE-EX format fields: */
; 996  :     if(sfdat->chformat==MC_BFMT){

  00044	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00049	83 78 7c 06	 cmp	 DWORD PTR [rax+124], 6
  0004d	75 27		 jne	 SHORT $LN3@waveExWrit

; 997  :         if(sfdat->samptype== PSF_SAMP_IEEE_FLOAT){				

  0004f	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00054	83 78 30 05	 cmp	 DWORD PTR [rax+48], 5
  00058	75 0e		 jne	 SHORT $LN5@waveExWrit

; 998  :             pGuid = (GUID *)  &SUBTYPE_AMBISONIC_B_FORMAT_IEEE_FLOAT;

  0005a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:SUBTYPE_AMBISONIC_B_FORMAT_IEEE_FLOAT
  00061	48 89 44 24 38	 mov	 QWORD PTR pGuid$[rsp], rax

; 999  :         }

  00066	eb 0c		 jmp	 SHORT $LN6@waveExWrit
$LN5@waveExWrit:

; 1000 :         else{		
; 1001 :             pGuid =(GUID *) &SUBTYPE_AMBISONIC_B_FORMAT_PCM;

  00068	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:SUBTYPE_AMBISONIC_B_FORMAT_PCM
  0006f	48 89 44 24 38	 mov	 QWORD PTR pGuid$[rsp], rax
$LN6@waveExWrit:

; 1002 :         }
; 1003 :         
; 1004 :     }else {

  00074	eb 28		 jmp	 SHORT $LN4@waveExWrit
$LN3@waveExWrit:

; 1005 :         if(sfdat->fmt.Format.wFormatTag==  WAVE_FORMAT_IEEE_FLOAT){				

  00076	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  0007b	0f b7 40 50	 movzx	 eax, WORD PTR [rax+80]
  0007f	83 f8 03	 cmp	 eax, 3
  00082	75 0e		 jne	 SHORT $LN7@waveExWrit

; 1006 :             pGuid = (GUID *)  &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT;

  00084	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:KSDATAFORMAT_SUBTYPE_IEEE_FLOAT
  0008b	48 89 44 24 38	 mov	 QWORD PTR pGuid$[rsp], rax

; 1007 :         }

  00090	eb 0c		 jmp	 SHORT $LN8@waveExWrit
$LN7@waveExWrit:

; 1008 :         else{		
; 1009 :             pGuid =(GUID *) &KSDATAFORMAT_SUBTYPE_PCM;

  00092	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:KSDATAFORMAT_SUBTYPE_PCM
  00099	48 89 44 24 38	 mov	 QWORD PTR pGuid$[rsp], rax
$LN8@waveExWrit:
$LN4@waveExWrit:

; 1010 :         }
; 1011 :     }
; 1012 : 	sfdat->fmt.Format.wFormatTag = WAVE_FORMAT_EXTENSIBLE;

  0009e	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000a3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  000a8	66 89 41 50	 mov	 WORD PTR [rcx+80], ax

; 1013 : 	memcpy((char *) &(sfdat->fmt.SubFormat),(char *)pGuid,sizeof(GUID));

  000ac	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  000b1	48 83 c0 6c	 add	 rax, 108		; 0000006cH
  000b5	41 b8 10 00 00
	00		 mov	 r8d, 16
  000bb	48 8b 54 24 38	 mov	 rdx, QWORD PTR pGuid$[rsp]
  000c0	48 8b c8	 mov	 rcx, rax
  000c3	e8 00 00 00 00	 call	 memcpy

; 1014 : 	tag = TAG('R','I','F','F');

  000c8	c7 44 24 20 46
	46 49 52	 mov	 DWORD PTR tag$[rsp], 1380533830 ; 52494646H

; 1015 : 	size = 0;

  000d0	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR size$[rsp], 0

; 1016 : 	if(!sfdat->is_little_endian)

  000d8	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  000dd	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  000e1	75 3f		 jne	 SHORT $LN9@waveExWrit

; 1017 : 		size = REVDWBYTES(size);

  000e3	8b 44 24 24	 mov	 eax, DWORD PTR size$[rsp]
  000e7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000ec	c1 e0 18	 shl	 eax, 24
  000ef	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  000f3	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  000f9	c1 e1 08	 shl	 ecx, 8
  000fc	0b c1		 or	 eax, ecx
  000fe	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  00102	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00108	c1 e9 08	 shr	 ecx, 8
  0010b	0b c1		 or	 eax, ecx
  0010d	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  00111	c1 e9 18	 shr	 ecx, 24
  00114	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0011a	0b c1		 or	 eax, ecx
  0011c	89 44 24 24	 mov	 DWORD PTR size$[rsp], eax
  00120	eb 3d		 jmp	 SHORT $LN10@waveExWrit
$LN9@waveExWrit:

; 1018 : 	else
; 1019 : 		tag = REVDWBYTES(tag);

  00122	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  00126	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0012b	c1 e0 18	 shl	 eax, 24
  0012e	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00132	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00138	c1 e1 08	 shl	 ecx, 8
  0013b	0b c1		 or	 eax, ecx
  0013d	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00141	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00147	c1 e9 08	 shr	 ecx, 8
  0014a	0b c1		 or	 eax, ecx
  0014c	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00150	c1 e9 18	 shr	 ecx, 24
  00153	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00159	0b c1		 or	 eax, ecx
  0015b	89 44 24 20	 mov	 DWORD PTR tag$[rsp], eax
$LN10@waveExWrit:

; 1020 : 	if(wavDoWrite(sfdat,(char *)&tag,sizeof(DWORD))
; 1021 : 		|| wavDoWrite(sfdat,(char *)&size,sizeof(DWORD)))

  0015f	41 b8 04 00 00
	00		 mov	 r8d, 4
  00165	48 8d 54 24 20	 lea	 rdx, QWORD PTR tag$[rsp]
  0016a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0016f	e8 00 00 00 00	 call	 wavDoWrite
  00174	85 c0		 test	 eax, eax
  00176	75 19		 jne	 SHORT $LN12@waveExWrit
  00178	41 b8 04 00 00
	00		 mov	 r8d, 4
  0017e	48 8d 54 24 24	 lea	 rdx, QWORD PTR size$[rsp]
  00183	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00188	e8 00 00 00 00	 call	 wavDoWrite
  0018d	85 c0		 test	 eax, eax
  0018f	74 0a		 je	 SHORT $LN11@waveExWrit
$LN12@waveExWrit:

; 1022 : 		return PSF_E_CANT_WRITE;

  00191	b8 fd ff ff ff	 mov	 eax, -3
  00196	e9 e4 04 00 00	 jmp	 $LN1@waveExWrit
$LN11@waveExWrit:

; 1023 : 	tag = TAG('W','A','V','E');

  0019b	c7 44 24 20 45
	56 41 57	 mov	 DWORD PTR tag$[rsp], 1463899717 ; 57415645H

; 1024 : 	if(sfdat->is_little_endian)

  001a3	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  001a8	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  001ac	74 3d		 je	 SHORT $LN13@waveExWrit

; 1025 : 		tag = REVDWBYTES(tag);

  001ae	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  001b2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001b7	c1 e0 18	 shl	 eax, 24
  001ba	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  001be	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  001c4	c1 e1 08	 shl	 ecx, 8
  001c7	0b c1		 or	 eax, ecx
  001c9	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  001cd	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  001d3	c1 e9 08	 shr	 ecx, 8
  001d6	0b c1		 or	 eax, ecx
  001d8	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  001dc	c1 e9 18	 shr	 ecx, 24
  001df	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  001e5	0b c1		 or	 eax, ecx
  001e7	89 44 24 20	 mov	 DWORD PTR tag$[rsp], eax
$LN13@waveExWrit:

; 1026 : 	if(wavDoWrite(sfdat,(char *)&tag,sizeof(DWORD)))

  001eb	41 b8 04 00 00
	00		 mov	 r8d, 4
  001f1	48 8d 54 24 20	 lea	 rdx, QWORD PTR tag$[rsp]
  001f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  001fb	e8 00 00 00 00	 call	 wavDoWrite
  00200	85 c0		 test	 eax, eax
  00202	74 0a		 je	 SHORT $LN14@waveExWrit

; 1027 : 		return PSF_E_CANT_WRITE;

  00204	b8 fd ff ff ff	 mov	 eax, -3
  00209	e9 71 04 00 00	 jmp	 $LN1@waveExWrit
$LN14@waveExWrit:

; 1028 : 	pfmt = &(sfdat->fmt);

  0020e	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00213	48 83 c0 50	 add	 rax, 80			; 00000050H
  00217	48 89 44 24 30	 mov	 QWORD PTR pfmt$[rsp], rax

; 1029 : 	tag = TAG('f','m','t',' ');	

  0021c	c7 44 24 20 20
	74 6d 66	 mov	 DWORD PTR tag$[rsp], 1718449184 ; 666d7420H

; 1030 : 	size = sizeof_WFMTEX;	

  00224	c7 44 24 24 28
	00 00 00	 mov	 DWORD PTR size$[rsp], 40 ; 00000028H

; 1031 : 	if(!sfdat->is_little_endian){

  0022c	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00231	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00235	75 49		 jne	 SHORT $LN15@waveExWrit

; 1032 : 		size = REVDWBYTES(size);

  00237	8b 44 24 24	 mov	 eax, DWORD PTR size$[rsp]
  0023b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00240	c1 e0 18	 shl	 eax, 24
  00243	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  00247	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  0024d	c1 e1 08	 shl	 ecx, 8
  00250	0b c1		 or	 eax, ecx
  00252	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  00256	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  0025c	c1 e9 08	 shr	 ecx, 8
  0025f	0b c1		 or	 eax, ecx
  00261	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  00265	c1 e9 18	 shr	 ecx, 24
  00268	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0026e	0b c1		 or	 eax, ecx
  00270	89 44 24 24	 mov	 DWORD PTR size$[rsp], eax

; 1033 : 		fmtExSwapBytes(sfdat);

  00274	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00279	e8 00 00 00 00	 call	 fmtExSwapBytes

; 1034 : 	}

  0027e	eb 3d		 jmp	 SHORT $LN16@waveExWrit
$LN15@waveExWrit:

; 1035 : 	else
; 1036 : 		tag = REVDWBYTES(tag);

  00280	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  00284	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00289	c1 e0 18	 shl	 eax, 24
  0028c	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  00290	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00296	c1 e1 08	 shl	 ecx, 8
  00299	0b c1		 or	 eax, ecx
  0029b	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  0029f	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  002a5	c1 e9 08	 shr	 ecx, 8
  002a8	0b c1		 or	 eax, ecx
  002aa	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  002ae	c1 e9 18	 shr	 ecx, 24
  002b1	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  002b7	0b c1		 or	 eax, ecx
  002b9	89 44 24 20	 mov	 DWORD PTR tag$[rsp], eax
$LN16@waveExWrit:

; 1037 : 	if(wavDoWrite(sfdat,(char *)&tag,sizeof(DWORD))
; 1038 : 		|| wavDoWrite(sfdat,(char *)&size,sizeof(DWORD)))		

  002bd	41 b8 04 00 00
	00		 mov	 r8d, 4
  002c3	48 8d 54 24 20	 lea	 rdx, QWORD PTR tag$[rsp]
  002c8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  002cd	e8 00 00 00 00	 call	 wavDoWrite
  002d2	85 c0		 test	 eax, eax
  002d4	75 19		 jne	 SHORT $LN18@waveExWrit
  002d6	41 b8 04 00 00
	00		 mov	 r8d, 4
  002dc	48 8d 54 24 24	 lea	 rdx, QWORD PTR size$[rsp]
  002e1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  002e6	e8 00 00 00 00	 call	 wavDoWrite
  002eb	85 c0		 test	 eax, eax
  002ed	74 0a		 je	 SHORT $LN17@waveExWrit
$LN18@waveExWrit:

; 1039 : 		return PSF_E_CANT_WRITE;

  002ef	b8 fd ff ff ff	 mov	 eax, -3
  002f4	e9 86 03 00 00	 jmp	 $LN1@waveExWrit
$LN17@waveExWrit:

; 1040 : 	if(fgetpos(sfdat->file,&bytepos))

  002f9	48 8d 54 24 40	 lea	 rdx, QWORD PTR bytepos$[rsp]
  002fe	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00303	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00306	e8 00 00 00 00	 call	 fgetpos
  0030b	85 c0		 test	 eax, eax
  0030d	74 0a		 je	 SHORT $LN19@waveExWrit

; 1041 : 	    return PSF_E_CANT_SEEK;

  0030f	b8 f5 ff ff ff	 mov	 eax, -11
  00314	e9 66 03 00 00	 jmp	 $LN1@waveExWrit
$LN19@waveExWrit:

; 1042 : 	sfdat->fmtoffset = bytepos;

  00319	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  0031e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bytepos$[rsp]
  00323	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 1043 : 	/* write fmt elementwise, to avoid C alignment traps with WORD */
; 1044 : 	/* 16byte format...*/
; 1045 : 	if(wavDoWrite(sfdat,(char *)pfmt,sizeof(WAVEFORMAT))	
; 1046 : 	/** cbSize... */
; 1047 : 	||wavDoWrite(sfdat,(char *) &(pfmt->Format.cbSize),sizeof(WORD))	
; 1048 : 	/* validbits... */
; 1049 : 	||wavDoWrite(sfdat,(char *) &(pfmt->Samples.wValidBitsPerSample),sizeof(WORD))	
; 1050 : 	/* ChannelMask .... */
; 1051 : 	||wavDoWrite(sfdat,(char *) &(pfmt->dwChannelMask),sizeof(DWORD))		
; 1052 : 	/*  and the GUID */
; 1053 : 	||wavDoWrite(sfdat,(char *) &(pfmt->SubFormat),sizeof(GUID)))

  00327	41 b8 10 00 00
	00		 mov	 r8d, 16
  0032d	48 8b 54 24 30	 mov	 rdx, QWORD PTR pfmt$[rsp]
  00332	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00337	e8 00 00 00 00	 call	 wavDoWrite
  0033c	85 c0		 test	 eax, eax
  0033e	0f 85 80 00 00
	00		 jne	 $LN21@waveExWrit
  00344	48 8b 44 24 30	 mov	 rax, QWORD PTR pfmt$[rsp]
  00349	48 83 c0 10	 add	 rax, 16
  0034d	41 b8 02 00 00
	00		 mov	 r8d, 2
  00353	48 8b d0	 mov	 rdx, rax
  00356	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0035b	e8 00 00 00 00	 call	 wavDoWrite
  00360	85 c0		 test	 eax, eax
  00362	75 60		 jne	 SHORT $LN21@waveExWrit
  00364	48 8b 44 24 30	 mov	 rax, QWORD PTR pfmt$[rsp]
  00369	48 83 c0 14	 add	 rax, 20
  0036d	41 b8 02 00 00
	00		 mov	 r8d, 2
  00373	48 8b d0	 mov	 rdx, rax
  00376	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0037b	e8 00 00 00 00	 call	 wavDoWrite
  00380	85 c0		 test	 eax, eax
  00382	75 40		 jne	 SHORT $LN21@waveExWrit
  00384	48 8b 44 24 30	 mov	 rax, QWORD PTR pfmt$[rsp]
  00389	48 83 c0 18	 add	 rax, 24
  0038d	41 b8 04 00 00
	00		 mov	 r8d, 4
  00393	48 8b d0	 mov	 rdx, rax
  00396	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0039b	e8 00 00 00 00	 call	 wavDoWrite
  003a0	85 c0		 test	 eax, eax
  003a2	75 20		 jne	 SHORT $LN21@waveExWrit
  003a4	48 8b 44 24 30	 mov	 rax, QWORD PTR pfmt$[rsp]
  003a9	48 83 c0 1c	 add	 rax, 28
  003ad	41 b8 10 00 00
	00		 mov	 r8d, 16
  003b3	48 8b d0	 mov	 rdx, rax
  003b6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  003bb	e8 00 00 00 00	 call	 wavDoWrite
  003c0	85 c0		 test	 eax, eax
  003c2	74 0a		 je	 SHORT $LN20@waveExWrit
$LN21@waveExWrit:

; 1054 : 		return PSF_E_CANT_WRITE;

  003c4	b8 fd ff ff ff	 mov	 eax, -3
  003c9	e9 b1 02 00 00	 jmp	 $LN1@waveExWrit
$LN20@waveExWrit:

; 1055 :         /* reswap it all */
; 1056 :         if(!sfdat->is_little_endian){

  003ce	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  003d3	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  003d7	75 0a		 jne	 SHORT $LN22@waveExWrit

; 1057 :             fmtExSwapBytes(sfdat);

  003d9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  003de	e8 00 00 00 00	 call	 fmtExSwapBytes
$LN22@waveExWrit:

; 1058 :         }
; 1059 : 	if(sfdat->pPeaks){

  003e3	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  003e8	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  003f0	0f 84 cb 01 00
	00		 je	 $LN23@waveExWrit

; 1060 : 		DWORD version = 1, now = 0;

  003f6	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR version$1[rsp], 1
  003fe	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR now$2[rsp], 0

; 1061 : 		
; 1062 :         peaks = sfdat->pPeaks;		

  00406	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  0040b	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00412	48 89 44 24 48	 mov	 QWORD PTR peaks$[rsp], rax

; 1063 : 		tag = TAG('P','E','A','K');		

  00417	c7 44 24 20 4b
	41 45 50	 mov	 DWORD PTR tag$[rsp], 1346715979 ; 5045414bH

; 1064 : 		size = 2 * sizeof(DWORD) + sizeof(PSF_CHPEAK) * pfmt->Format.nChannels;

  0041f	48 8b 44 24 30	 mov	 rax, QWORD PTR pfmt$[rsp]
  00424	0f b7 40 02	 movzx	 eax, WORD PTR [rax+2]
  00428	48 8d 04 c5 08
	00 00 00	 lea	 rax, QWORD PTR [rax*8+8]
  00430	89 44 24 24	 mov	 DWORD PTR size$[rsp], eax

; 1065 : 		if(!sfdat->is_little_endian){

  00434	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00439	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0043d	75 7c		 jne	 SHORT $LN24@waveExWrit

; 1066 : 			size = REVDWBYTES(size);

  0043f	8b 44 24 24	 mov	 eax, DWORD PTR size$[rsp]
  00443	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00448	c1 e0 18	 shl	 eax, 24
  0044b	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  0044f	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00455	c1 e1 08	 shl	 ecx, 8
  00458	0b c1		 or	 eax, ecx
  0045a	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  0045e	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00464	c1 e9 08	 shr	 ecx, 8
  00467	0b c1		 or	 eax, ecx
  00469	8b 4c 24 24	 mov	 ecx, DWORD PTR size$[rsp]
  0046d	c1 e9 18	 shr	 ecx, 24
  00470	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00476	0b c1		 or	 eax, ecx
  00478	89 44 24 24	 mov	 DWORD PTR size$[rsp], eax

; 1067 : 			version  = REVDWBYTES(version);

  0047c	8b 44 24 28	 mov	 eax, DWORD PTR version$1[rsp]
  00480	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00485	c1 e0 18	 shl	 eax, 24
  00488	8b 4c 24 28	 mov	 ecx, DWORD PTR version$1[rsp]
  0048c	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00492	c1 e1 08	 shl	 ecx, 8
  00495	0b c1		 or	 eax, ecx
  00497	8b 4c 24 28	 mov	 ecx, DWORD PTR version$1[rsp]
  0049b	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  004a1	c1 e9 08	 shr	 ecx, 8
  004a4	0b c1		 or	 eax, ecx
  004a6	8b 4c 24 28	 mov	 ecx, DWORD PTR version$1[rsp]
  004aa	c1 e9 18	 shr	 ecx, 24
  004ad	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  004b3	0b c1		 or	 eax, ecx
  004b5	89 44 24 28	 mov	 DWORD PTR version$1[rsp], eax

; 1068 : 		}

  004b9	eb 3d		 jmp	 SHORT $LN25@waveExWrit
$LN24@waveExWrit:

; 1069 : 		else
; 1070 : 			tag = REVDWBYTES(tag);

  004bb	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  004bf	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004c4	c1 e0 18	 shl	 eax, 24
  004c7	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  004cb	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  004d1	c1 e1 08	 shl	 ecx, 8
  004d4	0b c1		 or	 eax, ecx
  004d6	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  004da	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  004e0	c1 e9 08	 shr	 ecx, 8
  004e3	0b c1		 or	 eax, ecx
  004e5	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  004e9	c1 e9 18	 shr	 ecx, 24
  004ec	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  004f2	0b c1		 or	 eax, ecx
  004f4	89 44 24 20	 mov	 DWORD PTR tag$[rsp], eax
$LN25@waveExWrit:

; 1071 : 		if(wavDoWrite(sfdat,(char *)&tag,sizeof(DWORD))
; 1072 : 			|| wavDoWrite(sfdat,(char *)&size,sizeof(DWORD))
; 1073 : 			|| wavDoWrite(sfdat,(char *)&version,sizeof(DWORD)))

  004f8	41 b8 04 00 00
	00		 mov	 r8d, 4
  004fe	48 8d 54 24 20	 lea	 rdx, QWORD PTR tag$[rsp]
  00503	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00508	e8 00 00 00 00	 call	 wavDoWrite
  0050d	85 c0		 test	 eax, eax
  0050f	75 32		 jne	 SHORT $LN27@waveExWrit
  00511	41 b8 04 00 00
	00		 mov	 r8d, 4
  00517	48 8d 54 24 24	 lea	 rdx, QWORD PTR size$[rsp]
  0051c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00521	e8 00 00 00 00	 call	 wavDoWrite
  00526	85 c0		 test	 eax, eax
  00528	75 19		 jne	 SHORT $LN27@waveExWrit
  0052a	41 b8 04 00 00
	00		 mov	 r8d, 4
  00530	48 8d 54 24 28	 lea	 rdx, QWORD PTR version$1[rsp]
  00535	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0053a	e8 00 00 00 00	 call	 wavDoWrite
  0053f	85 c0		 test	 eax, eax
  00541	74 0a		 je	 SHORT $LN26@waveExWrit
$LN27@waveExWrit:

; 1074 : 			return PSF_E_CANT_WRITE;

  00543	b8 fd ff ff ff	 mov	 eax, -3
  00548	e9 32 01 00 00	 jmp	 $LN1@waveExWrit
$LN26@waveExWrit:

; 1075 : 		if(fgetpos(sfdat->file,&bytepos))

  0054d	48 8d 54 24 40	 lea	 rdx, QWORD PTR bytepos$[rsp]
  00552	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00557	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0055a	e8 00 00 00 00	 call	 fgetpos
  0055f	85 c0		 test	 eax, eax
  00561	74 0a		 je	 SHORT $LN28@waveExWrit

; 1076 : 		    return PSF_E_CANT_SEEK;

  00563	b8 f5 ff ff ff	 mov	 eax, -11
  00568	e9 12 01 00 00	 jmp	 $LN1@waveExWrit
$LN28@waveExWrit:

; 1077 : 		sfdat->peakoffset = bytepos;  /*we need to update time*/

  0056d	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00572	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bytepos$[rsp]
  00577	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 1078 : 		if(wavDoWrite(sfdat,(char *) &now,sizeof(DWORD))
; 1079 : 			|| wavDoWrite(sfdat,(char *) peaks, sizeof(PSF_CHPEAK) * sfdat->fmt.Format.nChannels))

  0057b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00581	48 8d 54 24 2c	 lea	 rdx, QWORD PTR now$2[rsp]
  00586	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0058b	e8 00 00 00 00	 call	 wavDoWrite
  00590	85 c0		 test	 eax, eax
  00592	75 23		 jne	 SHORT $LN30@waveExWrit
  00594	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00599	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  0059d	48 c1 e0 03	 shl	 rax, 3
  005a1	44 8b c0	 mov	 r8d, eax
  005a4	48 8b 54 24 48	 mov	 rdx, QWORD PTR peaks$[rsp]
  005a9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  005ae	e8 00 00 00 00	 call	 wavDoWrite
  005b3	85 c0		 test	 eax, eax
  005b5	74 0a		 je	 SHORT $LN29@waveExWrit
$LN30@waveExWrit:

; 1080 : 			return PSF_E_CANT_WRITE;

  005b7	b8 fd ff ff ff	 mov	 eax, -3
  005bc	e9 be 00 00 00	 jmp	 $LN1@waveExWrit
$LN29@waveExWrit:
$LN23@waveExWrit:

; 1081 : 	}
; 1082 : 	
; 1083 : 	tag = TAG('d','a','t','a');	

  005c1	c7 44 24 20 61
	74 61 64	 mov	 DWORD PTR tag$[rsp], 1684108385 ; 64617461H

; 1084 : 	size = 0;	

  005c9	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR size$[rsp], 0

; 1085 : 	if(sfdat->is_little_endian)

  005d1	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  005d6	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  005da	74 3d		 je	 SHORT $LN31@waveExWrit

; 1086 : 		tag = REVDWBYTES(tag);

  005dc	8b 44 24 20	 mov	 eax, DWORD PTR tag$[rsp]
  005e0	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  005e5	c1 e0 18	 shl	 eax, 24
  005e8	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  005ec	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  005f2	c1 e1 08	 shl	 ecx, 8
  005f5	0b c1		 or	 eax, ecx
  005f7	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  005fb	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00601	c1 e9 08	 shr	 ecx, 8
  00604	0b c1		 or	 eax, ecx
  00606	8b 4c 24 20	 mov	 ecx, DWORD PTR tag$[rsp]
  0060a	c1 e9 18	 shr	 ecx, 24
  0060d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00613	0b c1		 or	 eax, ecx
  00615	89 44 24 20	 mov	 DWORD PTR tag$[rsp], eax
$LN31@waveExWrit:

; 1087 : 	if(wavDoWrite(sfdat,(char *)&tag,sizeof(DWORD))
; 1088 : 		|| wavDoWrite(sfdat,(char *)&size,sizeof(DWORD)))		

  00619	41 b8 04 00 00
	00		 mov	 r8d, 4
  0061f	48 8d 54 24 20	 lea	 rdx, QWORD PTR tag$[rsp]
  00624	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00629	e8 00 00 00 00	 call	 wavDoWrite
  0062e	85 c0		 test	 eax, eax
  00630	75 19		 jne	 SHORT $LN33@waveExWrit
  00632	41 b8 04 00 00
	00		 mov	 r8d, 4
  00638	48 8d 54 24 24	 lea	 rdx, QWORD PTR size$[rsp]
  0063d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00642	e8 00 00 00 00	 call	 wavDoWrite
  00647	85 c0		 test	 eax, eax
  00649	74 07		 je	 SHORT $LN32@waveExWrit
$LN33@waveExWrit:

; 1089 : 		return PSF_E_CANT_WRITE;

  0064b	b8 fd ff ff ff	 mov	 eax, -3
  00650	eb 2d		 jmp	 SHORT $LN1@waveExWrit
$LN32@waveExWrit:

; 1090 : 	if(fgetpos(sfdat->file,&bytepos))

  00652	48 8d 54 24 40	 lea	 rdx, QWORD PTR bytepos$[rsp]
  00657	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  0065c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0065f	e8 00 00 00 00	 call	 fgetpos
  00664	85 c0		 test	 eax, eax
  00666	74 07		 je	 SHORT $LN34@waveExWrit

; 1091 : 	    return PSF_E_CANT_SEEK;

  00668	b8 f5 ff ff ff	 mov	 eax, -11
  0066d	eb 10		 jmp	 SHORT $LN1@waveExWrit
$LN34@waveExWrit:

; 1092 : 	sfdat->dataoffset = bytepos;

  0066f	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00674	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bytepos$[rsp]
  00679	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 1093 : 	return PSF_E_NOERROR;

  0067d	33 c0		 xor	 eax, eax
$LN1@waveExWrit:

; 1094 : }

  0067f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00683	c3		 ret	 0
waveExWriteHeader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
cbSize$ = 32
tag$ = 36
size$ = 40
version$1 = 44
now$2 = 48
bytepos$ = 56
pfmt$ = 64
peaks$ = 72
sfdat$ = 96
wavWriteHeader PROC

; 870  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 871  : 	DWORD tag,size;
; 872  : 	WORD cbSize = 0;

  00009	33 c0		 xor	 eax, eax
  0000b	66 89 44 24 20	 mov	 WORD PTR cbSize$[rsp], ax

; 873  : 	WAVEFORMATEX *pfmt;
; 874  : 	PSF_CHPEAK *peaks;
; 875  :     fpos_t bytepos;
; 876  : #ifdef _DEBUG
; 877  : 	assert(sfdat);
; 878  : 	assert(sfdat->file);
; 879  : 	assert(sfdat->riff_format == PSF_STDWAVE);
; 880  : 	assert(sfdat->nFrames == 0);
; 881  : 	assert(!sfdat->isRead);
; 882  : 	assert(sfdat->fmt.Format.nChannels != 0);
; 883  : #endif
; 884  : 
; 885  : 	/*clear pPeaks array*/
; 886  : 	if(sfdat->pPeaks)

  00010	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00015	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  0001d	74 23		 je	 SHORT $LN2@wavWriteHe

; 887  : 		memset((char *)sfdat->pPeaks,0,sizeof(PSF_CHPEAK) * sfdat->fmt.Format.nChannels);

  0001f	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00024	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  00028	48 c1 e0 03	 shl	 rax, 3
  0002c	4c 8b c0	 mov	 r8, rax
  0002f	33 d2		 xor	 edx, edx
  00031	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00036	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  0003d	e8 00 00 00 00	 call	 memset
$LN2@wavWriteHe:

; 888  : 
; 889  : 
; 890  : 	tag = TAG('R','I','F','F');

  00042	c7 44 24 24 46
	46 49 52	 mov	 DWORD PTR tag$[rsp], 1380533830 ; 52494646H

; 891  : 	size = 0;

  0004a	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR size$[rsp], 0

; 892  : 	if(!sfdat->is_little_endian)

  00052	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00057	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0005b	75 3f		 jne	 SHORT $LN3@wavWriteHe

; 893  : 		size = REVDWBYTES(size);

  0005d	8b 44 24 28	 mov	 eax, DWORD PTR size$[rsp]
  00061	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00066	c1 e0 18	 shl	 eax, 24
  00069	8b 4c 24 28	 mov	 ecx, DWORD PTR size$[rsp]
  0006d	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00073	c1 e1 08	 shl	 ecx, 8
  00076	0b c1		 or	 eax, ecx
  00078	8b 4c 24 28	 mov	 ecx, DWORD PTR size$[rsp]
  0007c	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00082	c1 e9 08	 shr	 ecx, 8
  00085	0b c1		 or	 eax, ecx
  00087	8b 4c 24 28	 mov	 ecx, DWORD PTR size$[rsp]
  0008b	c1 e9 18	 shr	 ecx, 24
  0008e	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00094	0b c1		 or	 eax, ecx
  00096	89 44 24 28	 mov	 DWORD PTR size$[rsp], eax
  0009a	eb 3d		 jmp	 SHORT $LN4@wavWriteHe
$LN3@wavWriteHe:

; 894  : 	else
; 895  : 		tag = REVDWBYTES(tag);

  0009c	8b 44 24 24	 mov	 eax, DWORD PTR tag$[rsp]
  000a0	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000a5	c1 e0 18	 shl	 eax, 24
  000a8	8b 4c 24 24	 mov	 ecx, DWORD PTR tag$[rsp]
  000ac	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  000b2	c1 e1 08	 shl	 ecx, 8
  000b5	0b c1		 or	 eax, ecx
  000b7	8b 4c 24 24	 mov	 ecx, DWORD PTR tag$[rsp]
  000bb	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  000c1	c1 e9 08	 shr	 ecx, 8
  000c4	0b c1		 or	 eax, ecx
  000c6	8b 4c 24 24	 mov	 ecx, DWORD PTR tag$[rsp]
  000ca	c1 e9 18	 shr	 ecx, 24
  000cd	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000d3	0b c1		 or	 eax, ecx
  000d5	89 44 24 24	 mov	 DWORD PTR tag$[rsp], eax
$LN4@wavWriteHe:

; 896  : 	
; 897  : 
; 898  : 	if(wavDoWrite(sfdat,(char *)&tag,sizeof(DWORD))
; 899  : 		|| wavDoWrite(sfdat,(char *)&size,sizeof(DWORD)))

  000d9	41 b8 04 00 00
	00		 mov	 r8d, 4
  000df	48 8d 54 24 24	 lea	 rdx, QWORD PTR tag$[rsp]
  000e4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  000e9	e8 00 00 00 00	 call	 wavDoWrite
  000ee	85 c0		 test	 eax, eax
  000f0	75 19		 jne	 SHORT $LN6@wavWriteHe
  000f2	41 b8 04 00 00
	00		 mov	 r8d, 4
  000f8	48 8d 54 24 28	 lea	 rdx, QWORD PTR size$[rsp]
  000fd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00102	e8 00 00 00 00	 call	 wavDoWrite
  00107	85 c0		 test	 eax, eax
  00109	74 0a		 je	 SHORT $LN5@wavWriteHe
$LN6@wavWriteHe:

; 900  : 		return PSF_E_CANT_WRITE;

  0010b	b8 fd ff ff ff	 mov	 eax, -3
  00110	e9 a5 04 00 00	 jmp	 $LN1@wavWriteHe
$LN5@wavWriteHe:

; 901  : 
; 902  : 	tag = TAG('W','A','V','E');

  00115	c7 44 24 24 45
	56 41 57	 mov	 DWORD PTR tag$[rsp], 1463899717 ; 57415645H

; 903  : 	if(sfdat->is_little_endian)

  0011d	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00122	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00126	74 3d		 je	 SHORT $LN7@wavWriteHe

; 904  : 		tag = REVDWBYTES(tag);

  00128	8b 44 24 24	 mov	 eax, DWORD PTR tag$[rsp]
  0012c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00131	c1 e0 18	 shl	 eax, 24
  00134	8b 4c 24 24	 mov	 ecx, DWORD PTR tag$[rsp]
  00138	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  0013e	c1 e1 08	 shl	 ecx, 8
  00141	0b c1		 or	 eax, ecx
  00143	8b 4c 24 24	 mov	 ecx, DWORD PTR tag$[rsp]
  00147	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  0014d	c1 e9 08	 shr	 ecx, 8
  00150	0b c1		 or	 eax, ecx
  00152	8b 4c 24 24	 mov	 ecx, DWORD PTR tag$[rsp]
  00156	c1 e9 18	 shr	 ecx, 24
  00159	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0015f	0b c1		 or	 eax, ecx
  00161	89 44 24 24	 mov	 DWORD PTR tag$[rsp], eax
$LN7@wavWriteHe:

; 905  : 	if(wavDoWrite(sfdat,(char *)&tag,sizeof(DWORD)))

  00165	41 b8 04 00 00
	00		 mov	 r8d, 4
  0016b	48 8d 54 24 24	 lea	 rdx, QWORD PTR tag$[rsp]
  00170	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00175	e8 00 00 00 00	 call	 wavDoWrite
  0017a	85 c0		 test	 eax, eax
  0017c	74 0a		 je	 SHORT $LN8@wavWriteHe

; 906  : 		return PSF_E_CANT_WRITE;

  0017e	b8 fd ff ff ff	 mov	 eax, -3
  00183	e9 32 04 00 00	 jmp	 $LN1@wavWriteHe
$LN8@wavWriteHe:

; 907  : 
; 908  : 	pfmt = &(sfdat->fmt.Format);

  00188	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  0018d	48 83 c0 50	 add	 rax, 80			; 00000050H
  00191	48 89 44 24 40	 mov	 QWORD PTR pfmt$[rsp], rax

; 909  : 
; 910  : 	tag = TAG('f','m','t',' ');	

  00196	c7 44 24 24 20
	74 6d 66	 mov	 DWORD PTR tag$[rsp], 1718449184 ; 666d7420H

; 911  : 	size = sizeof(WAVEFORMAT);

  0019e	c7 44 24 28 10
	00 00 00	 mov	 DWORD PTR size$[rsp], 16

; 912  : 	if(sfdat->samptype==PSF_SAMP_IEEE_FLOAT)

  001a6	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  001ab	83 78 30 05	 cmp	 DWORD PTR [rax+48], 5
  001af	75 0c		 jne	 SHORT $LN9@wavWriteHe

; 913  : 		size += sizeof(WORD);		  /* for cbSize: WAVEOFRMATEX */

  001b1	8b 44 24 28	 mov	 eax, DWORD PTR size$[rsp]
  001b5	48 83 c0 02	 add	 rax, 2
  001b9	89 44 24 28	 mov	 DWORD PTR size$[rsp], eax
$LN9@wavWriteHe:

; 914  : 	if(!sfdat->is_little_endian){

  001bd	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  001c2	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  001c6	75 49		 jne	 SHORT $LN10@wavWriteHe

; 915  : 		size = REVDWBYTES(size);

  001c8	8b 44 24 28	 mov	 eax, DWORD PTR size$[rsp]
  001cc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001d1	c1 e0 18	 shl	 eax, 24
  001d4	8b 4c 24 28	 mov	 ecx, DWORD PTR size$[rsp]
  001d8	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  001de	c1 e1 08	 shl	 ecx, 8
  001e1	0b c1		 or	 eax, ecx
  001e3	8b 4c 24 28	 mov	 ecx, DWORD PTR size$[rsp]
  001e7	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  001ed	c1 e9 08	 shr	 ecx, 8
  001f0	0b c1		 or	 eax, ecx
  001f2	8b 4c 24 28	 mov	 ecx, DWORD PTR size$[rsp]
  001f6	c1 e9 18	 shr	 ecx, 24
  001f9	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  001ff	0b c1		 or	 eax, ecx
  00201	89 44 24 28	 mov	 DWORD PTR size$[rsp], eax

; 916  : 		fmtSwapBytes(sfdat);

  00205	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0020a	e8 00 00 00 00	 call	 fmtSwapBytes

; 917  : 	}

  0020f	eb 3d		 jmp	 SHORT $LN11@wavWriteHe
$LN10@wavWriteHe:

; 918  : 	else
; 919  : 		tag = REVDWBYTES(tag);

  00211	8b 44 24 24	 mov	 eax, DWORD PTR tag$[rsp]
  00215	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0021a	c1 e0 18	 shl	 eax, 24
  0021d	8b 4c 24 24	 mov	 ecx, DWORD PTR tag$[rsp]
  00221	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00227	c1 e1 08	 shl	 ecx, 8
  0022a	0b c1		 or	 eax, ecx
  0022c	8b 4c 24 24	 mov	 ecx, DWORD PTR tag$[rsp]
  00230	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00236	c1 e9 08	 shr	 ecx, 8
  00239	0b c1		 or	 eax, ecx
  0023b	8b 4c 24 24	 mov	 ecx, DWORD PTR tag$[rsp]
  0023f	c1 e9 18	 shr	 ecx, 24
  00242	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00248	0b c1		 or	 eax, ecx
  0024a	89 44 24 24	 mov	 DWORD PTR tag$[rsp], eax
$LN11@wavWriteHe:

; 920  : 	if(wavDoWrite(sfdat,(char *)&tag,sizeof(DWORD))
; 921  : 		|| wavDoWrite(sfdat,(char *)&size,sizeof(DWORD)))		

  0024e	41 b8 04 00 00
	00		 mov	 r8d, 4
  00254	48 8d 54 24 24	 lea	 rdx, QWORD PTR tag$[rsp]
  00259	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0025e	e8 00 00 00 00	 call	 wavDoWrite
  00263	85 c0		 test	 eax, eax
  00265	75 19		 jne	 SHORT $LN13@wavWriteHe
  00267	41 b8 04 00 00
	00		 mov	 r8d, 4
  0026d	48 8d 54 24 28	 lea	 rdx, QWORD PTR size$[rsp]
  00272	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00277	e8 00 00 00 00	 call	 wavDoWrite
  0027c	85 c0		 test	 eax, eax
  0027e	74 0a		 je	 SHORT $LN12@wavWriteHe
$LN13@wavWriteHe:

; 922  : 		return PSF_E_CANT_WRITE;

  00280	b8 fd ff ff ff	 mov	 eax, -3
  00285	e9 30 03 00 00	 jmp	 $LN1@wavWriteHe
$LN12@wavWriteHe:

; 923  :         if(fgetpos(sfdat->file,&bytepos))

  0028a	48 8d 54 24 38	 lea	 rdx, QWORD PTR bytepos$[rsp]
  0028f	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00294	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00297	e8 00 00 00 00	 call	 fgetpos
  0029c	85 c0		 test	 eax, eax
  0029e	74 0a		 je	 SHORT $LN14@wavWriteHe

; 924  : 	    return PSF_E_CANT_SEEK;

  002a0	b8 f5 ff ff ff	 mov	 eax, -11
  002a5	e9 10 03 00 00	 jmp	 $LN1@wavWriteHe
$LN14@wavWriteHe:

; 925  : 	sfdat->fmtoffset = bytepos;

  002aa	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  002af	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bytepos$[rsp]
  002b4	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 926  : 	
; 927  : 	if(wavDoWrite(sfdat,(char *)pfmt,sizeof(WAVEFORMAT)))

  002b8	41 b8 10 00 00
	00		 mov	 r8d, 16
  002be	48 8b 54 24 40	 mov	 rdx, QWORD PTR pfmt$[rsp]
  002c3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  002c8	e8 00 00 00 00	 call	 wavDoWrite
  002cd	85 c0		 test	 eax, eax
  002cf	74 0a		 je	 SHORT $LN15@wavWriteHe

; 928  : 		return PSF_E_CANT_WRITE;

  002d1	b8 fd ff ff ff	 mov	 eax, -3
  002d6	e9 df 02 00 00	 jmp	 $LN1@wavWriteHe
$LN15@wavWriteHe:

; 929  : 	/*add cbSize if floatsams */
; 930  : 	if(sfdat->samptype==PSF_SAMP_IEEE_FLOAT)

  002db	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  002e0	83 78 30 05	 cmp	 DWORD PTR [rax+48], 5
  002e4	75 23		 jne	 SHORT $LN16@wavWriteHe

; 931  : 		if(wavDoWrite(sfdat,(char *)&cbSize,sizeof(WORD)))

  002e6	41 b8 02 00 00
	00		 mov	 r8d, 2
  002ec	48 8d 54 24 20	 lea	 rdx, QWORD PTR cbSize$[rsp]
  002f1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  002f6	e8 00 00 00 00	 call	 wavDoWrite
  002fb	85 c0		 test	 eax, eax
  002fd	74 0a		 je	 SHORT $LN17@wavWriteHe

; 932  : 			return PSF_E_CANT_WRITE;

  002ff	b8 fd ff ff ff	 mov	 eax, -3
  00304	e9 b1 02 00 00	 jmp	 $LN1@wavWriteHe
$LN17@wavWriteHe:
$LN16@wavWriteHe:

; 933  :         /* reswap it all */
; 934  :         if(!sfdat->is_little_endian){

  00309	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  0030e	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00312	75 0a		 jne	 SHORT $LN18@wavWriteHe

; 935  :             fmtSwapBytes(sfdat);

  00314	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00319	e8 00 00 00 00	 call	 fmtSwapBytes
$LN18@wavWriteHe:

; 936  :         }
; 937  :         
; 938  : 	if(sfdat->pPeaks){

  0031e	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00323	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  0032b	0f 84 cb 01 00
	00		 je	 $LN19@wavWriteHe

; 939  : 		DWORD version = 1, now = 0;

  00331	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR version$1[rsp], 1
  00339	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR now$2[rsp], 0

; 940  : 		peaks = sfdat->pPeaks;

  00341	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00346	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0034d	48 89 44 24 48	 mov	 QWORD PTR peaks$[rsp], rax

; 941  : 		
; 942  : 		tag = TAG('P','E','A','K');		

  00352	c7 44 24 24 4b
	41 45 50	 mov	 DWORD PTR tag$[rsp], 1346715979 ; 5045414bH

; 943  : 		size = 2 * sizeof(DWORD) + sizeof(PSF_CHPEAK) * pfmt->nChannels;

  0035a	48 8b 44 24 40	 mov	 rax, QWORD PTR pfmt$[rsp]
  0035f	0f b7 40 02	 movzx	 eax, WORD PTR [rax+2]
  00363	48 8d 04 c5 08
	00 00 00	 lea	 rax, QWORD PTR [rax*8+8]
  0036b	89 44 24 28	 mov	 DWORD PTR size$[rsp], eax

; 944  : 		if(!sfdat->is_little_endian){

  0036f	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00374	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00378	75 7c		 jne	 SHORT $LN20@wavWriteHe

; 945  : 			size = REVDWBYTES(size);

  0037a	8b 44 24 28	 mov	 eax, DWORD PTR size$[rsp]
  0037e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00383	c1 e0 18	 shl	 eax, 24
  00386	8b 4c 24 28	 mov	 ecx, DWORD PTR size$[rsp]
  0038a	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00390	c1 e1 08	 shl	 ecx, 8
  00393	0b c1		 or	 eax, ecx
  00395	8b 4c 24 28	 mov	 ecx, DWORD PTR size$[rsp]
  00399	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  0039f	c1 e9 08	 shr	 ecx, 8
  003a2	0b c1		 or	 eax, ecx
  003a4	8b 4c 24 28	 mov	 ecx, DWORD PTR size$[rsp]
  003a8	c1 e9 18	 shr	 ecx, 24
  003ab	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  003b1	0b c1		 or	 eax, ecx
  003b3	89 44 24 28	 mov	 DWORD PTR size$[rsp], eax

; 946  : 			version  = REVDWBYTES(version);

  003b7	8b 44 24 2c	 mov	 eax, DWORD PTR version$1[rsp]
  003bb	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003c0	c1 e0 18	 shl	 eax, 24
  003c3	8b 4c 24 2c	 mov	 ecx, DWORD PTR version$1[rsp]
  003c7	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  003cd	c1 e1 08	 shl	 ecx, 8
  003d0	0b c1		 or	 eax, ecx
  003d2	8b 4c 24 2c	 mov	 ecx, DWORD PTR version$1[rsp]
  003d6	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  003dc	c1 e9 08	 shr	 ecx, 8
  003df	0b c1		 or	 eax, ecx
  003e1	8b 4c 24 2c	 mov	 ecx, DWORD PTR version$1[rsp]
  003e5	c1 e9 18	 shr	 ecx, 24
  003e8	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  003ee	0b c1		 or	 eax, ecx
  003f0	89 44 24 2c	 mov	 DWORD PTR version$1[rsp], eax

; 947  : 		}

  003f4	eb 3d		 jmp	 SHORT $LN21@wavWriteHe
$LN20@wavWriteHe:

; 948  : 		else
; 949  : 			tag = REVDWBYTES(tag);

  003f6	8b 44 24 24	 mov	 eax, DWORD PTR tag$[rsp]
  003fa	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003ff	c1 e0 18	 shl	 eax, 24
  00402	8b 4c 24 24	 mov	 ecx, DWORD PTR tag$[rsp]
  00406	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  0040c	c1 e1 08	 shl	 ecx, 8
  0040f	0b c1		 or	 eax, ecx
  00411	8b 4c 24 24	 mov	 ecx, DWORD PTR tag$[rsp]
  00415	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  0041b	c1 e9 08	 shr	 ecx, 8
  0041e	0b c1		 or	 eax, ecx
  00420	8b 4c 24 24	 mov	 ecx, DWORD PTR tag$[rsp]
  00424	c1 e9 18	 shr	 ecx, 24
  00427	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0042d	0b c1		 or	 eax, ecx
  0042f	89 44 24 24	 mov	 DWORD PTR tag$[rsp], eax
$LN21@wavWriteHe:

; 950  : 
; 951  : 		if(wavDoWrite(sfdat,(char *)&tag,sizeof(DWORD))
; 952  : 			|| wavDoWrite(sfdat,(char *)&size,sizeof(DWORD))
; 953  : 			|| wavDoWrite(sfdat,(char *)&version,sizeof(DWORD)))

  00433	41 b8 04 00 00
	00		 mov	 r8d, 4
  00439	48 8d 54 24 24	 lea	 rdx, QWORD PTR tag$[rsp]
  0043e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00443	e8 00 00 00 00	 call	 wavDoWrite
  00448	85 c0		 test	 eax, eax
  0044a	75 32		 jne	 SHORT $LN23@wavWriteHe
  0044c	41 b8 04 00 00
	00		 mov	 r8d, 4
  00452	48 8d 54 24 28	 lea	 rdx, QWORD PTR size$[rsp]
  00457	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0045c	e8 00 00 00 00	 call	 wavDoWrite
  00461	85 c0		 test	 eax, eax
  00463	75 19		 jne	 SHORT $LN23@wavWriteHe
  00465	41 b8 04 00 00
	00		 mov	 r8d, 4
  0046b	48 8d 54 24 2c	 lea	 rdx, QWORD PTR version$1[rsp]
  00470	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00475	e8 00 00 00 00	 call	 wavDoWrite
  0047a	85 c0		 test	 eax, eax
  0047c	74 0a		 je	 SHORT $LN22@wavWriteHe
$LN23@wavWriteHe:

; 954  : 			return PSF_E_CANT_WRITE;

  0047e	b8 fd ff ff ff	 mov	 eax, -3
  00483	e9 32 01 00 00	 jmp	 $LN1@wavWriteHe
$LN22@wavWriteHe:

; 955  : 		if(fgetpos(sfdat->file,&bytepos))

  00488	48 8d 54 24 38	 lea	 rdx, QWORD PTR bytepos$[rsp]
  0048d	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00492	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00495	e8 00 00 00 00	 call	 fgetpos
  0049a	85 c0		 test	 eax, eax
  0049c	74 0a		 je	 SHORT $LN24@wavWriteHe

; 956  : 		    return PSF_E_CANT_SEEK;

  0049e	b8 f5 ff ff ff	 mov	 eax, -11
  004a3	e9 12 01 00 00	 jmp	 $LN1@wavWriteHe
$LN24@wavWriteHe:

; 957  : 		sfdat->peakoffset = bytepos;  /*we need to update time*/

  004a8	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  004ad	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bytepos$[rsp]
  004b2	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 958  : 
; 959  : 		if(wavDoWrite(sfdat,(char *) &now,sizeof(DWORD))
; 960  : 			|| wavDoWrite(sfdat,(char *) peaks, sizeof(PSF_CHPEAK) * sfdat->fmt.Format.nChannels))

  004b6	41 b8 04 00 00
	00		 mov	 r8d, 4
  004bc	48 8d 54 24 30	 lea	 rdx, QWORD PTR now$2[rsp]
  004c1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  004c6	e8 00 00 00 00	 call	 wavDoWrite
  004cb	85 c0		 test	 eax, eax
  004cd	75 23		 jne	 SHORT $LN26@wavWriteHe
  004cf	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  004d4	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  004d8	48 c1 e0 03	 shl	 rax, 3
  004dc	44 8b c0	 mov	 r8d, eax
  004df	48 8b 54 24 48	 mov	 rdx, QWORD PTR peaks$[rsp]
  004e4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  004e9	e8 00 00 00 00	 call	 wavDoWrite
  004ee	85 c0		 test	 eax, eax
  004f0	74 0a		 je	 SHORT $LN25@wavWriteHe
$LN26@wavWriteHe:

; 961  : 			return PSF_E_CANT_WRITE;

  004f2	b8 fd ff ff ff	 mov	 eax, -3
  004f7	e9 be 00 00 00	 jmp	 $LN1@wavWriteHe
$LN25@wavWriteHe:
$LN19@wavWriteHe:

; 962  : 	}	
; 963  : 	tag = TAG('d','a','t','a');	

  004fc	c7 44 24 24 61
	74 61 64	 mov	 DWORD PTR tag$[rsp], 1684108385 ; 64617461H

; 964  : 	size = 0;	

  00504	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR size$[rsp], 0

; 965  : 	if(sfdat->is_little_endian)

  0050c	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00511	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00515	74 3d		 je	 SHORT $LN27@wavWriteHe

; 966  : 		tag = REVDWBYTES(tag);

  00517	8b 44 24 24	 mov	 eax, DWORD PTR tag$[rsp]
  0051b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00520	c1 e0 18	 shl	 eax, 24
  00523	8b 4c 24 24	 mov	 ecx, DWORD PTR tag$[rsp]
  00527	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  0052d	c1 e1 08	 shl	 ecx, 8
  00530	0b c1		 or	 eax, ecx
  00532	8b 4c 24 24	 mov	 ecx, DWORD PTR tag$[rsp]
  00536	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  0053c	c1 e9 08	 shr	 ecx, 8
  0053f	0b c1		 or	 eax, ecx
  00541	8b 4c 24 24	 mov	 ecx, DWORD PTR tag$[rsp]
  00545	c1 e9 18	 shr	 ecx, 24
  00548	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0054e	0b c1		 or	 eax, ecx
  00550	89 44 24 24	 mov	 DWORD PTR tag$[rsp], eax
$LN27@wavWriteHe:

; 967  : 	if(wavDoWrite(sfdat,(char *)&tag,sizeof(DWORD))
; 968  : 		|| wavDoWrite(sfdat,(char *)&size,sizeof(DWORD)))		

  00554	41 b8 04 00 00
	00		 mov	 r8d, 4
  0055a	48 8d 54 24 24	 lea	 rdx, QWORD PTR tag$[rsp]
  0055f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00564	e8 00 00 00 00	 call	 wavDoWrite
  00569	85 c0		 test	 eax, eax
  0056b	75 19		 jne	 SHORT $LN29@wavWriteHe
  0056d	41 b8 04 00 00
	00		 mov	 r8d, 4
  00573	48 8d 54 24 28	 lea	 rdx, QWORD PTR size$[rsp]
  00578	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0057d	e8 00 00 00 00	 call	 wavDoWrite
  00582	85 c0		 test	 eax, eax
  00584	74 07		 je	 SHORT $LN28@wavWriteHe
$LN29@wavWriteHe:

; 969  : 		return PSF_E_CANT_WRITE;

  00586	b8 fd ff ff ff	 mov	 eax, -3
  0058b	eb 2d		 jmp	 SHORT $LN1@wavWriteHe
$LN28@wavWriteHe:

; 970  : 	if(fgetpos(sfdat->file,&bytepos))

  0058d	48 8d 54 24 38	 lea	 rdx, QWORD PTR bytepos$[rsp]
  00592	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00597	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0059a	e8 00 00 00 00	 call	 fgetpos
  0059f	85 c0		 test	 eax, eax
  005a1	74 07		 je	 SHORT $LN30@wavWriteHe

; 971  : 	    return PSF_E_CANT_SEEK;

  005a3	b8 f5 ff ff ff	 mov	 eax, -11
  005a8	eb 10		 jmp	 SHORT $LN1@wavWriteHe
$LN30@wavWriteHe:

; 972  : 	sfdat->dataoffset = bytepos;	

  005aa	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  005af	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bytepos$[rsp]
  005b4	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 973  : 	return PSF_E_NOERROR;

  005b8	33 c0		 xor	 eax, eax
$LN1@wavWriteHe:

; 974  : }

  005ba	48 83 c4 58	 add	 rsp, 88			; 00000058H
  005be	c3		 ret	 0
wavWriteHeader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
got$ = 32
sfdat$ = 64
buf$ = 72
nBytes$ = 80
wavDoRead PROC

; 849  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 850  : 	
; 851  : 	DWORD got = 0;

  00013	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR got$[rsp], 0

; 852  : 	if(sfdat==NULL || buf==NULL)

  0001b	48 83 7c 24 40
	00		 cmp	 QWORD PTR sfdat$[rsp], 0
  00021	74 08		 je	 SHORT $LN3@wavDoRead
  00023	48 83 7c 24 48
	00		 cmp	 QWORD PTR buf$[rsp], 0
  00029	75 07		 jne	 SHORT $LN2@wavDoRead
$LN3@wavDoRead:

; 853  : 		return PSF_E_BADARG;

  0002b	b8 f6 ff ff ff	 mov	 eax, -10
  00030	eb 56		 jmp	 SHORT $LN1@wavDoRead
$LN2@wavDoRead:

; 854  : 
; 855  : 	if(sfdat->file==NULL)

  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  00037	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0003b	75 07		 jne	 SHORT $LN4@wavDoRead

; 856  : 		return PSF_E_CANT_READ;

  0003d	b8 fc ff ff ff	 mov	 eax, -4
  00042	eb 44		 jmp	 SHORT $LN1@wavDoRead
$LN4@wavDoRead:

; 857  : 
; 858  : 	if((got = fread(buf,sizeof(char),nBytes,sfdat->file)) != nBytes) {

  00044	8b 44 24 50	 mov	 eax, DWORD PTR nBytes$[rsp]
  00048	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0004d	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  00050	44 8b c0	 mov	 r8d, eax
  00053	ba 01 00 00 00	 mov	 edx, 1
  00058	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buf$[rsp]
  0005d	e8 00 00 00 00	 call	 fread
  00062	89 44 24 20	 mov	 DWORD PTR got$[rsp], eax
  00066	8b 44 24 50	 mov	 eax, DWORD PTR nBytes$[rsp]
  0006a	39 44 24 20	 cmp	 DWORD PTR got$[rsp], eax
  0006e	74 07		 je	 SHORT $LN5@wavDoRead

; 859  : 		DBGFPRINTF((stderr, "wavDoRead: wanted %d got %d.\n",
; 860  :                     (int) nBytes,(int) got));
; 861  :         return PSF_E_CANT_READ;

  00070	b8 fc ff ff ff	 mov	 eax, -4
  00075	eb 11		 jmp	 SHORT $LN1@wavDoRead
$LN5@wavDoRead:

; 862  :     }
; 863  : 	sfdat->lastop = PSF_OP_READ;

  00077	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  0007c	c7 80 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+152], 0

; 864  : 	return PSF_E_NOERROR;

  00086	33 c0		 xor	 eax, eax
$LN1@wavDoRead:

; 865  : 
; 866  : }

  00088	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008c	c3		 ret	 0
wavDoRead ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
written$ = 32
sfdat$ = 64
buf$ = 72
nBytes$ = 80
wavDoWrite PROC

; 830  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 831  : 	
; 832  : 	DWORD written = 0;

  00013	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR written$[rsp], 0

; 833  : 	if(sfdat==NULL || buf==NULL)

  0001b	48 83 7c 24 40
	00		 cmp	 QWORD PTR sfdat$[rsp], 0
  00021	74 08		 je	 SHORT $LN3@wavDoWrite
  00023	48 83 7c 24 48
	00		 cmp	 QWORD PTR buf$[rsp], 0
  00029	75 07		 jne	 SHORT $LN2@wavDoWrite
$LN3@wavDoWrite:

; 834  : 		return PSF_E_BADARG;

  0002b	b8 f6 ff ff ff	 mov	 eax, -10
  00030	eb 56		 jmp	 SHORT $LN1@wavDoWrite
$LN2@wavDoWrite:

; 835  : 
; 836  : 	if(sfdat->file==NULL)

  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  00037	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0003b	75 07		 jne	 SHORT $LN4@wavDoWrite

; 837  : 		return PSF_E_CANT_WRITE;

  0003d	b8 fd ff ff ff	 mov	 eax, -3
  00042	eb 44		 jmp	 SHORT $LN1@wavDoWrite
$LN4@wavDoWrite:

; 838  : 
; 839  : 	if((written = fwrite(buf,sizeof(char),nBytes,sfdat->file)) != nBytes) {

  00044	8b 44 24 50	 mov	 eax, DWORD PTR nBytes$[rsp]
  00048	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0004d	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  00050	44 8b c0	 mov	 r8d, eax
  00053	ba 01 00 00 00	 mov	 edx, 1
  00058	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buf$[rsp]
  0005d	e8 00 00 00 00	 call	 fwrite
  00062	89 44 24 20	 mov	 DWORD PTR written$[rsp], eax
  00066	8b 44 24 50	 mov	 eax, DWORD PTR nBytes$[rsp]
  0006a	39 44 24 20	 cmp	 DWORD PTR written$[rsp], eax
  0006e	74 07		 je	 SHORT $LN5@wavDoWrite

; 840  : 		DBGFPRINTF((stderr, "wavDoWrite: wanted %d got %d.\n",
; 841  :                     (int) nBytes,(int) written));
; 842  :         return PSF_E_CANT_WRITE;

  00070	b8 fd ff ff ff	 mov	 eax, -3
  00075	eb 11		 jmp	 SHORT $LN1@wavDoWrite
$LN5@wavDoWrite:

; 843  :     }
; 844  : 	sfdat->lastop  = PSF_OP_WRITE;

  00077	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  0007c	c7 80 98 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+152], 1

; 845  : 	return PSF_E_NOERROR;

  00086	33 c0		 xor	 eax, eax
$LN1@wavDoWrite:

; 846  : }

  00088	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008c	c3		 ret	 0
wavDoWrite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
i$1 = 32
datasize$ = 36
pad$ = 40
aiffsize$ = 44
frames$ = 48
bytepos$ = 56
now$2 = 64
rev_datasize$ = 72
pblock$3 = 80
filesize$ = 88
sfdat$ = 112
aiffUpdate PROC

; 739  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 740  : 	DWORD aiffsize,datasize,rev_datasize,frames;
; 741  : 	fpos_t bytepos,filesize;
; 742  : 	unsigned char pad = 0x00;

  00009	c6 44 24 28 00	 mov	 BYTE PTR pad$[rsp], 0

; 743  : 
; 744  : 	if(sfdat==NULL || sfdat->file== NULL)

  0000e	48 83 7c 24 70
	00		 cmp	 QWORD PTR sfdat$[rsp], 0
  00014	74 0b		 je	 SHORT $LN6@aiffUpdate
  00016	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  0001b	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0001f	75 0a		 jne	 SHORT $LN5@aiffUpdate
$LN6@aiffUpdate:

; 745  : 		return PSF_E_BADARG;

  00021	b8 f6 ff ff ff	 mov	 eax, -10
  00026	e9 d6 04 00 00	 jmp	 $LN1@aiffUpdate
$LN5@aiffUpdate:

; 746  : 
; 747  : 	if(POS64(sfdat->dataoffset)  == 0)

  0002b	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  00030	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00035	75 0a		 jne	 SHORT $LN7@aiffUpdate

; 748  : 		return PSF_E_BADARG;

  00037	b8 f6 ff ff ff	 mov	 eax, -10
  0003c	e9 c0 04 00 00	 jmp	 $LN1@aiffUpdate
$LN7@aiffUpdate:

; 749  : 	POS64(bytepos) = sizeof(int);

  00041	48 c7 44 24 38
	04 00 00 00	 mov	 QWORD PTR bytepos$[rsp], 4

; 750  : 	if((fsetpos(sfdat->file,&bytepos))==0) {

  0004a	48 8d 54 24 38	 lea	 rdx, QWORD PTR bytepos$[rsp]
  0004f	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  00054	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00057	e8 00 00 00 00	 call	 fsetpos
  0005c	85 c0		 test	 eax, eax
  0005e	0f 85 9f 00 00
	00		 jne	 $LN8@aiffUpdate

; 751  : 		/* RWD 26:10:2002 */
; 752  :             /* RWD Nov 2003: dataoffset includes first two DWORDS in file, which must not be counted here! */
; 753  : 		aiffsize = (sfdat->nFrames * sfdat->fmt.Format.nBlockAlign) 

  00064	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  00069	0f b7 40 5c	 movzx	 eax, WORD PTR [rax+92]
  0006d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00072	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00075	0f af c8	 imul	 ecx, eax
  00078	8b c1		 mov	 eax, ecx
  0007a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0007f	03 41 38	 add	 eax, DWORD PTR [rcx+56]
  00082	8b c0		 mov	 eax, eax
  00084	48 83 e8 08	 sub	 rax, 8
  00088	89 44 24 2c	 mov	 DWORD PTR aiffsize$[rsp], eax

; 754  :             + (MYLONG) POS64(sfdat->dataoffset) - (2 * sizeof(DWORD));
; 755  : 		if(sfdat->is_little_endian)

  0008c	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  00091	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00095	74 3d		 je	 SHORT $LN10@aiffUpdate

; 756  : 			aiffsize = REVDWBYTES(aiffsize);

  00097	8b 44 24 2c	 mov	 eax, DWORD PTR aiffsize$[rsp]
  0009b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000a0	c1 e0 18	 shl	 eax, 24
  000a3	8b 4c 24 2c	 mov	 ecx, DWORD PTR aiffsize$[rsp]
  000a7	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  000ad	c1 e1 08	 shl	 ecx, 8
  000b0	0b c1		 or	 eax, ecx
  000b2	8b 4c 24 2c	 mov	 ecx, DWORD PTR aiffsize$[rsp]
  000b6	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  000bc	c1 e9 08	 shr	 ecx, 8
  000bf	0b c1		 or	 eax, ecx
  000c1	8b 4c 24 2c	 mov	 ecx, DWORD PTR aiffsize$[rsp]
  000c5	c1 e9 18	 shr	 ecx, 24
  000c8	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000ce	0b c1		 or	 eax, ecx
  000d0	89 44 24 2c	 mov	 DWORD PTR aiffsize$[rsp], eax
$LN10@aiffUpdate:

; 757  : 		if(fwrite((char *) &aiffsize,sizeof(DWORD),1,sfdat->file) != 1)

  000d4	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  000d9	4c 8b 08	 mov	 r9, QWORD PTR [rax]
  000dc	41 b8 01 00 00
	00		 mov	 r8d, 1
  000e2	ba 04 00 00 00	 mov	 edx, 4
  000e7	48 8d 4c 24 2c	 lea	 rcx, QWORD PTR aiffsize$[rsp]
  000ec	e8 00 00 00 00	 call	 fwrite
  000f1	48 83 f8 01	 cmp	 rax, 1
  000f5	74 0a		 je	 SHORT $LN11@aiffUpdate

; 758  : 			return PSF_E_CANT_WRITE;

  000f7	b8 fd ff ff ff	 mov	 eax, -3
  000fc	e9 00 04 00 00	 jmp	 $LN1@aiffUpdate
$LN11@aiffUpdate:

; 759  : 	}

  00101	eb 0a		 jmp	 SHORT $LN9@aiffUpdate
$LN8@aiffUpdate:

; 760  : 	else
; 761  : 		return PSF_E_CANT_SEEK;	

  00103	b8 f5 ff ff ff	 mov	 eax, -11
  00108	e9 f4 03 00 00	 jmp	 $LN1@aiffUpdate
$LN9@aiffUpdate:

; 762  :     POS64(bytepos)  = POS64(sfdat->fmtoffset) + sizeof(WORD);

  0010d	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  00112	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00116	48 83 c0 02	 add	 rax, 2
  0011a	48 89 44 24 38	 mov	 QWORD PTR bytepos$[rsp], rax

; 763  : 	if((fsetpos(sfdat->file,&bytepos))==0) {

  0011f	48 8d 54 24 38	 lea	 rdx, QWORD PTR bytepos$[rsp]
  00124	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  00129	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0012c	e8 00 00 00 00	 call	 fsetpos
  00131	85 c0		 test	 eax, eax
  00133	0f 85 83 00 00
	00		 jne	 $LN12@aiffUpdate

; 764  : 		frames = sfdat->nFrames;		

  00139	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  0013e	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00141	89 44 24 30	 mov	 DWORD PTR frames$[rsp], eax

; 765  : 		if(sfdat->is_little_endian)

  00145	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  0014a	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0014e	74 3d		 je	 SHORT $LN14@aiffUpdate

; 766  : 			frames = REVDWBYTES(frames);

  00150	8b 44 24 30	 mov	 eax, DWORD PTR frames$[rsp]
  00154	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00159	c1 e0 18	 shl	 eax, 24
  0015c	8b 4c 24 30	 mov	 ecx, DWORD PTR frames$[rsp]
  00160	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00166	c1 e1 08	 shl	 ecx, 8
  00169	0b c1		 or	 eax, ecx
  0016b	8b 4c 24 30	 mov	 ecx, DWORD PTR frames$[rsp]
  0016f	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00175	c1 e9 08	 shr	 ecx, 8
  00178	0b c1		 or	 eax, ecx
  0017a	8b 4c 24 30	 mov	 ecx, DWORD PTR frames$[rsp]
  0017e	c1 e9 18	 shr	 ecx, 24
  00181	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00187	0b c1		 or	 eax, ecx
  00189	89 44 24 30	 mov	 DWORD PTR frames$[rsp], eax
$LN14@aiffUpdate:

; 767  : 		if(fwrite((char *) &frames,sizeof(DWORD),1,sfdat->file) != 1)

  0018d	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  00192	4c 8b 08	 mov	 r9, QWORD PTR [rax]
  00195	41 b8 01 00 00
	00		 mov	 r8d, 1
  0019b	ba 04 00 00 00	 mov	 edx, 4
  001a0	48 8d 4c 24 30	 lea	 rcx, QWORD PTR frames$[rsp]
  001a5	e8 00 00 00 00	 call	 fwrite
  001aa	48 83 f8 01	 cmp	 rax, 1
  001ae	74 0a		 je	 SHORT $LN15@aiffUpdate

; 768  : 			return PSF_E_CANT_WRITE;

  001b0	b8 fd ff ff ff	 mov	 eax, -3
  001b5	e9 47 03 00 00	 jmp	 $LN1@aiffUpdate
$LN15@aiffUpdate:

; 769  : 	}

  001ba	eb 0a		 jmp	 SHORT $LN13@aiffUpdate
$LN12@aiffUpdate:

; 770  : 	else
; 771  : 		return PSF_E_CANT_SEEK;

  001bc	b8 f5 ff ff ff	 mov	 eax, -11
  001c1	e9 3b 03 00 00	 jmp	 $LN1@aiffUpdate
$LN13@aiffUpdate:

; 772  : 	if(sfdat->pPeaks){		

  001c6	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  001cb	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  001d3	0f 84 bf 01 00
	00		 je	 $LN16@aiffUpdate

; 773  :         if(POS64(sfdat->peakoffset)==0)

  001d9	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  001de	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  001e3	75 0a		 jne	 SHORT $LN17@aiffUpdate

; 774  : 			return PSF_E_BADARG;

  001e5	b8 f6 ff ff ff	 mov	 eax, -10
  001ea	e9 12 03 00 00	 jmp	 $LN1@aiffUpdate
$LN17@aiffUpdate:

; 775  : 		
; 776  : 		/*do byterev if necessary...*/
; 777  : 		if((fsetpos(sfdat->file,&sfdat->peakoffset))==0){

  001ef	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  001f4	48 83 c0 48	 add	 rax, 72			; 00000048H
  001f8	48 8b d0	 mov	 rdx, rax
  001fb	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  00200	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00203	e8 00 00 00 00	 call	 fsetpos
  00208	85 c0		 test	 eax, eax
  0020a	0f 85 7e 01 00
	00		 jne	 $LN18@aiffUpdate

; 778  : 			/*set current time*/
; 779  : 			DWORD *pblock;
; 780  : 			int i;
; 781  : 			time_t now = time(0);

  00210	33 c9		 xor	 ecx, ecx
  00212	e8 00 00 00 00	 call	 time
  00217	48 89 44 24 40	 mov	 QWORD PTR now$2[rsp], rax

; 782  : 			if(sfdat->is_little_endian){

  0021c	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  00221	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00225	0f 84 f2 00 00
	00		 je	 $LN20@aiffUpdate

; 783  : 				now = REVDWBYTES(now);

  0022b	48 8b 44 24 40	 mov	 rax, QWORD PTR now$2[rsp]
  00230	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  00236	48 c1 e0 18	 shl	 rax, 24
  0023a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR now$2[rsp]
  0023f	48 81 e1 00 ff
	00 00		 and	 rcx, 65280		; 0000ff00H
  00246	48 c1 e1 08	 shl	 rcx, 8
  0024a	48 0b c1	 or	 rax, rcx
  0024d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR now$2[rsp]
  00252	48 81 e1 00 00
	ff 00		 and	 rcx, 16711680		; 00ff0000H
  00259	48 c1 f9 08	 sar	 rcx, 8
  0025d	48 0b c1	 or	 rax, rcx
  00260	48 8b 4c 24 40	 mov	 rcx, QWORD PTR now$2[rsp]
  00265	48 c1 f9 18	 sar	 rcx, 24
  00269	48 81 e1 ff 00
	00 00		 and	 rcx, 255		; 000000ffH
  00270	48 0b c1	 or	 rax, rcx
  00273	48 89 44 24 40	 mov	 QWORD PTR now$2[rsp], rax

; 784  : 				pblock = (DWORD *) (sfdat->pPeaks);

  00278	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  0027d	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00284	48 89 44 24 50	 mov	 QWORD PTR pblock$3[rsp], rax

; 785  : 				for(i=0;i < sfdat->fmt.Format.nChannels * 2; i++)

  00289	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00291	eb 0a		 jmp	 SHORT $LN4@aiffUpdate
$LN2@aiffUpdate:
  00293	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00297	ff c0		 inc	 eax
  00299	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN4@aiffUpdate:
  0029d	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  002a2	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  002a6	d1 e0		 shl	 eax, 1
  002a8	39 44 24 20	 cmp	 DWORD PTR i$1[rsp], eax
  002ac	7d 6f		 jge	 SHORT $LN3@aiffUpdate

; 786  : 					pblock[i] = REVDWBYTES(pblock[i]);

  002ae	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  002b3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pblock$3[rsp]
  002b8	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  002bb	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002c0	c1 e0 18	 shl	 eax, 24
  002c3	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$1[rsp]
  002c8	48 8b 54 24 50	 mov	 rdx, QWORD PTR pblock$3[rsp]
  002cd	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  002d0	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  002d6	c1 e1 08	 shl	 ecx, 8
  002d9	0b c1		 or	 eax, ecx
  002db	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$1[rsp]
  002e0	48 8b 54 24 50	 mov	 rdx, QWORD PTR pblock$3[rsp]
  002e5	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  002e8	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  002ee	c1 e9 08	 shr	 ecx, 8
  002f1	0b c1		 or	 eax, ecx
  002f3	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$1[rsp]
  002f8	48 8b 54 24 50	 mov	 rdx, QWORD PTR pblock$3[rsp]
  002fd	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  00300	c1 e9 18	 shr	 ecx, 24
  00303	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00309	0b c1		 or	 eax, ecx
  0030b	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00310	48 8b 54 24 50	 mov	 rdx, QWORD PTR pblock$3[rsp]
  00315	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  00318	e9 76 ff ff ff	 jmp	 $LN2@aiffUpdate
$LN3@aiffUpdate:
$LN20@aiffUpdate:

; 787  : 			}
; 788  : 			if((fwrite((char*)&now,sizeof(DWORD),1,sfdat->file)) != 1)

  0031d	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  00322	4c 8b 08	 mov	 r9, QWORD PTR [rax]
  00325	41 b8 01 00 00
	00		 mov	 r8d, 1
  0032b	ba 04 00 00 00	 mov	 edx, 4
  00330	48 8d 4c 24 40	 lea	 rcx, QWORD PTR now$2[rsp]
  00335	e8 00 00 00 00	 call	 fwrite
  0033a	48 83 f8 01	 cmp	 rax, 1
  0033e	74 0a		 je	 SHORT $LN21@aiffUpdate

; 789  : 				return PSF_E_CANT_WRITE;

  00340	b8 fd ff ff ff	 mov	 eax, -3
  00345	e9 b7 01 00 00	 jmp	 $LN1@aiffUpdate
$LN21@aiffUpdate:

; 790  : 
; 791  : 			if((fwrite((char *) (sfdat->pPeaks),sizeof(PSF_CHPEAK),sfdat->fmt.Format.nChannels,sfdat->file))
; 792  : 				!= sfdat->fmt.Format.nChannels )

  0034a	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  0034f	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  00353	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00358	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  0035b	44 8b c0	 mov	 r8d, eax
  0035e	ba 08 00 00 00	 mov	 edx, 8
  00363	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  00368	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  0036f	e8 00 00 00 00	 call	 fwrite
  00374	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00379	0f b7 49 52	 movzx	 ecx, WORD PTR [rcx+82]
  0037d	48 3b c1	 cmp	 rax, rcx
  00380	74 0a		 je	 SHORT $LN22@aiffUpdate

; 793  : 				return PSF_E_CANT_WRITE;

  00382	b8 fd ff ff ff	 mov	 eax, -3
  00387	e9 75 01 00 00	 jmp	 $LN1@aiffUpdate
$LN22@aiffUpdate:

; 794  : 		}

  0038c	eb 0a		 jmp	 SHORT $LN19@aiffUpdate
$LN18@aiffUpdate:

; 795  : 		else
; 796  : 			return PSF_E_CANT_SEEK;

  0038e	b8 f5 ff ff ff	 mov	 eax, -11
  00393	e9 69 01 00 00	 jmp	 $LN1@aiffUpdate
$LN19@aiffUpdate:
$LN16@aiffUpdate:

; 797  : 	}	
; 798  :     POS64(bytepos) = POS64(sfdat->dataoffset) - (3 * sizeof(int));

  00398	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  0039d	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  003a1	48 83 e8 0c	 sub	 rax, 12
  003a5	48 89 44 24 38	 mov	 QWORD PTR bytepos$[rsp], rax

; 799  : 	if((fsetpos(sfdat->file,&bytepos))==0) {			

  003aa	48 8d 54 24 38	 lea	 rdx, QWORD PTR bytepos$[rsp]
  003af	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  003b4	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  003b7	e8 00 00 00 00	 call	 fsetpos
  003bc	85 c0		 test	 eax, eax
  003be	0f 85 a5 00 00
	00		 jne	 $LN23@aiffUpdate

; 800  : 		datasize = sfdat->nFrames * sfdat->fmt.Format.nBlockAlign;

  003c4	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  003c9	0f b7 40 5c	 movzx	 eax, WORD PTR [rax+92]
  003cd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sfdat$[rsp]
  003d2	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  003d5	0f af c8	 imul	 ecx, eax
  003d8	8b c1		 mov	 eax, ecx
  003da	89 44 24 24	 mov	 DWORD PTR datasize$[rsp], eax

; 801  : 		datasize += 2* sizeof(DWORD);	/* add offset and blocksize fields */

  003de	8b 44 24 24	 mov	 eax, DWORD PTR datasize$[rsp]
  003e2	48 83 c0 08	 add	 rax, 8
  003e6	89 44 24 24	 mov	 DWORD PTR datasize$[rsp], eax

; 802  : 		rev_datasize = datasize; /* preserve this for the seek later on */

  003ea	8b 44 24 24	 mov	 eax, DWORD PTR datasize$[rsp]
  003ee	89 44 24 48	 mov	 DWORD PTR rev_datasize$[rsp], eax

; 803  : 		if(sfdat->is_little_endian)

  003f2	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  003f7	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  003fb	74 3d		 je	 SHORT $LN25@aiffUpdate

; 804  : 			rev_datasize = REVDWBYTES(datasize);

  003fd	8b 44 24 24	 mov	 eax, DWORD PTR datasize$[rsp]
  00401	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00406	c1 e0 18	 shl	 eax, 24
  00409	8b 4c 24 24	 mov	 ecx, DWORD PTR datasize$[rsp]
  0040d	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00413	c1 e1 08	 shl	 ecx, 8
  00416	0b c1		 or	 eax, ecx
  00418	8b 4c 24 24	 mov	 ecx, DWORD PTR datasize$[rsp]
  0041c	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00422	c1 e9 08	 shr	 ecx, 8
  00425	0b c1		 or	 eax, ecx
  00427	8b 4c 24 24	 mov	 ecx, DWORD PTR datasize$[rsp]
  0042b	c1 e9 18	 shr	 ecx, 24
  0042e	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00434	0b c1		 or	 eax, ecx
  00436	89 44 24 48	 mov	 DWORD PTR rev_datasize$[rsp], eax
$LN25@aiffUpdate:

; 805  : 		if(fwrite((char *) & rev_datasize,sizeof(DWORD),1,sfdat->file) != 1)

  0043a	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  0043f	4c 8b 08	 mov	 r9, QWORD PTR [rax]
  00442	41 b8 01 00 00
	00		 mov	 r8d, 1
  00448	ba 04 00 00 00	 mov	 edx, 4
  0044d	48 8d 4c 24 48	 lea	 rcx, QWORD PTR rev_datasize$[rsp]
  00452	e8 00 00 00 00	 call	 fwrite
  00457	48 83 f8 01	 cmp	 rax, 1
  0045b	74 0a		 je	 SHORT $LN26@aiffUpdate

; 806  : 			return PSF_E_CANT_WRITE;	

  0045d	b8 fd ff ff ff	 mov	 eax, -3
  00462	e9 9a 00 00 00	 jmp	 $LN1@aiffUpdate
$LN26@aiffUpdate:

; 807  : 	}

  00467	eb 0a		 jmp	 SHORT $LN24@aiffUpdate
$LN23@aiffUpdate:

; 808  : 	else
; 809  : 		return PSF_E_CANT_SEEK;

  00469	b8 f5 ff ff ff	 mov	 eax, -11
  0046e	e9 8e 00 00 00	 jmp	 $LN1@aiffUpdate
$LN24@aiffUpdate:

; 810  : 	/* datachunk needs added pad byte if odd, not included in saved chunksize*/
; 811  :     POS64(bytepos) = POS64(sfdat->dataoffset) + datasize;

  00473	8b 44 24 24	 mov	 eax, DWORD PTR datasize$[rsp]
  00477	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0047c	48 03 41 38	 add	 rax, QWORD PTR [rcx+56]
  00480	48 89 44 24 38	 mov	 QWORD PTR bytepos$[rsp], rax

; 812  : 	if((fsetpos(sfdat->file,&bytepos))){

  00485	48 8d 54 24 38	 lea	 rdx, QWORD PTR bytepos$[rsp]
  0048a	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  0048f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00492	e8 00 00 00 00	 call	 fsetpos
  00497	85 c0		 test	 eax, eax
  00499	74 07		 je	 SHORT $LN27@aiffUpdate

; 813  : 		return PSF_E_CANT_SEEK;

  0049b	b8 f5 ff ff ff	 mov	 eax, -11
  004a0	eb 5f		 jmp	 SHORT $LN1@aiffUpdate
$LN27@aiffUpdate:

; 814  : 	}
; 815  : 	if(fgetpos(sfdat->file,&filesize))

  004a2	48 8d 54 24 58	 lea	 rdx, QWORD PTR filesize$[rsp]
  004a7	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  004ac	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  004af	e8 00 00 00 00	 call	 fgetpos
  004b4	85 c0		 test	 eax, eax
  004b6	74 07		 je	 SHORT $LN28@aiffUpdate

; 816  : 	      return PSF_E_CANT_SEEK;

  004b8	b8 f5 ff ff ff	 mov	 eax, -11
  004bd	eb 42		 jmp	 SHORT $LN1@aiffUpdate
$LN28@aiffUpdate:

; 817  : #ifdef _DEBUG	
; 818  :     assert(POS64(filesize) == POS64(bytepos));
; 819  : #endif	
; 820  :     if(POS64(filesize) % 2)

  004bf	48 8b 44 24 58	 mov	 rax, QWORD PTR filesize$[rsp]
  004c4	48 99		 cdq
  004c6	48 83 e0 01	 and	 rax, 1
  004ca	48 33 c2	 xor	 rax, rdx
  004cd	48 2b c2	 sub	 rax, rdx
  004d0	48 85 c0	 test	 rax, rax
  004d3	74 2a		 je	 SHORT $LN29@aiffUpdate

; 821  : 		if(fwrite(&pad,sizeof(unsigned char),1,sfdat->file) != 1)

  004d5	48 8b 44 24 70	 mov	 rax, QWORD PTR sfdat$[rsp]
  004da	4c 8b 08	 mov	 r9, QWORD PTR [rax]
  004dd	41 b8 01 00 00
	00		 mov	 r8d, 1
  004e3	ba 01 00 00 00	 mov	 edx, 1
  004e8	48 8d 4c 24 28	 lea	 rcx, QWORD PTR pad$[rsp]
  004ed	e8 00 00 00 00	 call	 fwrite
  004f2	48 83 f8 01	 cmp	 rax, 1
  004f6	74 07		 je	 SHORT $LN30@aiffUpdate

; 822  : 			return PSF_E_CANT_WRITE;

  004f8	b8 fd ff ff ff	 mov	 eax, -3
  004fd	eb 02		 jmp	 SHORT $LN1@aiffUpdate
$LN30@aiffUpdate:
$LN29@aiffUpdate:

; 823  : 
; 824  : 	return PSF_E_NOERROR;

  004ff	33 c0		 xor	 eax, eax
$LN1@aiffUpdate:

; 825  : }

  00501	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00505	c3		 ret	 0
aiffUpdate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
riffsize$ = 32
i$1 = 36
datasize$ = 40
now$2 = 48
pblock$3 = 56
bytepos$ = 64
sfdat$ = 96
wavUpdate PROC

; 670  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 671  : 	DWORD riffsize,datasize;
; 672  : 	fpos_t bytepos;
; 673  : #ifdef _DEBUG
; 674  : 	assert(sfdat);
; 675  : 	assert(sfdat->file);
; 676  : 	assert(POS64(sfdat->dataoffset) != 0);	
; 677  : #endif		
; 678  :     POS64(bytepos) = sizeof(int);

  00009	48 c7 44 24 40
	04 00 00 00	 mov	 QWORD PTR bytepos$[rsp], 4

; 679  : 	if((fsetpos(sfdat->file,&bytepos))==0) {			 

  00012	48 8d 54 24 40	 lea	 rdx, QWORD PTR bytepos$[rsp]
  00017	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  0001c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0001f	e8 00 00 00 00	 call	 fsetpos
  00024	85 c0		 test	 eax, eax
  00026	0f 85 a5 00 00
	00		 jne	 $LN5@wavUpdate

; 680  : 		riffsize = (sfdat->nFrames * sfdat->fmt.Format.nBlockAlign) +  (MYLONG) POS64(sfdat->dataoffset);

  0002c	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00031	0f b7 40 5c	 movzx	 eax, WORD PTR [rax+92]
  00035	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0003a	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  0003d	0f af c8	 imul	 ecx, eax
  00040	8b c1		 mov	 eax, ecx
  00042	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00047	03 41 38	 add	 eax, DWORD PTR [rcx+56]
  0004a	89 44 24 20	 mov	 DWORD PTR riffsize$[rsp], eax

; 681  : 		riffsize -= 2 * sizeof(DWORD);

  0004e	8b 44 24 20	 mov	 eax, DWORD PTR riffsize$[rsp]
  00052	48 83 e8 08	 sub	 rax, 8
  00056	89 44 24 20	 mov	 DWORD PTR riffsize$[rsp], eax

; 682  : 		if(!sfdat->is_little_endian)

  0005a	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  0005f	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00063	75 3d		 jne	 SHORT $LN7@wavUpdate

; 683  : 			riffsize = REVDWBYTES(riffsize);

  00065	8b 44 24 20	 mov	 eax, DWORD PTR riffsize$[rsp]
  00069	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0006e	c1 e0 18	 shl	 eax, 24
  00071	8b 4c 24 20	 mov	 ecx, DWORD PTR riffsize$[rsp]
  00075	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  0007b	c1 e1 08	 shl	 ecx, 8
  0007e	0b c1		 or	 eax, ecx
  00080	8b 4c 24 20	 mov	 ecx, DWORD PTR riffsize$[rsp]
  00084	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  0008a	c1 e9 08	 shr	 ecx, 8
  0008d	0b c1		 or	 eax, ecx
  0008f	8b 4c 24 20	 mov	 ecx, DWORD PTR riffsize$[rsp]
  00093	c1 e9 18	 shr	 ecx, 24
  00096	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0009c	0b c1		 or	 eax, ecx
  0009e	89 44 24 20	 mov	 DWORD PTR riffsize$[rsp], eax
$LN7@wavUpdate:

; 684  : 		if(fwrite((char *) &riffsize,sizeof(int),1,sfdat->file) != 1)

  000a2	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  000a7	4c 8b 08	 mov	 r9, QWORD PTR [rax]
  000aa	41 b8 01 00 00
	00		 mov	 r8d, 1
  000b0	ba 04 00 00 00	 mov	 edx, 4
  000b5	48 8d 4c 24 20	 lea	 rcx, QWORD PTR riffsize$[rsp]
  000ba	e8 00 00 00 00	 call	 fwrite
  000bf	48 83 f8 01	 cmp	 rax, 1
  000c3	74 0a		 je	 SHORT $LN8@wavUpdate

; 685  : 			return PSF_E_CANT_WRITE;

  000c5	b8 fd ff ff ff	 mov	 eax, -3
  000ca	e9 b8 02 00 00	 jmp	 $LN1@wavUpdate
$LN8@wavUpdate:

; 686  : 	}

  000cf	eb 0a		 jmp	 SHORT $LN6@wavUpdate
$LN5@wavUpdate:

; 687  : 	else
; 688  : 	    return PSF_E_CANT_SEEK;

  000d1	b8 f5 ff ff ff	 mov	 eax, -11
  000d6	e9 ac 02 00 00	 jmp	 $LN1@wavUpdate
$LN6@wavUpdate:

; 689  : 	if(sfdat->pPeaks){

  000db	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  000e0	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  000e8	0f 84 bf 01 00
	00		 je	 $LN9@wavUpdate

; 690  : 		if(POS64(sfdat->peakoffset)==0)

  000ee	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  000f3	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  000f8	75 0a		 jne	 SHORT $LN10@wavUpdate

; 691  : 			return PSF_E_BADARG;

  000fa	b8 f6 ff ff ff	 mov	 eax, -10
  000ff	e9 83 02 00 00	 jmp	 $LN1@wavUpdate
$LN10@wavUpdate:

; 692  : 		
; 693  : 		/*do byterev if necessary...*/
; 694  : 		if((fsetpos(sfdat->file,&sfdat->peakoffset))==0){

  00104	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00109	48 83 c0 48	 add	 rax, 72			; 00000048H
  0010d	48 8b d0	 mov	 rdx, rax
  00110	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00115	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00118	e8 00 00 00 00	 call	 fsetpos
  0011d	85 c0		 test	 eax, eax
  0011f	0f 85 7e 01 00
	00		 jne	 $LN11@wavUpdate

; 695  : 			/*set current time*/
; 696  : 			DWORD *pblock;
; 697  : 			int i;
; 698  : 			time_t now = time(0);

  00125	33 c9		 xor	 ecx, ecx
  00127	e8 00 00 00 00	 call	 time
  0012c	48 89 44 24 30	 mov	 QWORD PTR now$2[rsp], rax

; 699  : 			if(!sfdat->is_little_endian){

  00131	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00136	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0013a	0f 85 f2 00 00
	00		 jne	 $LN13@wavUpdate

; 700  : 				now = REVDWBYTES(now);

  00140	48 8b 44 24 30	 mov	 rax, QWORD PTR now$2[rsp]
  00145	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  0014b	48 c1 e0 18	 shl	 rax, 24
  0014f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR now$2[rsp]
  00154	48 81 e1 00 ff
	00 00		 and	 rcx, 65280		; 0000ff00H
  0015b	48 c1 e1 08	 shl	 rcx, 8
  0015f	48 0b c1	 or	 rax, rcx
  00162	48 8b 4c 24 30	 mov	 rcx, QWORD PTR now$2[rsp]
  00167	48 81 e1 00 00
	ff 00		 and	 rcx, 16711680		; 00ff0000H
  0016e	48 c1 f9 08	 sar	 rcx, 8
  00172	48 0b c1	 or	 rax, rcx
  00175	48 8b 4c 24 30	 mov	 rcx, QWORD PTR now$2[rsp]
  0017a	48 c1 f9 18	 sar	 rcx, 24
  0017e	48 81 e1 ff 00
	00 00		 and	 rcx, 255		; 000000ffH
  00185	48 0b c1	 or	 rax, rcx
  00188	48 89 44 24 30	 mov	 QWORD PTR now$2[rsp], rax

; 701  : 				pblock = (DWORD *) (sfdat->pPeaks);

  0018d	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00192	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00199	48 89 44 24 38	 mov	 QWORD PTR pblock$3[rsp], rax

; 702  : 				for(i=0;i < sfdat->fmt.Format.nChannels * 2; i++)

  0019e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  001a6	eb 0a		 jmp	 SHORT $LN4@wavUpdate
$LN2@wavUpdate:
  001a8	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  001ac	ff c0		 inc	 eax
  001ae	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
$LN4@wavUpdate:
  001b2	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  001b7	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  001bb	d1 e0		 shl	 eax, 1
  001bd	39 44 24 24	 cmp	 DWORD PTR i$1[rsp], eax
  001c1	7d 6f		 jge	 SHORT $LN3@wavUpdate

; 703  : 					pblock[i] = REVDWBYTES(pblock[i]);

  001c3	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$1[rsp]
  001c8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pblock$3[rsp]
  001cd	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  001d0	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001d5	c1 e0 18	 shl	 eax, 24
  001d8	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR i$1[rsp]
  001dd	48 8b 54 24 38	 mov	 rdx, QWORD PTR pblock$3[rsp]
  001e2	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  001e5	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  001eb	c1 e1 08	 shl	 ecx, 8
  001ee	0b c1		 or	 eax, ecx
  001f0	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR i$1[rsp]
  001f5	48 8b 54 24 38	 mov	 rdx, QWORD PTR pblock$3[rsp]
  001fa	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  001fd	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00203	c1 e9 08	 shr	 ecx, 8
  00206	0b c1		 or	 eax, ecx
  00208	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR i$1[rsp]
  0020d	48 8b 54 24 38	 mov	 rdx, QWORD PTR pblock$3[rsp]
  00212	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  00215	c1 e9 18	 shr	 ecx, 24
  00218	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0021e	0b c1		 or	 eax, ecx
  00220	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00225	48 8b 54 24 38	 mov	 rdx, QWORD PTR pblock$3[rsp]
  0022a	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  0022d	e9 76 ff ff ff	 jmp	 $LN2@wavUpdate
$LN3@wavUpdate:
$LN13@wavUpdate:

; 704  : 			}
; 705  : 			if((fwrite((char*)&now,sizeof(DWORD),1,sfdat->file)) != 1)

  00232	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00237	4c 8b 08	 mov	 r9, QWORD PTR [rax]
  0023a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00240	ba 04 00 00 00	 mov	 edx, 4
  00245	48 8d 4c 24 30	 lea	 rcx, QWORD PTR now$2[rsp]
  0024a	e8 00 00 00 00	 call	 fwrite
  0024f	48 83 f8 01	 cmp	 rax, 1
  00253	74 0a		 je	 SHORT $LN14@wavUpdate

; 706  : 				return PSF_E_CANT_WRITE;

  00255	b8 fd ff ff ff	 mov	 eax, -3
  0025a	e9 28 01 00 00	 jmp	 $LN1@wavUpdate
$LN14@wavUpdate:

; 707  : 
; 708  : 			if((fwrite((char *) (sfdat->pPeaks),sizeof(PSF_CHPEAK),sfdat->fmt.Format.nChannels,sfdat->file))
; 709  : 				!= sfdat->fmt.Format.nChannels )

  0025f	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00264	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  00268	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0026d	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  00270	44 8b c0	 mov	 r8d, eax
  00273	ba 08 00 00 00	 mov	 edx, 8
  00278	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  0027d	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00284	e8 00 00 00 00	 call	 fwrite
  00289	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0028e	0f b7 49 52	 movzx	 ecx, WORD PTR [rcx+82]
  00292	48 3b c1	 cmp	 rax, rcx
  00295	74 0a		 je	 SHORT $LN15@wavUpdate

; 710  : 				return PSF_E_CANT_WRITE;

  00297	b8 fd ff ff ff	 mov	 eax, -3
  0029c	e9 e6 00 00 00	 jmp	 $LN1@wavUpdate
$LN15@wavUpdate:

; 711  : 		}

  002a1	eb 0a		 jmp	 SHORT $LN12@wavUpdate
$LN11@wavUpdate:

; 712  : 		else
; 713  : 		    return PSF_E_CANT_SEEK;

  002a3	b8 f5 ff ff ff	 mov	 eax, -11
  002a8	e9 da 00 00 00	 jmp	 $LN1@wavUpdate
$LN12@wavUpdate:
$LN9@wavUpdate:

; 714  : 	}
; 715  : 	POS64(bytepos) = POS64(sfdat->dataoffset) -  sizeof(int);

  002ad	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  002b2	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  002b6	48 83 e8 04	 sub	 rax, 4
  002ba	48 89 44 24 40	 mov	 QWORD PTR bytepos$[rsp], rax

; 716  : 	if((fsetpos(sfdat->file,&bytepos))==0) {			

  002bf	48 8d 54 24 40	 lea	 rdx, QWORD PTR bytepos$[rsp]
  002c4	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  002c9	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  002cc	e8 00 00 00 00	 call	 fsetpos
  002d1	85 c0		 test	 eax, eax
  002d3	0f 85 8c 00 00
	00		 jne	 $LN16@wavUpdate

; 717  : 		datasize = sfdat->nFrames * sfdat->fmt.Format.nBlockAlign;

  002d9	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  002de	0f b7 40 5c	 movzx	 eax, WORD PTR [rax+92]
  002e2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sfdat$[rsp]
  002e7	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  002ea	0f af c8	 imul	 ecx, eax
  002ed	8b c1		 mov	 eax, ecx
  002ef	89 44 24 28	 mov	 DWORD PTR datasize$[rsp], eax

; 718  : 		if(!sfdat->is_little_endian)

  002f3	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  002f8	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  002fc	75 3d		 jne	 SHORT $LN17@wavUpdate

; 719  : 			datasize = REVDWBYTES(datasize);

  002fe	8b 44 24 28	 mov	 eax, DWORD PTR datasize$[rsp]
  00302	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00307	c1 e0 18	 shl	 eax, 24
  0030a	8b 4c 24 28	 mov	 ecx, DWORD PTR datasize$[rsp]
  0030e	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00314	c1 e1 08	 shl	 ecx, 8
  00317	0b c1		 or	 eax, ecx
  00319	8b 4c 24 28	 mov	 ecx, DWORD PTR datasize$[rsp]
  0031d	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00323	c1 e9 08	 shr	 ecx, 8
  00326	0b c1		 or	 eax, ecx
  00328	8b 4c 24 28	 mov	 ecx, DWORD PTR datasize$[rsp]
  0032c	c1 e9 18	 shr	 ecx, 24
  0032f	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00335	0b c1		 or	 eax, ecx
  00337	89 44 24 28	 mov	 DWORD PTR datasize$[rsp], eax
$LN17@wavUpdate:

; 720  : 		if(fwrite((char *) & datasize,sizeof(DWORD),1,sfdat->file) != 1)

  0033b	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00340	4c 8b 08	 mov	 r9, QWORD PTR [rax]
  00343	41 b8 01 00 00
	00		 mov	 r8d, 1
  00349	ba 04 00 00 00	 mov	 edx, 4
  0034e	48 8d 4c 24 28	 lea	 rcx, QWORD PTR datasize$[rsp]
  00353	e8 00 00 00 00	 call	 fwrite
  00358	48 83 f8 01	 cmp	 rax, 1
  0035c	74 07		 je	 SHORT $LN18@wavUpdate

; 721  : 			return PSF_E_CANT_WRITE;	

  0035e	b8 fd ff ff ff	 mov	 eax, -3
  00363	eb 22		 jmp	 SHORT $LN1@wavUpdate
$LN18@wavUpdate:
$LN16@wavUpdate:

; 722  : 	}
; 723  : 	if(fseek(sfdat->file,0,SEEK_END)){

  00365	41 b8 02 00 00
	00		 mov	 r8d, 2
  0036b	33 d2		 xor	 edx, edx
  0036d	48 8b 44 24 60	 mov	 rax, QWORD PTR sfdat$[rsp]
  00372	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00375	e8 00 00 00 00	 call	 fseek
  0037a	85 c0		 test	 eax, eax
  0037c	74 07		 je	 SHORT $LN19@wavUpdate

; 724  : 		/*DBGFPRINTF((stderr,"wavUpdate: error reseeking to end of file\n"));*/
; 725  : 		return PSF_E_CANT_SEEK;

  0037e	b8 f5 ff ff ff	 mov	 eax, -11
  00383	eb 02		 jmp	 SHORT $LN1@wavUpdate
$LN19@wavUpdate:

; 726  : 	}
; 727  : 
; 728  : 	return PSF_E_NOERROR;

  00385	33 c0		 xor	 eax, eax
$LN1@wavUpdate:

; 729  : }

  00387	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0038b	c3		 ret	 0
wavUpdate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
sfdat$ = 32
tv210 = 40
tv128 = 44
tv137 = 48
tv144 = 52
tv149 = 56
tv155 = 60
tv160 = 64
tv163 = 68
tv187 = 72
tv173 = 80
tv181 = 88
props$ = 112
psf_newFile PROC

; 530  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 531  : 	PSFFILE *sfdat;	
; 532  : 
; 533  : 	if(props){

  00009	48 83 7c 24 70
	00		 cmp	 QWORD PTR props$[rsp], 0
  0000f	74 7a		 je	 SHORT $LN4@psf_newFil

; 534  : 		if(props->srate <=0)

  00011	48 8b 44 24 70	 mov	 rax, QWORD PTR props$[rsp]
  00016	83 38 00	 cmp	 DWORD PTR [rax], 0
  00019	7f 07		 jg	 SHORT $LN5@psf_newFil

; 535  : 			return NULL;

  0001b	33 c0		 xor	 eax, eax
  0001d	e9 37 05 00 00	 jmp	 $LN1@psf_newFil
$LN5@psf_newFil:

; 536  : 		if(props->chans <=0)

  00022	48 8b 44 24 70	 mov	 rax, QWORD PTR props$[rsp]
  00027	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  0002b	7f 07		 jg	 SHORT $LN6@psf_newFil

; 537  : 			return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	e9 25 05 00 00	 jmp	 $LN1@psf_newFil
$LN6@psf_newFil:

; 538  : 		/* NO support for PSF_SAMP_8 yet...*/
; 539  : 		if(props->samptype < PSF_SAMP_16 || props->samptype > PSF_SAMP_IEEE_FLOAT)

  00034	48 8b 44 24 70	 mov	 rax, QWORD PTR props$[rsp]
  00039	83 78 08 02	 cmp	 DWORD PTR [rax+8], 2
  0003d	7c 0b		 jl	 SHORT $LN8@psf_newFil
  0003f	48 8b 44 24 70	 mov	 rax, QWORD PTR props$[rsp]
  00044	83 78 08 05	 cmp	 DWORD PTR [rax+8], 5
  00048	7e 07		 jle	 SHORT $LN7@psf_newFil
$LN8@psf_newFil:

; 540  : 			return NULL;

  0004a	33 c0		 xor	 eax, eax
  0004c	e9 08 05 00 00	 jmp	 $LN1@psf_newFil
$LN7@psf_newFil:

; 541  : 		if(props->format	<= PSF_FMT_UNKNOWN || props->format > PSF_AIFC)

  00051	48 8b 44 24 70	 mov	 rax, QWORD PTR props$[rsp]
  00056	83 78 0c 00	 cmp	 DWORD PTR [rax+12], 0
  0005a	7e 0b		 jle	 SHORT $LN10@psf_newFil
  0005c	48 8b 44 24 70	 mov	 rax, QWORD PTR props$[rsp]
  00061	83 78 0c 04	 cmp	 DWORD PTR [rax+12], 4
  00065	7e 07		 jle	 SHORT $LN9@psf_newFil
$LN10@psf_newFil:

; 542  : 			return NULL;

  00067	33 c0		 xor	 eax, eax
  00069	e9 eb 04 00 00	 jmp	 $LN1@psf_newFil
$LN9@psf_newFil:

; 543  : 		if(props->chformat < STDWAVE || props->chformat > MC_WAVE_EX)

  0006e	48 8b 44 24 70	 mov	 rax, QWORD PTR props$[rsp]
  00073	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  00077	7c 0b		 jl	 SHORT $LN12@psf_newFil
  00079	48 8b 44 24 70	 mov	 rax, QWORD PTR props$[rsp]
  0007e	83 78 10 0a	 cmp	 DWORD PTR [rax+16], 10
  00082	7e 07		 jle	 SHORT $LN11@psf_newFil
$LN12@psf_newFil:

; 544  : 			return NULL;

  00084	33 c0		 xor	 eax, eax
  00086	e9 ce 04 00 00	 jmp	 $LN1@psf_newFil
$LN11@psf_newFil:
$LN4@psf_newFil:

; 545  : 	}
; 546  : 
; 547  : 
; 548  : 	sfdat = (PSFFILE *) malloc(sizeof(PSFFILE));

  0008b	b9 a0 00 00 00	 mov	 ecx, 160		; 000000a0H
  00090	e8 00 00 00 00	 call	 malloc
  00095	48 89 44 24 20	 mov	 QWORD PTR sfdat$[rsp], rax

; 549  : 	if(sfdat==NULL)

  0009a	48 83 7c 24 20
	00		 cmp	 QWORD PTR sfdat$[rsp], 0
  000a0	75 0a		 jne	 SHORT $LN13@psf_newFil

; 550  : 		return sfdat;

  000a2	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  000a7	e9 ad 04 00 00	 jmp	 $LN1@psf_newFil
$LN13@psf_newFil:

; 551  : 
; 552  : 	POS64(sfdat->lastwritepos)		= 0;

  000ac	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  000b1	48 c7 80 90 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+144], 0

; 553  : 	sfdat->file			= NULL;

  000bc	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  000c1	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 554  : 	sfdat->filename			= NULL;

  000c8	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  000cd	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 555  : 	sfdat->nFrames			= 0;

  000d5	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  000da	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0

; 556  : 	sfdat->curframepos		= 0;				

  000e1	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  000e6	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 557  : 	sfdat->isRead			= 1;				/* OK. who knows?    */

  000ed	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  000f2	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [rax+24], 1

; 558  : 	/* or use platform default format.... */
; 559  : 	sfdat->riff_format		= props ? props->format : PSF_STDWAVE;		/* almost certainly! */

  000f9	48 83 7c 24 70
	00		 cmp	 QWORD PTR props$[rsp], 0
  000ff	74 0e		 je	 SHORT $LN34@psf_newFil
  00101	48 8b 44 24 70	 mov	 rax, QWORD PTR props$[rsp]
  00106	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00109	89 44 24 2c	 mov	 DWORD PTR tv128[rsp], eax
  0010d	eb 08		 jmp	 SHORT $LN35@psf_newFil
$LN34@psf_newFil:
  0010f	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv128[rsp], 1
$LN35@psf_newFil:
  00117	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  0011c	8b 4c 24 2c	 mov	 ecx, DWORD PTR tv128[rsp]
  00120	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 560  : 	/*sfdat->isSeekable		= 1;*/
; 561  : 	sfdat->clip_floats		= 1;

  00123	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  00128	c7 40 1c 01 00
	00 00		 mov	 DWORD PTR [rax+28], 1

; 562  : 	sfdat->rescale			= 0;

  0012f	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  00134	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 563  : 	sfdat->rescale_fac		= 1.0f;

  0013b	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  00140	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00148	f3 0f 11 40 24	 movss	 DWORD PTR [rax+36], xmm0

; 564  : 	sfdat->is_little_endian	= byte_order();			

  0014d	e8 00 00 00 00	 call	 byte_order
  00152	48 8b 4c 24 20	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00157	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 565  : 	sfdat->samptype			= props ? props->samptype : PSF_SAMP_16;		/* reasonable...     */

  0015a	48 83 7c 24 70
	00		 cmp	 QWORD PTR props$[rsp], 0
  00160	74 0e		 je	 SHORT $LN36@psf_newFil
  00162	48 8b 44 24 70	 mov	 rax, QWORD PTR props$[rsp]
  00167	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0016a	89 44 24 30	 mov	 DWORD PTR tv137[rsp], eax
  0016e	eb 08		 jmp	 SHORT $LN37@psf_newFil
$LN36@psf_newFil:
  00170	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv137[rsp], 2
$LN37@psf_newFil:
  00178	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  0017d	8b 4c 24 30	 mov	 ecx, DWORD PTR tv137[rsp]
  00181	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 566  : 	POS64(sfdat->dataoffset)		= 0;

  00184	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  00189	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 567  : 	POS64(sfdat->fmtoffset)		= 0;

  00191	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  00196	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0

; 568  : 	POS64(sfdat->peakoffset)		= 0;

  0019e	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  001a3	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0

; 569  : 	sfdat->chformat			= props ? props->chformat : STDWAVE;

  001ab	48 83 7c 24 70
	00		 cmp	 QWORD PTR props$[rsp], 0
  001b1	74 0e		 je	 SHORT $LN38@psf_newFil
  001b3	48 8b 44 24 70	 mov	 rax, QWORD PTR props$[rsp]
  001b8	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  001bb	89 44 24 34	 mov	 DWORD PTR tv144[rsp], eax
  001bf	eb 08		 jmp	 SHORT $LN39@psf_newFil
$LN38@psf_newFil:
  001c1	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv144[rsp], 0
$LN39@psf_newFil:
  001c9	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  001ce	8b 4c 24 34	 mov	 ecx, DWORD PTR tv144[rsp]
  001d2	89 48 7c	 mov	 DWORD PTR [rax+124], ecx

; 570  : 	/*setup Format */
; 571  : 	if(props)

  001d5	48 83 7c 24 70
	00		 cmp	 QWORD PTR props$[rsp], 0
  001db	74 2d		 je	 SHORT $LN14@psf_newFil

; 572  : 		sfdat->fmt.Format.wFormatTag  = (WORD) (props->samptype == PSF_SAMP_IEEE_FLOAT ?  WAVE_FORMAT_IEEE_FLOAT : WAVE_FORMAT_PCM); 

  001dd	48 8b 44 24 70	 mov	 rax, QWORD PTR props$[rsp]
  001e2	83 78 08 05	 cmp	 DWORD PTR [rax+8], 5
  001e6	75 0a		 jne	 SHORT $LN40@psf_newFil
  001e8	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR tv149[rsp], 3
  001f0	eb 08		 jmp	 SHORT $LN41@psf_newFil
$LN40@psf_newFil:
  001f2	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv149[rsp], 1
$LN41@psf_newFil:
  001fa	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  001ff	0f b7 4c 24 38	 movzx	 ecx, WORD PTR tv149[rsp]
  00204	66 89 48 50	 mov	 WORD PTR [rax+80], cx
  00208	eb 0e		 jmp	 SHORT $LN15@psf_newFil
$LN14@psf_newFil:

; 573  : 	else
; 574  : 		sfdat->fmt.Format.wFormatTag  = WAVE_FORMAT_PCM;

  0020a	b8 01 00 00 00	 mov	 eax, 1
  0020f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00214	66 89 41 50	 mov	 WORD PTR [rcx+80], ax
$LN15@psf_newFil:

; 575  :     sfdat->fmt.Format.nChannels		  = (WORD) (props ?  props->chans : 1); 

  00218	48 83 7c 24 70
	00		 cmp	 QWORD PTR props$[rsp], 0
  0021e	74 0e		 je	 SHORT $LN42@psf_newFil
  00220	48 8b 44 24 70	 mov	 rax, QWORD PTR props$[rsp]
  00225	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00228	89 44 24 3c	 mov	 DWORD PTR tv155[rsp], eax
  0022c	eb 08		 jmp	 SHORT $LN43@psf_newFil
$LN42@psf_newFil:
  0022e	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv155[rsp], 1
$LN43@psf_newFil:
  00236	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  0023b	0f b7 4c 24 3c	 movzx	 ecx, WORD PTR tv155[rsp]
  00240	66 89 48 52	 mov	 WORD PTR [rax+82], cx

; 576  :     sfdat->fmt.Format.nSamplesPerSec  = props ? props->srate : 44100;      

  00244	48 83 7c 24 70
	00		 cmp	 QWORD PTR props$[rsp], 0
  0024a	74 0d		 je	 SHORT $LN44@psf_newFil
  0024c	48 8b 44 24 70	 mov	 rax, QWORD PTR props$[rsp]
  00251	8b 00		 mov	 eax, DWORD PTR [rax]
  00253	89 44 24 40	 mov	 DWORD PTR tv160[rsp], eax
  00257	eb 08		 jmp	 SHORT $LN45@psf_newFil
$LN44@psf_newFil:
  00259	c7 44 24 40 44
	ac 00 00	 mov	 DWORD PTR tv160[rsp], 44100 ; 0000ac44H
$LN45@psf_newFil:
  00261	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  00266	8b 4c 24 40	 mov	 ecx, DWORD PTR tv160[rsp]
  0026a	89 48 54	 mov	 DWORD PTR [rax+84], ecx

; 577  :     sfdat->fmt.Format.nBlockAlign	  = (WORD) (props  ?  sfdat->fmt.Format.nChannels * psf_wordsize(props->samptype) : sfdat->fmt.Format.nChannels * sizeof(short)); 

  0026d	48 83 7c 24 70
	00		 cmp	 QWORD PTR props$[rsp], 0
  00273	74 2c		 je	 SHORT $LN46@psf_newFil
  00275	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  0027a	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  0027e	89 44 24 44	 mov	 DWORD PTR tv163[rsp], eax
  00282	48 8b 4c 24 70	 mov	 rcx, QWORD PTR props$[rsp]
  00287	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  0028a	e8 00 00 00 00	 call	 psf_wordsize
  0028f	8b 4c 24 44	 mov	 ecx, DWORD PTR tv163[rsp]
  00293	0f af c8	 imul	 ecx, eax
  00296	8b c1		 mov	 eax, ecx
  00298	48 98		 cdqe
  0029a	48 89 44 24 50	 mov	 QWORD PTR tv173[rsp], rax
  0029f	eb 11		 jmp	 SHORT $LN47@psf_newFil
$LN46@psf_newFil:
  002a1	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  002a6	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  002aa	48 d1 e0	 shl	 rax, 1
  002ad	48 89 44 24 50	 mov	 QWORD PTR tv173[rsp], rax
$LN47@psf_newFil:
  002b2	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  002b7	0f b7 4c 24 50	 movzx	 ecx, WORD PTR tv173[rsp]
  002bc	66 89 48 5c	 mov	 WORD PTR [rax+92], cx

; 578  :     sfdat->fmt.Format.wBitsPerSample  = (WORD) (props ?  psf_bitsize(props->samptype)  : sizeof(short) * BITS_PER_BYTE);

  002c0	48 83 7c 24 70
	00		 cmp	 QWORD PTR props$[rsp], 0
  002c6	74 16		 je	 SHORT $LN48@psf_newFil
  002c8	48 8b 44 24 70	 mov	 rax, QWORD PTR props$[rsp]
  002cd	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  002d0	e8 00 00 00 00	 call	 psf_bitsize
  002d5	48 98		 cdqe
  002d7	48 89 44 24 58	 mov	 QWORD PTR tv181[rsp], rax
  002dc	eb 09		 jmp	 SHORT $LN49@psf_newFil
$LN48@psf_newFil:
  002de	48 c7 44 24 58
	10 00 00 00	 mov	 QWORD PTR tv181[rsp], 16
$LN49@psf_newFil:
  002e7	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  002ec	0f b7 4c 24 58	 movzx	 ecx, WORD PTR tv181[rsp]
  002f1	66 89 48 5e	 mov	 WORD PTR [rax+94], cx

; 579  : 	sfdat->fmt.Format.nAvgBytesPerSec = sfdat->fmt.Format.nSamplesPerSec  

  002f5	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  002fa	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  002fe	48 8b 4c 24 20	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00303	8b 49 54	 mov	 ecx, DWORD PTR [rcx+84]
  00306	0f af c8	 imul	 ecx, eax
  00309	8b c1		 mov	 eax, ecx
  0030b	89 44 24 48	 mov	 DWORD PTR tv187[rsp], eax
  0030f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00314	0f b7 49 5e	 movzx	 ecx, WORD PTR [rcx+94]
  00318	8b c1		 mov	 eax, ecx
  0031a	99		 cdq
  0031b	83 e2 07	 and	 edx, 7
  0031e	03 c2		 add	 eax, edx
  00320	c1 f8 03	 sar	 eax, 3
  00323	8b 4c 24 48	 mov	 ecx, DWORD PTR tv187[rsp]
  00327	0f af c8	 imul	 ecx, eax
  0032a	8b c1		 mov	 eax, ecx
  0032c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00331	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 580  : 				 *sfdat->fmt.Format.nChannels 
; 581  : 				 * (sfdat->fmt.Format.wBitsPerSample / BITS_PER_BYTE);
; 582  : 	sfdat->pPeaks			= NULL;

  00334	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  00339	48 c7 80 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+128], 0

; 583  : 	sfdat->peaktime			= 0;

  00344	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  00349	48 c7 80 88 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+136], 0

; 584  : 	sfdat->fmt.Format.cbSize = 0;

  00354	33 c0		 xor	 eax, eax
  00356	48 8b 4c 24 20	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0035b	66 89 41 60	 mov	 WORD PTR [rcx+96], ax

; 585  : 	/* set initial defaults for WAVE-EX stuff; may change */
; 586  : 	/* but nobody should look at these fields unless we have a real WAVE-EX file anyway... */
; 587  : 	sfdat->fmt.dwChannelMask = SPKRS_UNASSIGNED;

  0035f	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  00364	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [rax+104], 0

; 588  : 	sfdat->fmt.Samples.wValidBitsPerSample  = sfdat->fmt.Format.wBitsPerSample;

  0036b	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  00370	48 8b 4c 24 20	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00375	0f b7 49 5e	 movzx	 ecx, WORD PTR [rcx+94]
  00379	66 89 48 64	 mov	 WORD PTR [rax+100], cx

; 589  : 	/* 0 should be a guaranteed non-valid GUID! */
; 590  : 	memset((char *) &(sfdat->fmt.SubFormat),0,sizeof(GUID));

  0037d	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  00382	48 83 c0 6c	 add	 rax, 108		; 0000006cH
  00386	41 b8 10 00 00
	00		 mov	 r8d, 16
  0038c	33 d2		 xor	 edx, edx
  0038e	48 8b c8	 mov	 rcx, rax
  00391	e8 00 00 00 00	 call	 memset

; 591  : 
; 592  : 	if(props && (props->format == PSF_WAVE_EX)) {

  00396	48 83 7c 24 70
	00		 cmp	 QWORD PTR props$[rsp], 0
  0039c	0f 84 a3 01 00
	00		 je	 $LN16@psf_newFil
  003a2	48 8b 44 24 70	 mov	 rax, QWORD PTR props$[rsp]
  003a7	83 78 0c 02	 cmp	 DWORD PTR [rax+12], 2
  003ab	0f 85 94 01 00
	00		 jne	 $LN16@psf_newFil

; 593  : 		sfdat->fmt.Format.cbSize = 22;

  003b1	b8 16 00 00 00	 mov	 eax, 22
  003b6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR sfdat$[rsp]
  003bb	66 89 41 60	 mov	 WORD PTR [rcx+96], ax

; 594  : 		/* NB we will set the GUID from wFormatTag in waveExWriteHeader() */		
; 595  : 		/* should really flag an error if user sets this */
; 596  : 		if(sfdat->chformat==STDWAVE)

  003bf	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  003c4	83 78 7c 00	 cmp	 DWORD PTR [rax+124], 0
  003c8	75 0c		 jne	 SHORT $LN17@psf_newFil

; 597  : 			sfdat->chformat = MC_STD;

  003ca	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  003cf	c7 40 7c 01 00
	00 00		 mov	 DWORD PTR [rax+124], 1
$LN17@psf_newFil:

; 598  : 
; 599  : 		/* set wavex speaker mask */
; 600  : 		/* TODO: support custom speaker masks, wordsizes, etc */
; 601  : 		switch(sfdat->chformat){			

  003d6	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  003db	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  003de	89 44 24 28	 mov	 DWORD PTR tv210[rsp], eax
  003e2	8b 44 24 28	 mov	 eax, DWORD PTR tv210[rsp]
  003e6	83 e8 02	 sub	 eax, 2
  003e9	89 44 24 28	 mov	 DWORD PTR tv210[rsp], eax
  003ed	83 7c 24 28 07	 cmp	 DWORD PTR tv210[rsp], 7
  003f2	0f 87 41 01 00
	00		 ja	 $LN32@psf_newFil
  003f8	48 63 44 24 28	 movsxd	 rax, DWORD PTR tv210[rsp]
  003fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00404	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN50@psf_newFil[rcx+rax*4]
  0040b	48 03 c1	 add	 rax, rcx
  0040e	ff e0		 jmp	 rax
$LN18@psf_newFil:

; 602  : 		case MC_MONO:
; 603  : 			if(props->chans != 1){			

  00410	48 8b 44 24 70	 mov	 rax, QWORD PTR props$[rsp]
  00415	83 78 04 01	 cmp	 DWORD PTR [rax+4], 1
  00419	74 11		 je	 SHORT $LN19@psf_newFil

; 604  : 				//rsferrstr = "conflicting channel configuration for WAVE-EX file";
; 605  : 				free(sfdat);

  0041b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00420	e8 00 00 00 00	 call	 free

; 606  : 				return NULL;

  00425	33 c0		 xor	 eax, eax
  00427	e9 2d 01 00 00	 jmp	 $LN1@psf_newFil
$LN19@psf_newFil:

; 607  : 			}
; 608  : 			sfdat->fmt.dwChannelMask = SPKRS_MONO;

  0042c	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  00431	c7 40 68 40 00
	00 00		 mov	 DWORD PTR [rax+104], 64	; 00000040H

; 609  : 			break;

  00438	e9 08 01 00 00	 jmp	 $LN2@psf_newFil
$LN20@psf_newFil:

; 610  : 		case MC_STEREO:
; 611  : 			if(props->chans != 2){			

  0043d	48 8b 44 24 70	 mov	 rax, QWORD PTR props$[rsp]
  00442	83 78 04 02	 cmp	 DWORD PTR [rax+4], 2
  00446	74 11		 je	 SHORT $LN21@psf_newFil

; 612  : 				//rsferrstr = "conflicting channel configuration for WAVE-EX file";
; 613  : 				free(sfdat);

  00448	48 8b 4c 24 20	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0044d	e8 00 00 00 00	 call	 free

; 614  : 				return NULL;

  00452	33 c0		 xor	 eax, eax
  00454	e9 00 01 00 00	 jmp	 $LN1@psf_newFil
$LN21@psf_newFil:

; 615  : 			}
; 616  : 			sfdat->fmt.dwChannelMask = SPKRS_STEREO;

  00459	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  0045e	c7 40 68 03 00
	00 00		 mov	 DWORD PTR [rax+104], 3

; 617  : 			break;

  00465	e9 db 00 00 00	 jmp	 $LN2@psf_newFil
$LN22@psf_newFil:

; 618  : 		case MC_QUAD:
; 619  : 			if(props->chans != 4){				

  0046a	48 8b 44 24 70	 mov	 rax, QWORD PTR props$[rsp]
  0046f	83 78 04 04	 cmp	 DWORD PTR [rax+4], 4
  00473	74 11		 je	 SHORT $LN23@psf_newFil

; 620  : 				//rsferrstr = "conflicting channel configuration for WAVE-EX file";
; 621  : 				free(sfdat);

  00475	48 8b 4c 24 20	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0047a	e8 00 00 00 00	 call	 free

; 622  : 				return NULL;

  0047f	33 c0		 xor	 eax, eax
  00481	e9 d3 00 00 00	 jmp	 $LN1@psf_newFil
$LN23@psf_newFil:

; 623  : 			}
; 624  : 			sfdat->fmt.dwChannelMask = SPKRS_GENERIC_QUAD;

  00486	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  0048b	c7 40 68 33 00
	00 00		 mov	 DWORD PTR [rax+104], 51	; 00000033H

; 625  : 			break;	

  00492	e9 ae 00 00 00	 jmp	 $LN2@psf_newFil
$LN24@psf_newFil:

; 626  : 		case MC_LCRS:
; 627  : 			if(props->chans != 4){

  00497	48 8b 44 24 70	 mov	 rax, QWORD PTR props$[rsp]
  0049c	83 78 04 04	 cmp	 DWORD PTR [rax+4], 4
  004a0	74 11		 je	 SHORT $LN25@psf_newFil

; 628  : 				free(sfdat);

  004a2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR sfdat$[rsp]
  004a7	e8 00 00 00 00	 call	 free

; 629  : 				return NULL;

  004ac	33 c0		 xor	 eax, eax
  004ae	e9 a6 00 00 00	 jmp	 $LN1@psf_newFil
$LN25@psf_newFil:

; 630  : 			}
; 631  : 			sfdat->fmt.dwChannelMask = SPKRS_SURROUND_LCRS;

  004b3	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  004b8	c7 40 68 07 01
	00 00		 mov	 DWORD PTR [rax+104], 263 ; 00000107H

; 632  : 			break;

  004bf	e9 81 00 00 00	 jmp	 $LN2@psf_newFil
$LN26@psf_newFil:

; 633  : 		case MC_DOLBY_5_1:
; 634  : 			if(props->chans != 6){			

  004c4	48 8b 44 24 70	 mov	 rax, QWORD PTR props$[rsp]
  004c9	83 78 04 06	 cmp	 DWORD PTR [rax+4], 6
  004cd	74 0e		 je	 SHORT $LN27@psf_newFil

; 635  : 				//rsferrstr = "conflicting channel configuration for WAVE-EX file";
; 636  : 				free(sfdat);

  004cf	48 8b 4c 24 20	 mov	 rcx, QWORD PTR sfdat$[rsp]
  004d4	e8 00 00 00 00	 call	 free

; 637  : 				return NULL;

  004d9	33 c0		 xor	 eax, eax
  004db	eb 7c		 jmp	 SHORT $LN1@psf_newFil
$LN27@psf_newFil:

; 638  : 			}
; 639  : 			sfdat->fmt.dwChannelMask = SPKRS_DOLBY5_1;	   

  004dd	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  004e2	c7 40 68 3f 00
	00 00		 mov	 DWORD PTR [rax+104], 63	; 0000003fH

; 640  : 			break;

  004e9	eb 5a		 jmp	 SHORT $LN2@psf_newFil
$LN28@psf_newFil:

; 641  :         case MC_SURR_5_0:
; 642  :             if(props->chans != 5){			

  004eb	48 8b 44 24 70	 mov	 rax, QWORD PTR props$[rsp]
  004f0	83 78 04 05	 cmp	 DWORD PTR [rax+4], 5
  004f4	74 0e		 je	 SHORT $LN29@psf_newFil

; 643  : 				//rsferrstr = "conflicting channel configuration for WAVE-EX file";
; 644  : 				free(sfdat);

  004f6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR sfdat$[rsp]
  004fb	e8 00 00 00 00	 call	 free

; 645  : 				return NULL;

  00500	33 c0		 xor	 eax, eax
  00502	eb 55		 jmp	 SHORT $LN1@psf_newFil
$LN29@psf_newFil:

; 646  : 			}
; 647  : 			sfdat->fmt.dwChannelMask = SPKRS_SURR_5_0;

  00504	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  00509	c7 40 68 37 00
	00 00		 mov	 DWORD PTR [rax+104], 55	; 00000037H

; 648  :             break;

  00510	eb 33		 jmp	 SHORT $LN2@psf_newFil
$LN30@psf_newFil:

; 649  :         case MC_SURR_7_1:
; 650  :             if(props->chans != 8){			

  00512	48 8b 44 24 70	 mov	 rax, QWORD PTR props$[rsp]
  00517	83 78 04 08	 cmp	 DWORD PTR [rax+4], 8
  0051b	74 0e		 je	 SHORT $LN31@psf_newFil

; 651  : 				//rsferrstr = "conflicting channel configuration for WAVE-EX file";
; 652  : 				free(sfdat);

  0051d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00522	e8 00 00 00 00	 call	 free

; 653  : 				return NULL;

  00527	33 c0		 xor	 eax, eax
  00529	eb 2e		 jmp	 SHORT $LN1@psf_newFil
$LN31@psf_newFil:

; 654  : 			}
; 655  : 			sfdat->fmt.dwChannelMask = SPKRS_7_1;

  0052b	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  00530	c7 40 68 7f 00
	00 00		 mov	 DWORD PTR [rax+104], 127 ; 0000007fH

; 656  :             break;

  00537	eb 0c		 jmp	 SHORT $LN2@psf_newFil
$LN32@psf_newFil:

; 657  : 		default:
; 658  : 			/*MC_STD, MC_BFMT */			
; 659  : 			sfdat->fmt.dwChannelMask = SPKRS_UNASSIGNED;

  00539	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  0053e	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [rax+104], 0
$LN2@psf_newFil:
$LN16@psf_newFil:

; 660  : 			break;
; 661  : 		}
; 662  : 	}
; 663  : 	/* no dither, by default */
; 664  : 	sfdat->dithertype = PSF_DITHER_OFF;

  00545	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  0054a	c7 80 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+156], 0

; 665  : 	return sfdat;

  00554	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
$LN1@psf_newFil:

; 666  : }

  00559	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0055d	c3		 ret	 0
  0055e	66 90		 npad	 2
$LN50@psf_newFil:
  00560	00 00 00 00	 DD	 $LN18@psf_newFil
  00564	00 00 00 00	 DD	 $LN20@psf_newFil
  00568	00 00 00 00	 DD	 $LN22@psf_newFil
  0056c	00 00 00 00	 DD	 $LN24@psf_newFil
  00570	00 00 00 00	 DD	 $LN32@psf_newFil
  00574	00 00 00 00	 DD	 $LN26@psf_newFil
  00578	00 00 00 00	 DD	 $LN28@psf_newFil
  0057c	00 00 00 00	 DD	 $LN30@psf_newFil
psf_newFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
k$ = 32
val$ = 64
psf_round PROC

; 467  : {

$LN4:
  00000	f2 0f 11 44 24
	08		 movsd	 QWORD PTR [rsp+8], xmm0
  00006	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 468  : 	long k;
; 469  : 	k = (long)(fabs(val)+0.5);

  0000a	f2 0f 10 44 24
	40		 movsd	 xmm0, QWORD PTR val$[rsp]
  00010	e8 00 00 00 00	 call	 fabs
  00015	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  0001d	f2 0f 2c c0	 cvttsd2si eax, xmm0
  00021	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 470  : 	if(val < 0.0)

  00025	0f 57 c0	 xorps	 xmm0, xmm0
  00028	66 0f 2f 44 24
	40		 comisd	 xmm0, QWORD PTR val$[rsp]
  0002e	76 0a		 jbe	 SHORT $LN2@psf_round

; 471  : 		k = -k;

  00030	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  00034	f7 d8		 neg	 eax
  00036	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN2@psf_round:

; 472  : 	return k;

  0003a	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]

; 473  : }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
psf_round ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
tv64 = 0
size$ = 4
type$ = 32
psf_wordsize PROC

; 427  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 428  : 	int size = 0;

  00008	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR size$[rsp], 0

; 429  : 	switch(type){

  00010	8b 44 24 20	 mov	 eax, DWORD PTR type$[rsp]
  00014	89 04 24	 mov	 DWORD PTR tv64[rsp], eax
  00017	83 3c 24 02	 cmp	 DWORD PTR tv64[rsp], 2
  0001b	74 14		 je	 SHORT $LN4@psf_wordsi
  0001d	83 3c 24 03	 cmp	 DWORD PTR tv64[rsp], 3
  00021	74 18		 je	 SHORT $LN5@psf_wordsi
  00023	83 3c 24 03	 cmp	 DWORD PTR tv64[rsp], 3
  00027	7e 24		 jle	 SHORT $LN7@psf_wordsi
  00029	83 3c 24 05	 cmp	 DWORD PTR tv64[rsp], 5
  0002d	7e 16		 jle	 SHORT $LN6@psf_wordsi
  0002f	eb 1c		 jmp	 SHORT $LN7@psf_wordsi
$LN4@psf_wordsi:

; 430  : 	case(PSF_SAMP_16):
; 431  : 		size = 2;

  00031	c7 44 24 04 02
	00 00 00	 mov	 DWORD PTR size$[rsp], 2

; 432  : 		break;

  00039	eb 12		 jmp	 SHORT $LN2@psf_wordsi
$LN5@psf_wordsi:

; 433  : 	case (PSF_SAMP_24):
; 434  : 		size = 3;

  0003b	c7 44 24 04 03
	00 00 00	 mov	 DWORD PTR size$[rsp], 3

; 435  : 		break;	

  00043	eb 08		 jmp	 SHORT $LN2@psf_wordsi
$LN6@psf_wordsi:

; 436  : 	case(PSF_SAMP_32):
; 437  : 	case(PSF_SAMP_IEEE_FLOAT):
; 438  : 		size = 4;

  00045	c7 44 24 04 04
	00 00 00	 mov	 DWORD PTR size$[rsp], 4
$LN7@psf_wordsi:
$LN2@psf_wordsi:

; 439  : 		break;		
; 440  : 	default:
; 441  : 		break;
; 442  : 	}
; 443  : 	return size;

  0004d	8b 44 24 04	 mov	 eax, DWORD PTR size$[rsp]

; 444  : 
; 445  : }

  00051	48 83 c4 18	 add	 rsp, 24
  00055	c3		 ret	 0
psf_wordsize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
tv64 = 0
size$ = 4
type$ = 32
psf_bitsize PROC

; 407  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 408  : 	int size = 0;

  00008	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR size$[rsp], 0

; 409  : 	switch(type){	

  00010	8b 44 24 20	 mov	 eax, DWORD PTR type$[rsp]
  00014	89 04 24	 mov	 DWORD PTR tv64[rsp], eax
  00017	83 3c 24 02	 cmp	 DWORD PTR tv64[rsp], 2
  0001b	74 14		 je	 SHORT $LN4@psf_bitsiz
  0001d	83 3c 24 03	 cmp	 DWORD PTR tv64[rsp], 3
  00021	74 18		 je	 SHORT $LN5@psf_bitsiz
  00023	83 3c 24 03	 cmp	 DWORD PTR tv64[rsp], 3
  00027	7e 24		 jle	 SHORT $LN7@psf_bitsiz
  00029	83 3c 24 05	 cmp	 DWORD PTR tv64[rsp], 5
  0002d	7e 16		 jle	 SHORT $LN6@psf_bitsiz
  0002f	eb 1c		 jmp	 SHORT $LN7@psf_bitsiz
$LN4@psf_bitsiz:

; 410  : 	case(PSF_SAMP_16):
; 411  : 		size = 16;

  00031	c7 44 24 04 10
	00 00 00	 mov	 DWORD PTR size$[rsp], 16

; 412  : 		break;

  00039	eb 12		 jmp	 SHORT $LN2@psf_bitsiz
$LN5@psf_bitsiz:

; 413  : 	case (PSF_SAMP_24):	
; 414  : 		size = 24;

  0003b	c7 44 24 04 18
	00 00 00	 mov	 DWORD PTR size$[rsp], 24

; 415  : 		break;

  00043	eb 08		 jmp	 SHORT $LN2@psf_bitsiz
$LN6@psf_bitsiz:

; 416  : 	case(PSF_SAMP_32):
; 417  : 	case(PSF_SAMP_IEEE_FLOAT):
; 418  : 		size = 32;

  00045	c7 44 24 04 20
	00 00 00	 mov	 DWORD PTR size$[rsp], 32 ; 00000020H
$LN7@psf_bitsiz:
$LN2@psf_bitsiz:

; 419  : 		break;
; 420  : 	default:
; 421  : 		break;
; 422  : 	}
; 423  : 	return size;

  0004d	8b 44 24 04	 mov	 eax, DWORD PTR size$[rsp]

; 424  : }

  00051	48 83 c4 18	 add	 rsp, 24
  00055	c3		 ret	 0
psf_bitsize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
tv73 = 32
tv146 = 36
sfdat$ = 64
check_guid PROC

; 341  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 342  : 	/* expects a GUID to be loaded already into sfdat.*/
; 343  : 	if(sfdat->riff_format != PSF_WAVE_EX)		

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  0000e	83 78 28 02	 cmp	 DWORD PTR [rax+40], 2
  00012	74 0a		 je	 SHORT $LN6@check_guid

; 344  : 		return 1;

  00014	b8 01 00 00 00	 mov	 eax, 1
  00019	e9 04 02 00 00	 jmp	 $LN1@check_guid
$LN6@check_guid:

; 345  : 
; 346  : 	if(compare_guids(&(sfdat->fmt.SubFormat),&(KSDATAFORMAT_SUBTYPE_PCM))){

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  00023	48 83 c0 6c	 add	 rax, 108		; 0000006cH
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:KSDATAFORMAT_SUBTYPE_PCM
  0002e	48 8b c8	 mov	 rcx, rax
  00031	e8 00 00 00 00	 call	 compare_guids
  00036	85 c0		 test	 eax, eax
  00038	0f 84 9b 00 00
	00		 je	 $LN7@check_guid

; 347  : 		switch(sfdat->fmt.Format.wBitsPerSample){

  0003e	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  00043	0f b7 40 5e	 movzx	 eax, WORD PTR [rax+94]
  00047	89 44 24 20	 mov	 DWORD PTR tv73[rsp], eax
  0004b	83 7c 24 20 10	 cmp	 DWORD PTR tv73[rsp], 16
  00050	74 10		 je	 SHORT $LN8@check_guid
  00052	83 7c 24 20 18	 cmp	 DWORD PTR tv73[rsp], 24
  00057	74 17		 je	 SHORT $LN9@check_guid
  00059	83 7c 24 20 20	 cmp	 DWORD PTR tv73[rsp], 32	; 00000020H
  0005e	74 4e		 je	 SHORT $LN11@check_guid
  00060	eb 5a		 jmp	 SHORT $LN12@check_guid
$LN8@check_guid:

; 348  : 		case(16):
; 349  : 			sfdat->samptype = PSF_SAMP_16;

  00062	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  00067	c7 40 30 02 00
	00 00		 mov	 DWORD PTR [rax+48], 2

; 350  : 			break;

  0006e	eb 62		 jmp	 SHORT $LN2@check_guid
$LN9@check_guid:

; 351  : 		case(24):
; 352  : 			/* only support packed format for now */
; 353  : 			if((sfdat->fmt.Format.nBlockAlign / sfdat->fmt.Format.nChannels) != 3){

  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  00075	0f b7 40 5c	 movzx	 eax, WORD PTR [rax+92]
  00079	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0007e	0f b7 49 52	 movzx	 ecx, WORD PTR [rcx+82]
  00082	99		 cdq
  00083	f7 f9		 idiv	 ecx
  00085	83 f8 03	 cmp	 eax, 3
  00088	74 16		 je	 SHORT $LN10@check_guid

; 354  : 				sfdat->samptype = PSF_SAMP_UNKNOWN;

  0008a	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  0008f	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 355  : 				return 1;

  00096	b8 01 00 00 00	 mov	 eax, 1
  0009b	e9 82 01 00 00	 jmp	 $LN1@check_guid
$LN10@check_guid:

; 356  : 			}
; 357  : 			sfdat->samptype = PSF_SAMP_24;

  000a0	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  000a5	c7 40 30 03 00
	00 00		 mov	 DWORD PTR [rax+48], 3

; 358  : 			break;

  000ac	eb 24		 jmp	 SHORT $LN2@check_guid
$LN11@check_guid:

; 359  : 		case(32):
; 360  : 			sfdat->samptype = PSF_SAMP_32;

  000ae	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  000b3	c7 40 30 04 00
	00 00		 mov	 DWORD PTR [rax+48], 4

; 361  : 			break;

  000ba	eb 16		 jmp	 SHORT $LN2@check_guid
$LN12@check_guid:

; 362  : 		default:
; 363  : 			sfdat->samptype = PSF_SAMP_UNKNOWN;

  000bc	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  000c1	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 364  : 			return 1;

  000c8	b8 01 00 00 00	 mov	 eax, 1
  000cd	e9 50 01 00 00	 jmp	 $LN1@check_guid
$LN2@check_guid:

; 365  : 		}
; 366  : 		return 0;

  000d2	33 c0		 xor	 eax, eax
  000d4	e9 49 01 00 00	 jmp	 $LN1@check_guid
$LN7@check_guid:

; 367  : 	}
; 368  : 	if(compare_guids(&(sfdat->fmt.SubFormat),&(KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)))

  000d9	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  000de	48 83 c0 6c	 add	 rax, 108		; 0000006cH
  000e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:KSDATAFORMAT_SUBTYPE_IEEE_FLOAT
  000e9	48 8b c8	 mov	 rcx, rax
  000ec	e8 00 00 00 00	 call	 compare_guids
  000f1	85 c0		 test	 eax, eax
  000f3	74 21		 je	 SHORT $LN13@check_guid

; 369  : 		if(sfdat->fmt.Format.wBitsPerSample == 32) {

  000f5	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  000fa	0f b7 40 5e	 movzx	 eax, WORD PTR [rax+94]
  000fe	83 f8 20	 cmp	 eax, 32			; 00000020H
  00101	75 13		 jne	 SHORT $LN14@check_guid

; 370  : 			sfdat->samptype = PSF_SAMP_IEEE_FLOAT;

  00103	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  00108	c7 40 30 05 00
	00 00		 mov	 DWORD PTR [rax+48], 5

; 371  : 			return 0;	

  0010f	33 c0		 xor	 eax, eax
  00111	e9 0c 01 00 00	 jmp	 $LN1@check_guid
$LN14@check_guid:
$LN13@check_guid:

; 372  : 		}
; 373  : 	/* add other recognised GUIDs here... */
; 374  :     if(compare_guids(&(sfdat->fmt.SubFormat),&(SUBTYPE_AMBISONIC_B_FORMAT_IEEE_FLOAT)))

  00116	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  0011b	48 83 c0 6c	 add	 rax, 108		; 0000006cH
  0011f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:SUBTYPE_AMBISONIC_B_FORMAT_IEEE_FLOAT
  00126	48 8b c8	 mov	 rcx, rax
  00129	e8 00 00 00 00	 call	 compare_guids
  0012e	85 c0		 test	 eax, eax
  00130	74 2d		 je	 SHORT $LN15@check_guid

; 375  : 		if(sfdat->fmt.Format.wBitsPerSample == 32) {

  00132	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  00137	0f b7 40 5e	 movzx	 eax, WORD PTR [rax+94]
  0013b	83 f8 20	 cmp	 eax, 32			; 00000020H
  0013e	75 1f		 jne	 SHORT $LN16@check_guid

; 376  : 			sfdat->samptype = PSF_SAMP_IEEE_FLOAT;

  00140	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  00145	c7 40 30 05 00
	00 00		 mov	 DWORD PTR [rax+48], 5

; 377  : 			sfdat->chformat = MC_BFMT;

  0014c	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  00151	c7 40 7c 06 00
	00 00		 mov	 DWORD PTR [rax+124], 6

; 378  : 			return 0;	

  00158	33 c0		 xor	 eax, eax
  0015a	e9 c3 00 00 00	 jmp	 $LN1@check_guid
$LN16@check_guid:
$LN15@check_guid:

; 379  : 		}
; 380  : 	if(compare_guids(&(sfdat->fmt.SubFormat),&(SUBTYPE_AMBISONIC_B_FORMAT_PCM))) {

  0015f	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  00164	48 83 c0 6c	 add	 rax, 108		; 0000006cH
  00168	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:SUBTYPE_AMBISONIC_B_FORMAT_PCM
  0016f	48 8b c8	 mov	 rcx, rax
  00172	e8 00 00 00 00	 call	 compare_guids
  00177	85 c0		 test	 eax, eax
  00179	0f 84 9e 00 00
	00		 je	 $LN17@check_guid

; 381  : 		switch(sfdat->fmt.Format.wBitsPerSample){

  0017f	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  00184	0f b7 40 5e	 movzx	 eax, WORD PTR [rax+94]
  00188	89 44 24 24	 mov	 DWORD PTR tv146[rsp], eax
  0018c	83 7c 24 24 10	 cmp	 DWORD PTR tv146[rsp], 16
  00191	74 10		 je	 SHORT $LN18@check_guid
  00193	83 7c 24 24 18	 cmp	 DWORD PTR tv146[rsp], 24
  00198	74 17		 je	 SHORT $LN19@check_guid
  0019a	83 7c 24 24 20	 cmp	 DWORD PTR tv146[rsp], 32 ; 00000020H
  0019f	74 4b		 je	 SHORT $LN21@check_guid
  001a1	eb 57		 jmp	 SHORT $LN22@check_guid
$LN18@check_guid:

; 382  : 		case(16):
; 383  : 			sfdat->samptype = PSF_SAMP_16;

  001a3	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  001a8	c7 40 30 02 00
	00 00		 mov	 DWORD PTR [rax+48], 2

; 384  : 			break;

  001af	eb 5c		 jmp	 SHORT $LN4@check_guid
$LN19@check_guid:

; 385  : 		case(24):
; 386  : 			/* only support packed format for now */
; 387  : 			if((sfdat->fmt.Format.nBlockAlign / sfdat->fmt.Format.nChannels) != 3){

  001b1	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  001b6	0f b7 40 5c	 movzx	 eax, WORD PTR [rax+92]
  001ba	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sfdat$[rsp]
  001bf	0f b7 49 52	 movzx	 ecx, WORD PTR [rcx+82]
  001c3	99		 cdq
  001c4	f7 f9		 idiv	 ecx
  001c6	83 f8 03	 cmp	 eax, 3
  001c9	74 13		 je	 SHORT $LN20@check_guid

; 388  : 				sfdat->samptype = PSF_SAMP_UNKNOWN;

  001cb	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  001d0	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 389  : 				return 1;

  001d7	b8 01 00 00 00	 mov	 eax, 1
  001dc	eb 44		 jmp	 SHORT $LN1@check_guid
$LN20@check_guid:

; 390  : 			}
; 391  : 			sfdat->samptype = PSF_SAMP_24;

  001de	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  001e3	c7 40 30 03 00
	00 00		 mov	 DWORD PTR [rax+48], 3

; 392  : 			break;

  001ea	eb 21		 jmp	 SHORT $LN4@check_guid
$LN21@check_guid:

; 393  : 		case(32):
; 394  : 			sfdat->samptype = PSF_SAMP_32;

  001ec	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  001f1	c7 40 30 04 00
	00 00		 mov	 DWORD PTR [rax+48], 4

; 395  : 			break;

  001f8	eb 13		 jmp	 SHORT $LN4@check_guid
$LN22@check_guid:

; 396  : 		default:
; 397  : 			sfdat->samptype = PSF_SAMP_UNKNOWN;

  001fa	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  001ff	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 398  : 			return 1;

  00206	b8 01 00 00 00	 mov	 eax, 1
  0020b	eb 15		 jmp	 SHORT $LN1@check_guid
$LN4@check_guid:

; 399  : 		}
; 400  : 		sfdat->chformat = MC_BFMT;

  0020d	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  00212	c7 40 7c 06 00
	00 00		 mov	 DWORD PTR [rax+124], 6

; 401  : 		return 0;

  00219	33 c0		 xor	 eax, eax
  0021b	eb 05		 jmp	 SHORT $LN1@check_guid
$LN17@check_guid:

; 402  : 	}
; 403  : 	return 1;	

  0021d	b8 01 00 00 00	 mov	 eax, 1
$LN1@check_guid:

; 404  : }

  00222	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00226	c3		 ret	 0
check_guid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
pfmt$ = 0
pfmtEx$ = 8
sfdat$ = 32
fmtExSwapBytes PROC

; 321  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 322  : 	WAVEFORMATEXTENSIBLE  *pfmtEx =  &(sfdat->fmt);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  0000e	48 83 c0 50	 add	 rax, 80			; 00000050H
  00012	48 89 44 24 08	 mov	 QWORD PTR pfmtEx$[rsp], rax

; 323  : 	WAVEFORMATEX          *pfmt   = &(pfmtEx->Format);

  00017	48 8b 44 24 08	 mov	 rax, QWORD PTR pfmtEx$[rsp]
  0001c	48 89 04 24	 mov	 QWORD PTR pfmt$[rsp], rax

; 324  : 
; 325  : 	pfmt->wFormatTag	= (WORD) REVWBYTES(pfmt->wFormatTag);

  00020	48 8b 04 24	 mov	 rax, QWORD PTR pfmt$[rsp]
  00024	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00027	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0002c	c1 e0 08	 shl	 eax, 8
  0002f	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  00033	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  00036	c1 f9 08	 sar	 ecx, 8
  00039	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0003f	0b c1		 or	 eax, ecx
  00041	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  00045	66 89 01	 mov	 WORD PTR [rcx], ax

; 326  : 	pfmt->nChannels		= (WORD) REVWBYTES(pfmt->nChannels);

  00048	48 8b 04 24	 mov	 rax, QWORD PTR pfmt$[rsp]
  0004c	0f b7 40 02	 movzx	 eax, WORD PTR [rax+2]
  00050	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00055	c1 e0 08	 shl	 eax, 8
  00058	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  0005c	0f b7 49 02	 movzx	 ecx, WORD PTR [rcx+2]
  00060	c1 f9 08	 sar	 ecx, 8
  00063	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00069	0b c1		 or	 eax, ecx
  0006b	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  0006f	66 89 41 02	 mov	 WORD PTR [rcx+2], ax

; 327  : 	pfmt->nSamplesPerSec	= REVDWBYTES(pfmt->nSamplesPerSec);

  00073	48 8b 04 24	 mov	 rax, QWORD PTR pfmt$[rsp]
  00077	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0007a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0007f	c1 e0 18	 shl	 eax, 24
  00082	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  00086	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00089	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  0008f	c1 e1 08	 shl	 ecx, 8
  00092	0b c1		 or	 eax, ecx
  00094	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  00098	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  0009b	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  000a1	c1 e9 08	 shr	 ecx, 8
  000a4	0b c1		 or	 eax, ecx
  000a6	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  000aa	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  000ad	c1 e9 18	 shr	 ecx, 24
  000b0	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000b6	0b c1		 or	 eax, ecx
  000b8	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  000bc	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 328  : 	pfmt->nAvgBytesPerSec	= REVDWBYTES(pfmt->nAvgBytesPerSec);

  000bf	48 8b 04 24	 mov	 rax, QWORD PTR pfmt$[rsp]
  000c3	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000c6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000cb	c1 e0 18	 shl	 eax, 24
  000ce	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  000d2	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  000d5	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  000db	c1 e1 08	 shl	 ecx, 8
  000de	0b c1		 or	 eax, ecx
  000e0	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  000e4	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  000e7	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  000ed	c1 e9 08	 shr	 ecx, 8
  000f0	0b c1		 or	 eax, ecx
  000f2	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  000f6	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  000f9	c1 e9 18	 shr	 ecx, 24
  000fc	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00102	0b c1		 or	 eax, ecx
  00104	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  00108	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 329  : 	pfmt->nBlockAlign	= (WORD) REVWBYTES(pfmt->nBlockAlign);

  0010b	48 8b 04 24	 mov	 rax, QWORD PTR pfmt$[rsp]
  0010f	0f b7 40 0c	 movzx	 eax, WORD PTR [rax+12]
  00113	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00118	c1 e0 08	 shl	 eax, 8
  0011b	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  0011f	0f b7 49 0c	 movzx	 ecx, WORD PTR [rcx+12]
  00123	c1 f9 08	 sar	 ecx, 8
  00126	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0012c	0b c1		 or	 eax, ecx
  0012e	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  00132	66 89 41 0c	 mov	 WORD PTR [rcx+12], ax

; 330  : 	pfmt->wBitsPerSample	= (WORD) REVWBYTES(pfmt->wBitsPerSample);

  00136	48 8b 04 24	 mov	 rax, QWORD PTR pfmt$[rsp]
  0013a	0f b7 40 0e	 movzx	 eax, WORD PTR [rax+14]
  0013e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00143	c1 e0 08	 shl	 eax, 8
  00146	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  0014a	0f b7 49 0e	 movzx	 ecx, WORD PTR [rcx+14]
  0014e	c1 f9 08	 sar	 ecx, 8
  00151	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00157	0b c1		 or	 eax, ecx
  00159	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  0015d	66 89 41 0e	 mov	 WORD PTR [rcx+14], ax

; 331  : 	pfmt->cbSize			= (WORD) REVWBYTES(pfmt->cbSize);

  00161	48 8b 04 24	 mov	 rax, QWORD PTR pfmt$[rsp]
  00165	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  00169	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0016e	c1 e0 08	 shl	 eax, 8
  00171	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  00175	0f b7 49 10	 movzx	 ecx, WORD PTR [rcx+16]
  00179	c1 f9 08	 sar	 ecx, 8
  0017c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00182	0b c1		 or	 eax, ecx
  00184	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  00188	66 89 41 10	 mov	 WORD PTR [rcx+16], ax

; 332  :     pfmtEx->Samples.wValidBitsPerSample = (WORD) REVWBYTES(pfmtEx->Samples.wValidBitsPerSample);

  0018c	48 8b 44 24 08	 mov	 rax, QWORD PTR pfmtEx$[rsp]
  00191	0f b7 40 14	 movzx	 eax, WORD PTR [rax+20]
  00195	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0019a	c1 e0 08	 shl	 eax, 8
  0019d	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pfmtEx$[rsp]
  001a2	0f b7 49 14	 movzx	 ecx, WORD PTR [rcx+20]
  001a6	c1 f9 08	 sar	 ecx, 8
  001a9	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  001af	0b c1		 or	 eax, ecx
  001b1	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pfmtEx$[rsp]
  001b6	66 89 41 14	 mov	 WORD PTR [rcx+20], ax

; 333  :     pfmtEx->dwChannelMask     = (DWORD) REVDWBYTES(pfmtEx->dwChannelMask);

  001ba	48 8b 44 24 08	 mov	 rax, QWORD PTR pfmtEx$[rsp]
  001bf	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  001c2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001c7	c1 e0 18	 shl	 eax, 24
  001ca	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pfmtEx$[rsp]
  001cf	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  001d2	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  001d8	c1 e1 08	 shl	 ecx, 8
  001db	0b c1		 or	 eax, ecx
  001dd	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pfmtEx$[rsp]
  001e2	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  001e5	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  001eb	c1 e9 08	 shr	 ecx, 8
  001ee	0b c1		 or	 eax, ecx
  001f0	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pfmtEx$[rsp]
  001f5	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  001f8	c1 e9 18	 shr	 ecx, 24
  001fb	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00201	0b c1		 or	 eax, ecx
  00203	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pfmtEx$[rsp]
  00208	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 334  : 	/* we swap numeric fields of GUID, but not the char string */		
; 335  : 	pfmtEx->SubFormat.Data1 = REVDWBYTES(pfmtEx->SubFormat.Data1);

  0020b	48 8b 44 24 08	 mov	 rax, QWORD PTR pfmtEx$[rsp]
  00210	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00213	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00218	c1 e0 18	 shl	 eax, 24
  0021b	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pfmtEx$[rsp]
  00220	8b 49 1c	 mov	 ecx, DWORD PTR [rcx+28]
  00223	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00229	c1 e1 08	 shl	 ecx, 8
  0022c	0b c1		 or	 eax, ecx
  0022e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pfmtEx$[rsp]
  00233	8b 49 1c	 mov	 ecx, DWORD PTR [rcx+28]
  00236	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  0023c	c1 e9 08	 shr	 ecx, 8
  0023f	0b c1		 or	 eax, ecx
  00241	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pfmtEx$[rsp]
  00246	8b 49 1c	 mov	 ecx, DWORD PTR [rcx+28]
  00249	c1 e9 18	 shr	 ecx, 24
  0024c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00252	0b c1		 or	 eax, ecx
  00254	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pfmtEx$[rsp]
  00259	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 336  : 	pfmtEx->SubFormat.Data2 = (WORD) REVWBYTES(pfmtEx->SubFormat.Data2);

  0025c	48 8b 44 24 08	 mov	 rax, QWORD PTR pfmtEx$[rsp]
  00261	0f b7 40 20	 movzx	 eax, WORD PTR [rax+32]
  00265	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0026a	c1 e0 08	 shl	 eax, 8
  0026d	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pfmtEx$[rsp]
  00272	0f b7 49 20	 movzx	 ecx, WORD PTR [rcx+32]
  00276	c1 f9 08	 sar	 ecx, 8
  00279	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0027f	0b c1		 or	 eax, ecx
  00281	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pfmtEx$[rsp]
  00286	66 89 41 20	 mov	 WORD PTR [rcx+32], ax

; 337  : 	pfmtEx->SubFormat.Data3 = (WORD) REVWBYTES(pfmtEx->SubFormat.Data3);

  0028a	48 8b 44 24 08	 mov	 rax, QWORD PTR pfmtEx$[rsp]
  0028f	0f b7 40 22	 movzx	 eax, WORD PTR [rax+34]
  00293	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00298	c1 e0 08	 shl	 eax, 8
  0029b	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pfmtEx$[rsp]
  002a0	0f b7 49 22	 movzx	 ecx, WORD PTR [rcx+34]
  002a4	c1 f9 08	 sar	 ecx, 8
  002a7	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  002ad	0b c1		 or	 eax, ecx
  002af	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pfmtEx$[rsp]
  002b4	66 89 41 22	 mov	 WORD PTR [rcx+34], ax

; 338  : }

  002b8	48 83 c4 18	 add	 rsp, 24
  002bc	c3		 ret	 0
fmtExSwapBytes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
pfmt$ = 0
sfdat$ = 32
fmtSwapBytes PROC

; 309  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 310  : 	WAVEFORMATEX  *pfmt	= (WAVEFORMATEX *) &(sfdat->fmt.Format);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR sfdat$[rsp]
  0000e	48 83 c0 50	 add	 rax, 80			; 00000050H
  00012	48 89 04 24	 mov	 QWORD PTR pfmt$[rsp], rax

; 311  : 	
; 312  : 	pfmt->wFormatTag	= (WORD) REVWBYTES(pfmt->wFormatTag);

  00016	48 8b 04 24	 mov	 rax, QWORD PTR pfmt$[rsp]
  0001a	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0001d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00022	c1 e0 08	 shl	 eax, 8
  00025	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  00029	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  0002c	c1 f9 08	 sar	 ecx, 8
  0002f	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00035	0b c1		 or	 eax, ecx
  00037	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  0003b	66 89 01	 mov	 WORD PTR [rcx], ax

; 313  : 	pfmt->nChannels		= (WORD) REVWBYTES(pfmt->nChannels);

  0003e	48 8b 04 24	 mov	 rax, QWORD PTR pfmt$[rsp]
  00042	0f b7 40 02	 movzx	 eax, WORD PTR [rax+2]
  00046	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0004b	c1 e0 08	 shl	 eax, 8
  0004e	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  00052	0f b7 49 02	 movzx	 ecx, WORD PTR [rcx+2]
  00056	c1 f9 08	 sar	 ecx, 8
  00059	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0005f	0b c1		 or	 eax, ecx
  00061	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  00065	66 89 41 02	 mov	 WORD PTR [rcx+2], ax

; 314  : 	pfmt->nSamplesPerSec	= REVDWBYTES(pfmt->nSamplesPerSec);

  00069	48 8b 04 24	 mov	 rax, QWORD PTR pfmt$[rsp]
  0006d	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00070	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00075	c1 e0 18	 shl	 eax, 24
  00078	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  0007c	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  0007f	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00085	c1 e1 08	 shl	 ecx, 8
  00088	0b c1		 or	 eax, ecx
  0008a	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  0008e	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00091	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00097	c1 e9 08	 shr	 ecx, 8
  0009a	0b c1		 or	 eax, ecx
  0009c	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  000a0	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  000a3	c1 e9 18	 shr	 ecx, 24
  000a6	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000ac	0b c1		 or	 eax, ecx
  000ae	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  000b2	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 315  : 	pfmt->nAvgBytesPerSec	= REVDWBYTES(pfmt->nAvgBytesPerSec);

  000b5	48 8b 04 24	 mov	 rax, QWORD PTR pfmt$[rsp]
  000b9	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000bc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000c1	c1 e0 18	 shl	 eax, 24
  000c4	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  000c8	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  000cb	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  000d1	c1 e1 08	 shl	 ecx, 8
  000d4	0b c1		 or	 eax, ecx
  000d6	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  000da	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  000dd	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  000e3	c1 e9 08	 shr	 ecx, 8
  000e6	0b c1		 or	 eax, ecx
  000e8	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  000ec	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  000ef	c1 e9 18	 shr	 ecx, 24
  000f2	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000f8	0b c1		 or	 eax, ecx
  000fa	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  000fe	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 316  : 	pfmt->nBlockAlign	= (WORD) REVWBYTES(pfmt->nBlockAlign);

  00101	48 8b 04 24	 mov	 rax, QWORD PTR pfmt$[rsp]
  00105	0f b7 40 0c	 movzx	 eax, WORD PTR [rax+12]
  00109	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0010e	c1 e0 08	 shl	 eax, 8
  00111	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  00115	0f b7 49 0c	 movzx	 ecx, WORD PTR [rcx+12]
  00119	c1 f9 08	 sar	 ecx, 8
  0011c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00122	0b c1		 or	 eax, ecx
  00124	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  00128	66 89 41 0c	 mov	 WORD PTR [rcx+12], ax

; 317  : 	pfmt->wBitsPerSample	= (WORD) REVWBYTES(pfmt->wBitsPerSample);	

  0012c	48 8b 04 24	 mov	 rax, QWORD PTR pfmt$[rsp]
  00130	0f b7 40 0e	 movzx	 eax, WORD PTR [rax+14]
  00134	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00139	c1 e0 08	 shl	 eax, 8
  0013c	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  00140	0f b7 49 0e	 movzx	 ecx, WORD PTR [rcx+14]
  00144	c1 f9 08	 sar	 ecx, 8
  00147	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0014d	0b c1		 or	 eax, ecx
  0014f	48 8b 0c 24	 mov	 rcx, QWORD PTR pfmt$[rsp]
  00153	66 89 41 0e	 mov	 WORD PTR [rcx+14], ax

; 318  : }

  00157	48 83 c4 18	 add	 rsp, 24
  0015b	c3		 ret	 0
fmtSwapBytes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
one$ = 0
endptr$ = 8
byte_order PROC

; 301  : {						    

  00000	48 83 ec 18	 sub	 rsp, 24

; 302  :   int   one = 1;

  00004	c7 04 24 01 00
	00 00		 mov	 DWORD PTR one$[rsp], 1

; 303  :   char* endptr = (char *) &one;

  0000b	48 8d 04 24	 lea	 rax, QWORD PTR one$[rsp]
  0000f	48 89 44 24 08	 mov	 QWORD PTR endptr$[rsp], rax

; 304  :   return (*endptr);

  00014	48 8b 44 24 08	 mov	 rax, QWORD PTR endptr$[rsp]
  00019	0f be 00	 movsx	 eax, BYTE PTR [rax]

; 305  : }

  0001c	48 83 c4 18	 add	 rsp, 24
  00020	c3		 ret	 0
byte_order ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
rc$ = 32
psff$ = 64
psf_release_file PROC

; 252  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 253  : 	int rc = 0;	

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 254  : #ifdef _DEBUG
; 255  : 	assert(psff);
; 256  : #endif
; 257  :       
; 258  :    if(psff->file){

  00011	48 8b 44 24 40	 mov	 rax, QWORD PTR psff$[rsp]
  00016	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0001a	74 2a		 je	 SHORT $LN2@psf_releas

; 259  :        rc = fclose(psff->file);

  0001c	48 8b 44 24 40	 mov	 rax, QWORD PTR psff$[rsp]
  00021	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00024	e8 00 00 00 00	 call	 fclose
  00029	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 260  :        if(rc)

  0002d	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00032	74 06		 je	 SHORT $LN3@psf_releas

; 261  :             return rc;

  00034	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  00038	eb 67		 jmp	 SHORT $LN1@psf_releas
$LN3@psf_releas:

; 262  :         psff->file = NULL;

  0003a	48 8b 44 24 40	 mov	 rax, QWORD PTR psff$[rsp]
  0003f	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN2@psf_releas:

; 263  :    }
; 264  :    if(psff->filename){

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR psff$[rsp]
  0004b	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00050	74 1b		 je	 SHORT $LN4@psf_releas

; 265  : 	   free(psff->filename);

  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR psff$[rsp]
  00057	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0005b	e8 00 00 00 00	 call	 free

; 266  : 	   psff->filename = NULL;

  00060	48 8b 44 24 40	 mov	 rax, QWORD PTR psff$[rsp]
  00065	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
$LN4@psf_releas:

; 267  :    }
; 268  :    if(psff->pPeaks) {

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR psff$[rsp]
  00072	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  0007a	74 21		 je	 SHORT $LN5@psf_releas

; 269  :        free(psff->pPeaks);

  0007c	48 8b 44 24 40	 mov	 rax, QWORD PTR psff$[rsp]
  00081	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00088	e8 00 00 00 00	 call	 free

; 270  :        psff->pPeaks = NULL;

  0008d	48 8b 44 24 40	 mov	 rax, QWORD PTR psff$[rsp]
  00092	48 c7 80 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+128], 0
$LN5@psf_releas:

; 271  :    }       
; 272  :    return rc;

  0009d	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@psf_releas:

; 273  : }

  000a1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a5	c3		 ret	 0
psf_release_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
tv69 = 32
right$ = 40
left$ = 48
gleft$ = 80
gright$ = 88
compare_guids PROC

; 226  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 227  : 	const char *left = (const char *) gleft, *right = (const char *) gright;

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR gleft$[rsp]
  00013	48 89 44 24 30	 mov	 QWORD PTR left$[rsp], rax
  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR gright$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR right$[rsp], rax

; 228  : 	return !memcmp(left,right,sizeof(GUID));

  00022	41 b8 10 00 00
	00		 mov	 r8d, 16
  00028	48 8b 54 24 28	 mov	 rdx, QWORD PTR right$[rsp]
  0002d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR left$[rsp]
  00032	e8 00 00 00 00	 call	 memcmp
  00037	85 c0		 test	 eax, eax
  00039	75 0a		 jne	 SHORT $LN3@compare_gu
  0003b	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv69[rsp], 1
  00043	eb 08		 jmp	 SHORT $LN4@compare_gu
$LN3@compare_gu:
  00045	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
$LN4@compare_gu:
  0004d	8b 44 24 20	 mov	 eax, DWORD PTR tv69[rsp]

; 229  : }

  00051	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00055	c3		 ret	 0
compare_guids ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
r1$ = 32
r2$ = 40
trirand	PROC

; 3307 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3308 : 	double r1,r2;
; 3309 : 	r1 = (double) rand() * inv_randmax;

  00004	e8 00 00 00 00	 call	 rand
  00009	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  0000d	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR inv_randmax
  00015	f2 0f 11 44 24
	20		 movsd	 QWORD PTR r1$[rsp], xmm0

; 3310 : 	r2 = (double) rand() * inv_randmax;

  0001b	e8 00 00 00 00	 call	 rand
  00020	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  00024	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR inv_randmax
  0002c	f2 0f 11 44 24
	28		 movsd	 QWORD PTR r2$[rsp], xmm0

; 3311 : 
; 3312 : 	return (float)((r1 + r2) - 1.0);

  00032	f2 0f 10 44 24
	20		 movsd	 xmm0, QWORD PTR r1$[rsp]
  00038	f2 0f 58 44 24
	28		 addsd	 xmm0, QWORD PTR r2$[rsp]
  0003e	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00046	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0

; 3313 : 
; 3314 : 
; 3315 : }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
trirand	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
tv64 = 0
chformat$ = 4
chmask$ = 32
chans$ = 40
get_speakerlayout PROC

; 3360 : {

$LN22:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 18	 sub	 rsp, 24

; 3361 :     psf_channelformat chformat = MC_WAVE_EX;	// default is some weird format!

  0000c	c7 44 24 04 0a
	00 00 00	 mov	 DWORD PTR chformat$[rsp], 10

; 3362 :     
; 3363 :     /* accept chancount > numbits set in speakermask */
; 3364 :     switch(chmask){

  00014	8b 44 24 20	 mov	 eax, DWORD PTR chmask$[rsp]
  00018	89 04 24	 mov	 DWORD PTR tv64[rsp], eax
  0001b	83 3c 24 3f	 cmp	 DWORD PTR tv64[rsp], 63	; 0000003fH
  0001f	77 27		 ja	 SHORT $LN21@get_speake
  00021	83 3c 24 3f	 cmp	 DWORD PTR tv64[rsp], 63	; 0000003fH
  00025	0f 84 82 00 00
	00		 je	 $LN13@get_speake
  0002b	83 3c 24 00	 cmp	 DWORD PTR tv64[rsp], 0
  0002f	74 2e		 je	 SHORT $LN4@get_speake
  00031	83 3c 24 03	 cmp	 DWORD PTR tv64[rsp], 3
  00035	74 43		 je	 SHORT $LN7@get_speake
  00037	83 3c 24 33	 cmp	 DWORD PTR tv64[rsp], 51	; 00000033H
  0003b	74 4e		 je	 SHORT $LN9@get_speake
  0003d	83 3c 24 37	 cmp	 DWORD PTR tv64[rsp], 55	; 00000037H
  00041	74 7b		 je	 SHORT $LN15@get_speake
  00043	e9 96 00 00 00	 jmp	 $LN19@get_speake
$LN21@get_speake:
  00048	83 3c 24 40	 cmp	 DWORD PTR tv64[rsp], 64	; 00000040H
  0004c	74 1b		 je	 SHORT $LN5@get_speake
  0004e	83 3c 24 7f	 cmp	 DWORD PTR tv64[rsp], 127 ; 0000007fH
  00052	74 7b		 je	 SHORT $LN17@get_speake
  00054	81 3c 24 07 01
	00 00		 cmp	 DWORD PTR tv64[rsp], 263 ; 00000107H
  0005b	74 3f		 je	 SHORT $LN11@get_speake
  0005d	eb 7f		 jmp	 SHORT $LN19@get_speake
$LN4@get_speake:

; 3365 :         case(SPKRS_UNASSIGNED):
; 3366 :             chformat = MC_STD;

  0005f	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR chformat$[rsp], 1

; 3367 :             break;

  00067	eb 75		 jmp	 SHORT $LN2@get_speake
$LN5@get_speake:

; 3368 :         case(SPKRS_MONO):
; 3369 :             if(chans==1)

  00069	83 7c 24 28 01	 cmp	 DWORD PTR chans$[rsp], 1
  0006e	75 08		 jne	 SHORT $LN6@get_speake

; 3370 :                 chformat = MC_MONO;

  00070	c7 44 24 04 02
	00 00 00	 mov	 DWORD PTR chformat$[rsp], 2
$LN6@get_speake:

; 3371 :             break;

  00078	eb 64		 jmp	 SHORT $LN2@get_speake
$LN7@get_speake:

; 3372 :         case(SPKRS_STEREO):
; 3373 :             if(chans==2)

  0007a	83 7c 24 28 02	 cmp	 DWORD PTR chans$[rsp], 2
  0007f	75 08		 jne	 SHORT $LN8@get_speake

; 3374 :                 chformat = MC_STEREO;

  00081	c7 44 24 04 03
	00 00 00	 mov	 DWORD PTR chformat$[rsp], 3
$LN8@get_speake:

; 3375 :             break;

  00089	eb 53		 jmp	 SHORT $LN2@get_speake
$LN9@get_speake:

; 3376 :         case(SPKRS_GENERIC_QUAD):
; 3377 :             if(chans==4)

  0008b	83 7c 24 28 04	 cmp	 DWORD PTR chans$[rsp], 4
  00090	75 08		 jne	 SHORT $LN10@get_speake

; 3378 :                 chformat = MC_QUAD;

  00092	c7 44 24 04 04
	00 00 00	 mov	 DWORD PTR chformat$[rsp], 4
$LN10@get_speake:

; 3379 :             break;			

  0009a	eb 42		 jmp	 SHORT $LN2@get_speake
$LN11@get_speake:

; 3380 :         case(SPKRS_SURROUND_LCRS):
; 3381 :             if(chans==4)

  0009c	83 7c 24 28 04	 cmp	 DWORD PTR chans$[rsp], 4
  000a1	75 08		 jne	 SHORT $LN12@get_speake

; 3382 :                 chformat = MC_LCRS;

  000a3	c7 44 24 04 05
	00 00 00	 mov	 DWORD PTR chformat$[rsp], 5
$LN12@get_speake:

; 3383 :             break;

  000ab	eb 31		 jmp	 SHORT $LN2@get_speake
$LN13@get_speake:

; 3384 :         case(SPKRS_DOLBY5_1):
; 3385 :             if(chans==6)

  000ad	83 7c 24 28 06	 cmp	 DWORD PTR chans$[rsp], 6
  000b2	75 08		 jne	 SHORT $LN14@get_speake

; 3386 :                 chformat = MC_DOLBY_5_1;

  000b4	c7 44 24 04 07
	00 00 00	 mov	 DWORD PTR chformat$[rsp], 7
$LN14@get_speake:

; 3387 :             break;

  000bc	eb 20		 jmp	 SHORT $LN2@get_speake
$LN15@get_speake:

; 3388 :         case(SPKRS_SURR_5_0):                   
; 3389 :             if(chans==5)

  000be	83 7c 24 28 05	 cmp	 DWORD PTR chans$[rsp], 5
  000c3	75 08		 jne	 SHORT $LN16@get_speake

; 3390 :                 chformat = MC_SURR_5_0;

  000c5	c7 44 24 04 08
	00 00 00	 mov	 DWORD PTR chformat$[rsp], 8
$LN16@get_speake:

; 3391 :             break;

  000cd	eb 0f		 jmp	 SHORT $LN2@get_speake
$LN17@get_speake:

; 3392 :         case(SPKRS_7_1):
; 3393 :             if(chans==8)

  000cf	83 7c 24 28 08	 cmp	 DWORD PTR chans$[rsp], 8
  000d4	75 08		 jne	 SHORT $LN18@get_speake

; 3394 :                 chformat = MC_SURR_7_1;

  000d6	c7 44 24 04 09
	00 00 00	 mov	 DWORD PTR chformat$[rsp], 9
$LN18@get_speake:
$LN19@get_speake:
$LN2@get_speake:

; 3395 :             break;
; 3396 :         default:
; 3397 :             break;
; 3398 :     }
; 3399 :     return chformat;

  000de	8b 44 24 04	 mov	 eax, DWORD PTR chformat$[rsp]

; 3400 : }

  000e2	48 83 c4 18	 add	 rsp, 24
  000e6	c3		 ret	 0
get_speakerlayout ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
sfdat$ = 0
sfd$ = 32
psf_speakermask PROC

; 3403 : {

$LN6:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 3404 :     PSFFILE *sfdat;
; 3405 :     
; 3406 : 	if(sfd < 0 || sfd > psf_maxfiles)

  00008	83 7c 24 20 00	 cmp	 DWORD PTR sfd$[rsp], 0
  0000d	7c 07		 jl	 SHORT $LN3@psf_speake
  0000f	83 7c 24 20 40	 cmp	 DWORD PTR sfd$[rsp], 64	; 00000040H
  00014	7e 07		 jle	 SHORT $LN2@psf_speake
$LN3@psf_speake:

; 3407 : 		return PSF_E_BADARG;

  00016	b8 f6 ff ff ff	 mov	 eax, -10
  0001b	eb 29		 jmp	 SHORT $LN1@psf_speake
$LN2@psf_speake:

; 3408 : 	
; 3409 : 	sfdat  = psf_files[sfd];

  0001d	48 63 44 24 20	 movsxd	 rax, DWORD PTR sfd$[rsp]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:psf_files
  00029	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0002d	48 89 04 24	 mov	 QWORD PTR sfdat$[rsp], rax

; 3410 : 	if(sfdat==NULL)

  00031	48 83 3c 24 00	 cmp	 QWORD PTR sfdat$[rsp], 0
  00036	75 07		 jne	 SHORT $LN4@psf_speake

; 3411 : 		return PSF_E_BADARG;

  00038	b8 f6 ff ff ff	 mov	 eax, -10
  0003d	eb 07		 jmp	 SHORT $LN1@psf_speake
$LN4@psf_speake:

; 3412 :     
; 3413 :     return (int) sfdat->fmt.dwChannelMask;

  0003f	48 8b 04 24	 mov	 rax, QWORD PTR sfdat$[rsp]
  00043	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
$LN1@psf_speake:

; 3414 : }

  00046	48 83 c4 18	 add	 rsp, 24
  0004a	c3		 ret	 0
psf_speakermask ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
sfdat$ = 0
sfd$ = 32
psf_sndGetDither PROC

; 3341 : {

$LN6:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 3342 : 	PSFFILE *sfdat;
; 3343 : 
; 3344 : 	if(sfd < 0 || sfd > psf_maxfiles)

  00008	83 7c 24 20 00	 cmp	 DWORD PTR sfd$[rsp], 0
  0000d	7c 07		 jl	 SHORT $LN3@psf_sndGet
  0000f	83 7c 24 20 40	 cmp	 DWORD PTR sfd$[rsp], 64	; 00000040H
  00014	7e 07		 jle	 SHORT $LN2@psf_sndGet
$LN3@psf_sndGet:

; 3345 : 		return PSF_E_BADARG;

  00016	b8 f6 ff ff ff	 mov	 eax, -10
  0001b	eb 2c		 jmp	 SHORT $LN1@psf_sndGet
$LN2@psf_sndGet:

; 3346 : 	
; 3347 : 	sfdat  = psf_files[sfd];

  0001d	48 63 44 24 20	 movsxd	 rax, DWORD PTR sfd$[rsp]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:psf_files
  00029	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0002d	48 89 04 24	 mov	 QWORD PTR sfdat$[rsp], rax

; 3348 : 	if(sfdat==NULL)

  00031	48 83 3c 24 00	 cmp	 QWORD PTR sfdat$[rsp], 0
  00036	75 07		 jne	 SHORT $LN4@psf_sndGet

; 3349 : 		return PSF_E_BADARG;

  00038	b8 f6 ff ff ff	 mov	 eax, -10
  0003d	eb 0a		 jmp	 SHORT $LN1@psf_sndGet
$LN4@psf_sndGet:

; 3350 : #ifdef _DEBUG		
; 3351 : 	assert(sfdat->file);
; 3352 : 	assert(sfdat->filename);
; 3353 : #endif
; 3354 : 
; 3355 : 	return sfdat->dithertype;

  0003f	48 8b 04 24	 mov	 rax, QWORD PTR sfdat$[rsp]
  00043	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
$LN1@psf_sndGet:

; 3356 : 	
; 3357 : }

  00049	48 83 c4 18	 add	 rsp, 24
  0004d	c3		 ret	 0
psf_sndGetDither ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
sfdat$ = 0
sfd$ = 32
dtype$ = 40
psf_sndSetDither PROC

; 3318 : {

$LN8:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 18	 sub	 rsp, 24

; 3319 : 	PSFFILE *sfdat;;
; 3320 : 
; 3321 : 	if(sfd < 0 || sfd > psf_maxfiles)

  0000c	83 7c 24 20 00	 cmp	 DWORD PTR sfd$[rsp], 0
  00011	7c 07		 jl	 SHORT $LN3@psf_sndSet
  00013	83 7c 24 20 40	 cmp	 DWORD PTR sfd$[rsp], 64	; 00000040H
  00018	7e 07		 jle	 SHORT $LN2@psf_sndSet
$LN3@psf_sndSet:

; 3322 : 		return PSF_E_BADARG;

  0001a	b8 f6 ff ff ff	 mov	 eax, -10
  0001f	eb 51		 jmp	 SHORT $LN1@psf_sndSet
$LN2@psf_sndSet:

; 3323 : 	
; 3324 : 	sfdat  = psf_files[sfd];

  00021	48 63 44 24 20	 movsxd	 rax, DWORD PTR sfd$[rsp]
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:psf_files
  0002d	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00031	48 89 04 24	 mov	 QWORD PTR sfdat$[rsp], rax

; 3325 : 	if(sfdat==NULL)

  00035	48 83 3c 24 00	 cmp	 QWORD PTR sfdat$[rsp], 0
  0003a	75 07		 jne	 SHORT $LN4@psf_sndSet

; 3326 : 		return PSF_E_BADARG;

  0003c	b8 f6 ff ff ff	 mov	 eax, -10
  00041	eb 2f		 jmp	 SHORT $LN1@psf_sndSet
$LN4@psf_sndSet:

; 3327 : #ifdef _DEBUG		
; 3328 : 	assert(sfdat->file);
; 3329 : 	assert(sfdat->filename);
; 3330 : #endif
; 3331 : 	if(dtype < PSF_DITHER_OFF || dtype > PSF_DITHER_TPDF || sfdat->isRead)

  00043	83 7c 24 28 00	 cmp	 DWORD PTR dtype$[rsp], 0
  00048	72 11		 jb	 SHORT $LN6@psf_sndSet
  0004a	83 7c 24 28 01	 cmp	 DWORD PTR dtype$[rsp], 1
  0004f	77 0a		 ja	 SHORT $LN6@psf_sndSet
  00051	48 8b 04 24	 mov	 rax, QWORD PTR sfdat$[rsp]
  00055	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00059	74 07		 je	 SHORT $LN5@psf_sndSet
$LN6@psf_sndSet:

; 3332 : 		return PSF_E_BADARG;

  0005b	b8 f6 ff ff ff	 mov	 eax, -10
  00060	eb 10		 jmp	 SHORT $LN1@psf_sndSet
$LN5@psf_sndSet:

; 3333 : 
; 3334 : 	sfdat->dithertype = dtype;

  00062	48 8b 04 24	 mov	 rax, QWORD PTR sfdat$[rsp]
  00066	8b 4c 24 28	 mov	 ecx, DWORD PTR dtype$[rsp]
  0006a	89 88 9c 00 00
	00		 mov	 DWORD PTR [rax+156], ecx

; 3335 : 
; 3336 : 	return PSF_E_NOERROR;

  00070	33 c0		 xor	 eax, eax
$LN1@psf_sndSet:

; 3337 : 	
; 3338 : }

  00072	48 83 c4 18	 add	 rsp, 24
  00076	c3		 ret	 0
psf_sndSetDither ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
lastdot$ = 32
path$ = 64
psf_getFormatExt PROC

; 3248 : {

$LN18:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3249 : 	char *lastdot;
; 3250 : 	if(path==NULL || (strlen(path) < 4))

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR path$[rsp], 0
  0000f	74 10		 je	 SHORT $LN3@psf_getFor
  00011	48 8b 4c 24 40	 mov	 rcx, QWORD PTR path$[rsp]
  00016	e8 00 00 00 00	 call	 strlen
  0001b	48 83 f8 04	 cmp	 rax, 4
  0001f	73 07		 jae	 SHORT $LN2@psf_getFor
$LN3@psf_getFor:

; 3251 : 		return PSF_FMT_UNKNOWN;				/* TODO: support RAW data... */

  00021	33 c0		 xor	 eax, eax
  00023	e9 eb 00 00 00	 jmp	 $LN1@psf_getFor
$LN2@psf_getFor:

; 3252 : 	lastdot = strrchr(path,'.');

  00028	ba 2e 00 00 00	 mov	 edx, 46			; 0000002eH
  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR path$[rsp]
  00032	e8 00 00 00 00	 call	 strrchr
  00037	48 89 44 24 20	 mov	 QWORD PTR lastdot$[rsp], rax

; 3253 : 	if(lastdot==NULL)

  0003c	48 83 7c 24 20
	00		 cmp	 QWORD PTR lastdot$[rsp], 0
  00042	75 07		 jne	 SHORT $LN4@psf_getFor

; 3254 : 		return PSF_FMT_UNKNOWN;

  00044	33 c0		 xor	 eax, eax
  00046	e9 c8 00 00 00	 jmp	 $LN1@psf_getFor
$LN4@psf_getFor:

; 3255 : 
; 3256 : 	if(stricmp(lastdot,".wav")==0)

  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11460
  00052	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lastdot$[rsp]
  00057	e8 00 00 00 00	 call	 stricmp
  0005c	85 c0		 test	 eax, eax
  0005e	75 0f		 jne	 SHORT $LN5@psf_getFor

; 3257 : 		 return PSF_STDWAVE;

  00060	b8 01 00 00 00	 mov	 eax, 1
  00065	e9 a9 00 00 00	 jmp	 $LN1@psf_getFor
  0006a	e9 a4 00 00 00	 jmp	 $LN6@psf_getFor
$LN5@psf_getFor:

; 3258 : 	else if((stricmp(lastdot,".aif")==0) || stricmp(lastdot,".aiff")==0)

  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11464
  00076	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lastdot$[rsp]
  0007b	e8 00 00 00 00	 call	 stricmp
  00080	85 c0		 test	 eax, eax
  00082	74 15		 je	 SHORT $LN9@psf_getFor
  00084	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11465
  0008b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lastdot$[rsp]
  00090	e8 00 00 00 00	 call	 stricmp
  00095	85 c0		 test	 eax, eax
  00097	75 09		 jne	 SHORT $LN7@psf_getFor
$LN9@psf_getFor:

; 3259 : 		 return PSF_AIFF;

  00099	b8 03 00 00 00	 mov	 eax, 3
  0009e	eb 73		 jmp	 SHORT $LN1@psf_getFor
  000a0	eb 71		 jmp	 SHORT $LN8@psf_getFor
$LN7@psf_getFor:

; 3260 : 	else if((stricmp(lastdot,".afc")==0) || stricmp(lastdot,".aifc")==0)

  000a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11469
  000a9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lastdot$[rsp]
  000ae	e8 00 00 00 00	 call	 stricmp
  000b3	85 c0		 test	 eax, eax
  000b5	74 15		 je	 SHORT $LN12@psf_getFor
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11470
  000be	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lastdot$[rsp]
  000c3	e8 00 00 00 00	 call	 stricmp
  000c8	85 c0		 test	 eax, eax
  000ca	75 09		 jne	 SHORT $LN10@psf_getFor
$LN12@psf_getFor:

; 3261 : 			return PSF_AIFC;

  000cc	b8 04 00 00 00	 mov	 eax, 4
  000d1	eb 40		 jmp	 SHORT $LN1@psf_getFor
  000d3	eb 3e		 jmp	 SHORT $LN11@psf_getFor
$LN10@psf_getFor:

; 3262 :     /* Ambisonic b-format files */
; 3263 :     else if(stricmp(lastdot,".wxyz")==0)

  000d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11473
  000dc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lastdot$[rsp]
  000e1	e8 00 00 00 00	 call	 stricmp
  000e6	85 c0		 test	 eax, eax
  000e8	75 09		 jne	 SHORT $LN13@psf_getFor

; 3264 : 		return PSF_STDWAVE;

  000ea	b8 01 00 00 00	 mov	 eax, 1
  000ef	eb 22		 jmp	 SHORT $LN1@psf_getFor
  000f1	eb 20		 jmp	 SHORT $LN14@psf_getFor
$LN13@psf_getFor:

; 3265 : 	else if(stricmp(lastdot,".amb")==0)

  000f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11476
  000fa	48 8b 4c 24 20	 mov	 rcx, QWORD PTR lastdot$[rsp]
  000ff	e8 00 00 00 00	 call	 stricmp
  00104	85 c0		 test	 eax, eax
  00106	75 09		 jne	 SHORT $LN15@psf_getFor

; 3266 : 		return PSF_WAVE_EX;

  00108	b8 02 00 00 00	 mov	 eax, 2
  0010d	eb 04		 jmp	 SHORT $LN1@psf_getFor
  0010f	eb 02		 jmp	 SHORT $LN16@psf_getFor
$LN15@psf_getFor:

; 3267 : 	else
; 3268 : 		return PSF_FMT_UNKNOWN;

  00111	33 c0		 xor	 eax, eax
$LN16@psf_getFor:
$LN14@psf_getFor:
$LN11@psf_getFor:
$LN8@psf_getFor:
$LN6@psf_getFor:
$LN1@psf_getFor:

; 3269 : 
; 3270 : }

  00113	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00117	c3		 ret	 0
psf_getFormatExt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
i$ = 0
nchans$ = 4
sfdat$ = 8
sfd$ = 32
peakdata$ = 40
peaktime$ = 48
psf_sndReadPeaks PROC

; 3275 : {

$LN12:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 3276 : 	int i,nchans;
; 3277 : 	PSFFILE *sfdat;
; 3278 : 	
; 3279 : 	if(sfd < 0 || sfd > psf_maxfiles)

  00012	83 7c 24 20 00	 cmp	 DWORD PTR sfd$[rsp], 0
  00017	7c 07		 jl	 SHORT $LN6@psf_sndRea
  00019	83 7c 24 20 40	 cmp	 DWORD PTR sfd$[rsp], 64	; 00000040H
  0001e	7e 0a		 jle	 SHORT $LN5@psf_sndRea
$LN6@psf_sndRea:

; 3280 : 		return PSF_E_BADARG;

  00020	b8 f6 ff ff ff	 mov	 eax, -10
  00025	e9 de 00 00 00	 jmp	 $LN1@psf_sndRea
$LN5@psf_sndRea:

; 3281 : 	
; 3282 : 	sfdat  = psf_files[sfd];

  0002a	48 63 44 24 20	 movsxd	 rax, DWORD PTR sfd$[rsp]
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:psf_files
  00036	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0003a	48 89 44 24 08	 mov	 QWORD PTR sfdat$[rsp], rax

; 3283 : 	if(sfdat==NULL)

  0003f	48 83 7c 24 08
	00		 cmp	 QWORD PTR sfdat$[rsp], 0
  00045	75 0a		 jne	 SHORT $LN7@psf_sndRea

; 3284 : 		return PSF_E_BADARG;

  00047	b8 f6 ff ff ff	 mov	 eax, -10
  0004c	e9 b7 00 00 00	 jmp	 $LN1@psf_sndRea
$LN7@psf_sndRea:

; 3285 : #ifdef _DEBUG		
; 3286 : 	assert(sfdat->file);
; 3287 : 	assert(sfdat->filename);
; 3288 : #endif
; 3289 : 	/* TODO: we may want to have this, for RAW files, even though we won't write it */
; 3290 : 	if(sfdat->pPeaks==NULL){		   /*NOT an error: just don't have the chunk*/

  00051	48 8b 44 24 08	 mov	 rax, QWORD PTR sfdat$[rsp]
  00056	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  0005e	75 1a		 jne	 SHORT $LN8@psf_sndRea

; 3291 : 		if(peaktime!= NULL)

  00060	48 83 7c 24 30
	00		 cmp	 QWORD PTR peaktime$[rsp], 0
  00066	74 0b		 je	 SHORT $LN9@psf_sndRea

; 3292 : 			*peaktime = 0;		

  00068	48 8b 44 24 30	 mov	 rax, QWORD PTR peaktime$[rsp]
  0006d	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN9@psf_sndRea:

; 3293 : 		return 0;			

  00073	33 c0		 xor	 eax, eax
  00075	e9 8e 00 00 00	 jmp	 $LN1@psf_sndRea
$LN8@psf_sndRea:

; 3294 : 
; 3295 : 	}
; 3296 : 	if(peaktime != NULL)

  0007a	48 83 7c 24 30
	00		 cmp	 QWORD PTR peaktime$[rsp], 0
  00080	74 12		 je	 SHORT $LN10@psf_sndRea

; 3297 : 		*peaktime = (int) sfdat->peaktime;

  00082	48 8b 44 24 30	 mov	 rax, QWORD PTR peaktime$[rsp]
  00087	48 8b 4c 24 08	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0008c	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  00092	89 08		 mov	 DWORD PTR [rax], ecx
$LN10@psf_sndRea:

; 3298 : 	nchans = sfdat->fmt.Format.nChannels;

  00094	48 8b 44 24 08	 mov	 rax, QWORD PTR sfdat$[rsp]
  00099	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  0009d	89 44 24 04	 mov	 DWORD PTR nchans$[rsp], eax

; 3299 : 	for(i=0;i < nchans;i++){

  000a1	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  000a8	eb 08		 jmp	 SHORT $LN4@psf_sndRea
$LN2@psf_sndRea:
  000aa	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  000ad	ff c0		 inc	 eax
  000af	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@psf_sndRea:
  000b2	8b 44 24 04	 mov	 eax, DWORD PTR nchans$[rsp]
  000b6	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  000b9	7d 48		 jge	 SHORT $LN3@psf_sndRea

; 3300 : 		peakdata[i].val = sfdat->pPeaks[i].val;

  000bb	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000bf	48 8b 4c 24 08	 mov	 rcx, QWORD PTR sfdat$[rsp]
  000c4	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  000cb	48 63 14 24	 movsxd	 rdx, DWORD PTR i$[rsp]
  000cf	4c 8b 44 24 28	 mov	 r8, QWORD PTR peakdata$[rsp]
  000d4	f3 0f 10 04 c1	 movss	 xmm0, DWORD PTR [rcx+rax*8]
  000d9	f3 41 0f 11 04
	d0		 movss	 DWORD PTR [r8+rdx*8], xmm0

; 3301 : 		peakdata[i].pos = sfdat->pPeaks[i].pos;

  000df	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000e3	48 8b 4c 24 08	 mov	 rcx, QWORD PTR sfdat$[rsp]
  000e8	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  000ef	48 63 14 24	 movsxd	 rdx, DWORD PTR i$[rsp]
  000f3	4c 8b 44 24 28	 mov	 r8, QWORD PTR peakdata$[rsp]
  000f8	8b 44 c1 04	 mov	 eax, DWORD PTR [rcx+rax*8+4]
  000fc	41 89 44 d0 04	 mov	 DWORD PTR [r8+rdx*8+4], eax

; 3302 : 	}

  00101	eb a7		 jmp	 SHORT $LN2@psf_sndRea
$LN3@psf_sndRea:

; 3303 : 	return 1;

  00103	b8 01 00 00 00	 mov	 eax, 1
$LN1@psf_sndRea:

; 3304 : }

  00108	48 83 c4 18	 add	 rsp, 24
  0010c	c3		 ret	 0
psf_sndReadPeaks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
i$ = 32
lsamp$ = 36
fsamp$ = 40
pbuf$ = 48
ssamp$ = 56
sfdat$ = 64
blocksize$ = 72
do_reverse$ = 76
framesread$ = 80
tv84 = 84
tv132 = 88
do_shift$ = 92
tv80 = 96
tv87 = 100
tv90 = 104
chans$ = 108
sfd$ = 128
buf$ = 136
nFrames$ = 144
psf_sndReadDoubleFrames PROC

; 2949 : {

$LN74:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2950 : 	int chans;
; 2951 : 	DWORD framesread;
; 2952 : 	int blocksize,lsamp;
; 2953 : 	int i,do_reverse;
; 2954 : 	short ssamp;
; 2955 : 	double *pbuf = buf;

  00012	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0001a	48 89 44 24 30	 mov	 QWORD PTR pbuf$[rsp], rax

; 2956 : 	float fsamp;
; 2957 : 	PSFFILE *sfdat;
; 2958 :     int do_shift;
; 2959 : 
; 2960 : 	if(sfd < 0 || sfd > psf_maxfiles)

  0001f	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR sfd$[rsp], 0
  00027	7c 0a		 jl	 SHORT $LN34@psf_sndRea
  00029	83 bc 24 80 00
	00 00 40	 cmp	 DWORD PTR sfd$[rsp], 64	; 00000040H
  00031	7e 0a		 jle	 SHORT $LN33@psf_sndRea
$LN34@psf_sndRea:

; 2961 : 		return PSF_E_BADARG;

  00033	b8 f6 ff ff ff	 mov	 eax, -10
  00038	e9 58 07 00 00	 jmp	 $LN1@psf_sndRea
$LN33@psf_sndRea:

; 2962 : 	if(buf==NULL)

  0003d	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  00046	75 0a		 jne	 SHORT $LN35@psf_sndRea

; 2963 : 		return PSF_E_BADARG;

  00048	b8 f6 ff ff ff	 mov	 eax, -10
  0004d	e9 43 07 00 00	 jmp	 $LN1@psf_sndRea
$LN35@psf_sndRea:

; 2964 : 	if(nFrames == 0)

  00052	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR nFrames$[rsp], 0
  0005a	75 0c		 jne	 SHORT $LN36@psf_sndRea

; 2965 : 		return nFrames;

  0005c	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  00063	e9 2d 07 00 00	 jmp	 $LN1@psf_sndRea
$LN36@psf_sndRea:

; 2966 : 	sfdat  = psf_files[sfd];

  00068	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR sfd$[rsp]
  00070	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:psf_files
  00077	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0007b	48 89 44 24 40	 mov	 QWORD PTR sfdat$[rsp], rax

; 2967 : #ifdef _DEBUG
; 2968 : 	assert(sfdat);
; 2969 : 	assert(sfdat->file);
; 2970 : 	assert(sfdat->filename);
; 2971 : 	/* must check our calcs! */
; 2972 : 	assert(sfdat->curframepos <= sfdat->nFrames);	 
; 2973 : #endif
; 2974 : 	/* how much do we have left? return immediately if none! */
; 2975 : 	chans = sfdat->fmt.Format.nChannels;

  00080	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  00085	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  00089	89 44 24 6c	 mov	 DWORD PTR chans$[rsp], eax

; 2976 : 	framesread = min(sfdat->nFrames - sfdat->curframepos,nFrames);	

  0008d	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  00092	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00097	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  0009a	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0009d	2b c1		 sub	 eax, ecx
  0009f	3b 84 24 90 00
	00 00		 cmp	 eax, DWORD PTR nFrames$[rsp]
  000a6	73 18		 jae	 SHORT $LN68@psf_sndRea
  000a8	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  000ad	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sfdat$[rsp]
  000b2	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  000b5	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000b8	2b c1		 sub	 eax, ecx
  000ba	89 44 24 60	 mov	 DWORD PTR tv80[rsp], eax
  000be	eb 0b		 jmp	 SHORT $LN69@psf_sndRea
$LN68@psf_sndRea:
  000c0	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  000c7	89 44 24 60	 mov	 DWORD PTR tv80[rsp], eax
$LN69@psf_sndRea:
  000cb	8b 44 24 60	 mov	 eax, DWORD PTR tv80[rsp]
  000cf	89 44 24 50	 mov	 DWORD PTR framesread$[rsp], eax

; 2977 : 	if(framesread==0)

  000d3	83 7c 24 50 00	 cmp	 DWORD PTR framesread$[rsp], 0
  000d8	75 09		 jne	 SHORT $LN37@psf_sndRea

; 2978 : 		return (long) framesread;

  000da	8b 44 24 50	 mov	 eax, DWORD PTR framesread$[rsp]
  000de	e9 b2 06 00 00	 jmp	 $LN1@psf_sndRea
$LN37@psf_sndRea:

; 2979 : 	
; 2980 : 	blocksize =  framesread * chans;

  000e3	8b 44 24 50	 mov	 eax, DWORD PTR framesread$[rsp]
  000e7	0f af 44 24 6c	 imul	 eax, DWORD PTR chans$[rsp]
  000ec	89 44 24 48	 mov	 DWORD PTR blocksize$[rsp], eax

; 2981 : 	switch(sfdat->riff_format){

  000f0	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  000f5	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  000f8	89 44 24 54	 mov	 DWORD PTR tv84[rsp], eax
  000fc	83 7c 24 54 00	 cmp	 DWORD PTR tv84[rsp], 0
  00101	7e 75		 jle	 SHORT $LN40@psf_sndRea
  00103	83 7c 24 54 02	 cmp	 DWORD PTR tv84[rsp], 2
  00108	7e 10		 jle	 SHORT $LN38@psf_sndRea
  0010a	83 7c 24 54 02	 cmp	 DWORD PTR tv84[rsp], 2
  0010f	7e 67		 jle	 SHORT $LN40@psf_sndRea
  00111	83 7c 24 54 04	 cmp	 DWORD PTR tv84[rsp], 4
  00116	7e 31		 jle	 SHORT $LN39@psf_sndRea
  00118	eb 5e		 jmp	 SHORT $LN40@psf_sndRea
$LN38@psf_sndRea:

; 2982 : 	case(PSF_STDWAVE):
; 2983 : 	case(PSF_WAVE_EX):
; 2984 : 		do_reverse = (sfdat->is_little_endian ? 0 : 1 );

  0011a	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  0011f	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00123	74 0a		 je	 SHORT $LN70@psf_sndRea
  00125	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
  0012d	eb 08		 jmp	 SHORT $LN71@psf_sndRea
$LN70@psf_sndRea:
  0012f	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv87[rsp], 1
$LN71@psf_sndRea:
  00137	8b 44 24 64	 mov	 eax, DWORD PTR tv87[rsp]
  0013b	89 44 24 4c	 mov	 DWORD PTR do_reverse$[rsp], eax

; 2985 :         do_shift = 1;

  0013f	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR do_shift$[rsp], 1

; 2986 : 		break;

  00147	eb 39		 jmp	 SHORT $LN2@psf_sndRea
$LN39@psf_sndRea:

; 2987 : 	case(PSF_AIFF):
; 2988 : 	case(PSF_AIFC):
; 2989 : 		do_reverse = (sfdat->is_little_endian ? 1 : 0 );

  00149	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  0014e	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00152	74 0a		 je	 SHORT $LN72@psf_sndRea
  00154	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv90[rsp], 1
  0015c	eb 08		 jmp	 SHORT $LN73@psf_sndRea
$LN72@psf_sndRea:
  0015e	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN73@psf_sndRea:
  00166	8b 44 24 68	 mov	 eax, DWORD PTR tv90[rsp]
  0016a	89 44 24 4c	 mov	 DWORD PTR do_reverse$[rsp], eax

; 2990 :         do_shift = 0;

  0016e	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR do_shift$[rsp], 0

; 2991 : 		break;

  00176	eb 0a		 jmp	 SHORT $LN2@psf_sndRea
$LN40@psf_sndRea:

; 2992 : 	default:
; 2993 : 		return PSF_E_UNSUPPORTED;

  00178	b8 f8 ff ff ff	 mov	 eax, -8
  0017d	e9 13 06 00 00	 jmp	 $LN1@psf_sndRea
$LN2@psf_sndRea:

; 2994 : 	}
; 2995 : 	if(sfdat->lastop == PSF_OP_WRITE)

  00182	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  00187	83 b8 98 00 00
	00 01		 cmp	 DWORD PTR [rax+152], 1
  0018e	75 0d		 jne	 SHORT $LN41@psf_sndRea

; 2996 : 		fflush(sfdat->file);

  00190	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  00195	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00198	e8 00 00 00 00	 call	 fflush
$LN41@psf_sndRea:

; 2997 : 	switch(sfdat->samptype){

  0019d	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  001a2	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  001a5	89 44 24 58	 mov	 DWORD PTR tv132[rsp], eax
  001a9	83 7c 24 58 02	 cmp	 DWORD PTR tv132[rsp], 2
  001ae	0f 84 d1 01 00
	00		 je	 $LN49@psf_sndRea
  001b4	83 7c 24 58 03	 cmp	 DWORD PTR tv132[rsp], 3
  001b9	0f 84 f7 02 00
	00		 je	 $LN54@psf_sndRea
  001bf	83 7c 24 58 04	 cmp	 DWORD PTR tv132[rsp], 4
  001c4	0f 84 64 04 00
	00		 je	 $LN61@psf_sndRea
  001ca	83 7c 24 58 05	 cmp	 DWORD PTR tv132[rsp], 5
  001cf	74 05		 je	 SHORT $LN42@psf_sndRea
  001d1	e9 a0 05 00 00	 jmp	 $LN66@psf_sndRea
$LN42@psf_sndRea:

; 2998 : 	case(PSF_SAMP_IEEE_FLOAT):
; 2999 : 		
; 3000 : 		if(do_reverse){

  001d6	83 7c 24 4c 00	 cmp	 DWORD PTR do_reverse$[rsp], 0
  001db	0f 84 d6 00 00
	00		 je	 $LN43@psf_sndRea

; 3001 : 		    for(i=0;i < blocksize;i ++){

  001e1	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001e9	eb 0a		 jmp	 SHORT $LN8@psf_sndRea
$LN6@psf_sndRea:
  001eb	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001ef	ff c0		 inc	 eax
  001f1	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN8@psf_sndRea:
  001f5	8b 44 24 48	 mov	 eax, DWORD PTR blocksize$[rsp]
  001f9	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  001fd	0f 8d af 00 00
	00		 jge	 $LN7@psf_sndRea

; 3002 : 			if(wavDoRead(sfdat,(char *)&lsamp,sizeof(int)))

  00203	41 b8 04 00 00
	00		 mov	 r8d, 4
  00209	48 8d 54 24 24	 lea	 rdx, QWORD PTR lsamp$[rsp]
  0020e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00213	e8 00 00 00 00	 call	 wavDoRead
  00218	85 c0		 test	 eax, eax
  0021a	74 0a		 je	 SHORT $LN45@psf_sndRea

; 3003 : 			    return PSF_E_CANT_READ;

  0021c	b8 fc ff ff ff	 mov	 eax, -4
  00221	e9 6f 05 00 00	 jmp	 $LN1@psf_sndRea
$LN45@psf_sndRea:

; 3004 : 			lsamp = REVDWBYTES(lsamp);

  00226	8b 44 24 24	 mov	 eax, DWORD PTR lsamp$[rsp]
  0022a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0022f	c1 e0 18	 shl	 eax, 24
  00232	8b 4c 24 24	 mov	 ecx, DWORD PTR lsamp$[rsp]
  00236	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  0023c	c1 e1 08	 shl	 ecx, 8
  0023f	0b c1		 or	 eax, ecx
  00241	8b 4c 24 24	 mov	 ecx, DWORD PTR lsamp$[rsp]
  00245	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  0024b	c1 f9 08	 sar	 ecx, 8
  0024e	0b c1		 or	 eax, ecx
  00250	8b 4c 24 24	 mov	 ecx, DWORD PTR lsamp$[rsp]
  00254	c1 f9 18	 sar	 ecx, 24
  00257	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0025d	0b c1		 or	 eax, ecx
  0025f	89 44 24 24	 mov	 DWORD PTR lsamp$[rsp], eax

; 3005 : 			fsamp = * (float *)&lsamp;

  00263	f3 0f 10 44 24
	24		 movss	 xmm0, DWORD PTR lsamp$[rsp]
  00269	f3 0f 11 44 24
	28		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 3006 : 			if(sfdat->rescale)

  0026f	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  00274	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  00278	74 16		 je	 SHORT $LN46@psf_sndRea

; 3007 : 			    fsamp *= sfdat->rescale_fac;

  0027a	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  0027f	f3 0f 10 44 24
	28		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00285	f3 0f 59 40 24	 mulss	 xmm0, DWORD PTR [rax+36]
  0028a	f3 0f 11 44 24
	28		 movss	 DWORD PTR fsamp$[rsp], xmm0
$LN46@psf_sndRea:

; 3008 : 			*pbuf++ = (double) fsamp;

  00290	f3 0f 5a 44 24
	28		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  00296	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  0029b	f2 0f 11 00	 movsd	 QWORD PTR [rax], xmm0
  0029f	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  002a4	48 83 c0 08	 add	 rax, 8
  002a8	48 89 44 24 30	 mov	 QWORD PTR pbuf$[rsp], rax

; 3009 : 		    }			

  002ad	e9 39 ff ff ff	 jmp	 $LN6@psf_sndRea
$LN7@psf_sndRea:

; 3010 : 		}

  002b2	e9 c9 00 00 00	 jmp	 $LN44@psf_sndRea
$LN43@psf_sndRea:

; 3011 : 		else{
; 3012 :                     for(i=0;i < blocksize;i++){	

  002b7	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002bf	eb 0a		 jmp	 SHORT $LN11@psf_sndRea
$LN9@psf_sndRea:
  002c1	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  002c5	ff c0		 inc	 eax
  002c7	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN11@psf_sndRea:
  002cb	8b 44 24 48	 mov	 eax, DWORD PTR blocksize$[rsp]
  002cf	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  002d3	7d 42		 jge	 SHORT $LN10@psf_sndRea

; 3013 :                         if(wavDoRead(sfdat,(char *) &fsamp, sizeof(float)))

  002d5	41 b8 04 00 00
	00		 mov	 r8d, 4
  002db	48 8d 54 24 28	 lea	 rdx, QWORD PTR fsamp$[rsp]
  002e0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sfdat$[rsp]
  002e5	e8 00 00 00 00	 call	 wavDoRead
  002ea	85 c0		 test	 eax, eax
  002ec	74 0a		 je	 SHORT $LN47@psf_sndRea

; 3014 : 				return PSF_E_CANT_READ;

  002ee	b8 fc ff ff ff	 mov	 eax, -4
  002f3	e9 9d 04 00 00	 jmp	 $LN1@psf_sndRea
$LN47@psf_sndRea:

; 3015 : 		        *pbuf++ = (double) fsamp;

  002f8	f3 0f 5a 44 24
	28		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  002fe	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  00303	f2 0f 11 00	 movsd	 QWORD PTR [rax], xmm0
  00307	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  0030c	48 83 c0 08	 add	 rax, 8
  00310	48 89 44 24 30	 mov	 QWORD PTR pbuf$[rsp], rax

; 3016 : 		    }					  

  00315	eb aa		 jmp	 SHORT $LN9@psf_sndRea
$LN10@psf_sndRea:

; 3017 : 		    if(sfdat->rescale){

  00317	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  0031c	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  00320	74 5e		 je	 SHORT $LN48@psf_sndRea

; 3018 : 			pbuf = buf;

  00322	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0032a	48 89 44 24 30	 mov	 QWORD PTR pbuf$[rsp], rax

; 3019 : 			for(i=0;i < blocksize; i++)

  0032f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00337	eb 0a		 jmp	 SHORT $LN14@psf_sndRea
$LN12@psf_sndRea:
  00339	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0033d	ff c0		 inc	 eax
  0033f	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN14@psf_sndRea:
  00343	8b 44 24 48	 mov	 eax, DWORD PTR blocksize$[rsp]
  00347	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0034b	7d 33		 jge	 SHORT $LN13@psf_sndRea

; 3020 : 			    *pbuf++  *= sfdat->rescale_fac;

  0034d	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  00352	f3 0f 5a 40 24	 cvtss2sd xmm0, DWORD PTR [rax+36]
  00357	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  0035c	f2 0f 10 08	 movsd	 xmm1, QWORD PTR [rax]
  00360	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00364	0f 28 c1	 movaps	 xmm0, xmm1
  00367	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  0036c	f2 0f 11 00	 movsd	 QWORD PTR [rax], xmm0
  00370	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  00375	48 83 c0 08	 add	 rax, 8
  00379	48 89 44 24 30	 mov	 QWORD PTR pbuf$[rsp], rax
  0037e	eb b9		 jmp	 SHORT $LN12@psf_sndRea
$LN13@psf_sndRea:
$LN48@psf_sndRea:
$LN44@psf_sndRea:

; 3021 : 		    }
; 3022 : 		}
; 3023 : 		break;

  00380	e9 f8 03 00 00	 jmp	 $LN4@psf_sndRea
$LN49@psf_sndRea:

; 3024 : 	case(PSF_SAMP_16):
; 3025 : 		if(do_reverse){

  00385	83 7c 24 4c 00	 cmp	 DWORD PTR do_reverse$[rsp], 0
  0038a	0f 84 a6 00 00
	00		 je	 $LN50@psf_sndRea

; 3026 : 			for(i = 0; i < blocksize; i++){

  00390	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00398	eb 0a		 jmp	 SHORT $LN17@psf_sndRea
$LN15@psf_sndRea:
  0039a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0039e	ff c0		 inc	 eax
  003a0	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN17@psf_sndRea:
  003a4	8b 44 24 48	 mov	 eax, DWORD PTR blocksize$[rsp]
  003a8	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  003ac	0f 8d 82 00 00
	00		 jge	 $LN16@psf_sndRea

; 3027 : 				if(wavDoRead(sfdat,(char *)&ssamp,sizeof(short)))

  003b2	41 b8 02 00 00
	00		 mov	 r8d, 2
  003b8	48 8d 54 24 38	 lea	 rdx, QWORD PTR ssamp$[rsp]
  003bd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sfdat$[rsp]
  003c2	e8 00 00 00 00	 call	 wavDoRead
  003c7	85 c0		 test	 eax, eax
  003c9	74 0a		 je	 SHORT $LN52@psf_sndRea

; 3028 : 					return PSF_E_CANT_READ;

  003cb	b8 fc ff ff ff	 mov	 eax, -4
  003d0	e9 c0 03 00 00	 jmp	 $LN1@psf_sndRea
$LN52@psf_sndRea:

; 3029 : 				ssamp = (short) REVWBYTES(ssamp);

  003d5	0f bf 44 24 38	 movsx	 eax, WORD PTR ssamp$[rsp]
  003da	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003df	c1 e0 08	 shl	 eax, 8
  003e2	0f bf 4c 24 38	 movsx	 ecx, WORD PTR ssamp$[rsp]
  003e7	c1 f9 08	 sar	 ecx, 8
  003ea	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  003f0	0b c1		 or	 eax, ecx
  003f2	66 89 44 24 38	 mov	 WORD PTR ssamp$[rsp], ax

; 3030 : 				fsamp = (float)((double) ssamp / MAX_16BIT);

  003f7	0f bf 44 24 38	 movsx	 eax, WORD PTR ssamp$[rsp]
  003fc	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  00400	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@40e0000000000000
  00408	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0040c	f3 0f 11 44 24
	28		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 3031 : 				*pbuf++ = (double) fsamp;

  00412	f3 0f 5a 44 24
	28		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  00418	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  0041d	f2 0f 11 00	 movsd	 QWORD PTR [rax], xmm0
  00421	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  00426	48 83 c0 08	 add	 rax, 8
  0042a	48 89 44 24 30	 mov	 QWORD PTR pbuf$[rsp], rax

; 3032 : 			}

  0042f	e9 66 ff ff ff	 jmp	 $LN15@psf_sndRea
$LN16@psf_sndRea:

; 3033 : 		}

  00434	eb 7b		 jmp	 SHORT $LN51@psf_sndRea
$LN50@psf_sndRea:

; 3034 : 		else{
; 3035 : 			for(i = 0; i < blocksize; i++){

  00436	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0043e	eb 0a		 jmp	 SHORT $LN20@psf_sndRea
$LN18@psf_sndRea:
  00440	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00444	ff c0		 inc	 eax
  00446	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN20@psf_sndRea:
  0044a	8b 44 24 48	 mov	 eax, DWORD PTR blocksize$[rsp]
  0044e	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00452	7d 5d		 jge	 SHORT $LN19@psf_sndRea

; 3036 : 				if(wavDoRead(sfdat,(char *)&ssamp,sizeof(short)))

  00454	41 b8 02 00 00
	00		 mov	 r8d, 2
  0045a	48 8d 54 24 38	 lea	 rdx, QWORD PTR ssamp$[rsp]
  0045f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00464	e8 00 00 00 00	 call	 wavDoRead
  00469	85 c0		 test	 eax, eax
  0046b	74 0a		 je	 SHORT $LN53@psf_sndRea

; 3037 : 					return PSF_E_CANT_READ;				

  0046d	b8 fc ff ff ff	 mov	 eax, -4
  00472	e9 1e 03 00 00	 jmp	 $LN1@psf_sndRea
$LN53@psf_sndRea:

; 3038 : 				fsamp = (float)((double) ssamp / MAX_16BIT);

  00477	0f bf 44 24 38	 movsx	 eax, WORD PTR ssamp$[rsp]
  0047c	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  00480	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@40e0000000000000
  00488	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0048c	f3 0f 11 44 24
	28		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 3039 : 				*pbuf++ = (double) fsamp;

  00492	f3 0f 5a 44 24
	28		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  00498	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  0049d	f2 0f 11 00	 movsd	 QWORD PTR [rax], xmm0
  004a1	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  004a6	48 83 c0 08	 add	 rax, 8
  004aa	48 89 44 24 30	 mov	 QWORD PTR pbuf$[rsp], rax

; 3040 : 			}

  004af	eb 8f		 jmp	 SHORT $LN18@psf_sndRea
$LN19@psf_sndRea:
$LN51@psf_sndRea:

; 3041 : 		}
; 3042 : 		break;

  004b1	e9 c7 02 00 00	 jmp	 $LN4@psf_sndRea
$LN54@psf_sndRea:

; 3043 : 	case(PSF_SAMP_24):
; 3044 : 		if(do_reverse){

  004b6	83 7c 24 4c 00	 cmp	 DWORD PTR do_reverse$[rsp], 0
  004bb	0f 84 d3 00 00
	00		 je	 $LN55@psf_sndRea

; 3045 : 			for(i=0;i < blocksize;i++){

  004c1	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  004c9	eb 0a		 jmp	 SHORT $LN23@psf_sndRea
$LN21@psf_sndRea:
  004cb	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  004cf	ff c0		 inc	 eax
  004d1	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN23@psf_sndRea:
  004d5	8b 44 24 48	 mov	 eax, DWORD PTR blocksize$[rsp]
  004d9	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  004dd	0f 8d ac 00 00
	00		 jge	 $LN22@psf_sndRea

; 3046 : 				if(wavDoRead(sfdat,(char *)&lsamp,3))

  004e3	41 b8 03 00 00
	00		 mov	 r8d, 3
  004e9	48 8d 54 24 24	 lea	 rdx, QWORD PTR lsamp$[rsp]
  004ee	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sfdat$[rsp]
  004f3	e8 00 00 00 00	 call	 wavDoRead
  004f8	85 c0		 test	 eax, eax
  004fa	74 0a		 je	 SHORT $LN57@psf_sndRea

; 3047 : 					return PSF_E_CANT_READ;

  004fc	b8 fc ff ff ff	 mov	 eax, -4
  00501	e9 8f 02 00 00	 jmp	 $LN1@psf_sndRea
$LN57@psf_sndRea:

; 3048 : 				lsamp = REVDWBYTES(lsamp);

  00506	8b 44 24 24	 mov	 eax, DWORD PTR lsamp$[rsp]
  0050a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0050f	c1 e0 18	 shl	 eax, 24
  00512	8b 4c 24 24	 mov	 ecx, DWORD PTR lsamp$[rsp]
  00516	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  0051c	c1 e1 08	 shl	 ecx, 8
  0051f	0b c1		 or	 eax, ecx
  00521	8b 4c 24 24	 mov	 ecx, DWORD PTR lsamp$[rsp]
  00525	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  0052b	c1 f9 08	 sar	 ecx, 8
  0052e	0b c1		 or	 eax, ecx
  00530	8b 4c 24 24	 mov	 ecx, DWORD PTR lsamp$[rsp]
  00534	c1 f9 18	 sar	 ecx, 24
  00537	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0053d	0b c1		 or	 eax, ecx
  0053f	89 44 24 24	 mov	 DWORD PTR lsamp$[rsp], eax

; 3049 :                 if(do_shift)

  00543	83 7c 24 5c 00	 cmp	 DWORD PTR do_shift$[rsp], 0
  00548	74 0b		 je	 SHORT $LN58@psf_sndRea

; 3050 : 				    lsamp <<= 8;

  0054a	8b 44 24 24	 mov	 eax, DWORD PTR lsamp$[rsp]
  0054e	c1 e0 08	 shl	 eax, 8
  00551	89 44 24 24	 mov	 DWORD PTR lsamp$[rsp], eax
$LN58@psf_sndRea:

; 3051 : 				fsamp = (float)((double)(lsamp) / MAX_32BIT);

  00555	f2 0f 2a 44 24
	24		 cvtsi2sd xmm0, DWORD PTR lsamp$[rsp]
  0055b	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@41e0000000000000
  00563	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00567	f3 0f 11 44 24
	28		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 3052 : 				*pbuf++ = (double) fsamp;

  0056d	f3 0f 5a 44 24
	28		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  00573	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  00578	f2 0f 11 00	 movsd	 QWORD PTR [rax], xmm0
  0057c	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  00581	48 83 c0 08	 add	 rax, 8
  00585	48 89 44 24 30	 mov	 QWORD PTR pbuf$[rsp], rax

; 3053 : 			}

  0058a	e9 3c ff ff ff	 jmp	 $LN21@psf_sndRea
$LN22@psf_sndRea:

; 3054 : 		}

  0058f	e9 95 00 00 00	 jmp	 $LN56@psf_sndRea
$LN55@psf_sndRea:

; 3055 : 		else{
; 3056 : 			for(i=0;i < blocksize;i++){

  00594	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0059c	eb 0a		 jmp	 SHORT $LN26@psf_sndRea
$LN24@psf_sndRea:
  0059e	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  005a2	ff c0		 inc	 eax
  005a4	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN26@psf_sndRea:
  005a8	8b 44 24 48	 mov	 eax, DWORD PTR blocksize$[rsp]
  005ac	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  005b0	7d 77		 jge	 SHORT $LN25@psf_sndRea

; 3057 : 				lsamp = 0L;

  005b2	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR lsamp$[rsp], 0

; 3058 : 				if(wavDoRead(sfdat,(char *)&lsamp,3))

  005ba	41 b8 03 00 00
	00		 mov	 r8d, 3
  005c0	48 8d 54 24 24	 lea	 rdx, QWORD PTR lsamp$[rsp]
  005c5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sfdat$[rsp]
  005ca	e8 00 00 00 00	 call	 wavDoRead
  005cf	85 c0		 test	 eax, eax
  005d1	74 0a		 je	 SHORT $LN59@psf_sndRea

; 3059 : 					return PSF_E_CANT_READ;

  005d3	b8 fc ff ff ff	 mov	 eax, -4
  005d8	e9 b8 01 00 00	 jmp	 $LN1@psf_sndRea
$LN59@psf_sndRea:

; 3060 :                 if(do_shift)

  005dd	83 7c 24 5c 00	 cmp	 DWORD PTR do_shift$[rsp], 0
  005e2	74 0b		 je	 SHORT $LN60@psf_sndRea

; 3061 : 				    lsamp <<= 8;

  005e4	8b 44 24 24	 mov	 eax, DWORD PTR lsamp$[rsp]
  005e8	c1 e0 08	 shl	 eax, 8
  005eb	89 44 24 24	 mov	 DWORD PTR lsamp$[rsp], eax
$LN60@psf_sndRea:

; 3062 : 				fsamp = (float)((double)(lsamp) / MAX_32BIT);

  005ef	f2 0f 2a 44 24
	24		 cvtsi2sd xmm0, DWORD PTR lsamp$[rsp]
  005f5	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@41e0000000000000
  005fd	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00601	f3 0f 11 44 24
	28		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 3063 : 				*pbuf++ = (double) fsamp;

  00607	f3 0f 5a 44 24
	28		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  0060d	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  00612	f2 0f 11 00	 movsd	 QWORD PTR [rax], xmm0
  00616	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  0061b	48 83 c0 08	 add	 rax, 8
  0061f	48 89 44 24 30	 mov	 QWORD PTR pbuf$[rsp], rax

; 3064 : 			}

  00624	e9 75 ff ff ff	 jmp	 $LN24@psf_sndRea
$LN25@psf_sndRea:
$LN56@psf_sndRea:

; 3065 : 		}
; 3066 : 		break;

  00629	e9 4f 01 00 00	 jmp	 $LN4@psf_sndRea
$LN61@psf_sndRea:

; 3067 : 	case(PSF_SAMP_32):
; 3068 : 		if(do_reverse){

  0062e	83 7c 24 4c 00	 cmp	 DWORD PTR do_reverse$[rsp], 0
  00633	0f 84 be 00 00
	00		 je	 $LN62@psf_sndRea

; 3069 : 			for(i=0;i < blocksize;i++){

  00639	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00641	eb 0a		 jmp	 SHORT $LN29@psf_sndRea
$LN27@psf_sndRea:
  00643	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00647	ff c0		 inc	 eax
  00649	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN29@psf_sndRea:
  0064d	8b 44 24 48	 mov	 eax, DWORD PTR blocksize$[rsp]
  00651	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00655	0f 8d 9a 00 00
	00		 jge	 $LN28@psf_sndRea

; 3070 : 				if(wavDoRead(sfdat,(char *)&lsamp,sizeof(int)))

  0065b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00661	48 8d 54 24 24	 lea	 rdx, QWORD PTR lsamp$[rsp]
  00666	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0066b	e8 00 00 00 00	 call	 wavDoRead
  00670	85 c0		 test	 eax, eax
  00672	74 0a		 je	 SHORT $LN64@psf_sndRea

; 3071 : 					return PSF_E_CANT_READ;

  00674	b8 fc ff ff ff	 mov	 eax, -4
  00679	e9 17 01 00 00	 jmp	 $LN1@psf_sndRea
$LN64@psf_sndRea:

; 3072 : 				lsamp = REVDWBYTES(lsamp);				

  0067e	8b 44 24 24	 mov	 eax, DWORD PTR lsamp$[rsp]
  00682	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00687	c1 e0 18	 shl	 eax, 24
  0068a	8b 4c 24 24	 mov	 ecx, DWORD PTR lsamp$[rsp]
  0068e	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00694	c1 e1 08	 shl	 ecx, 8
  00697	0b c1		 or	 eax, ecx
  00699	8b 4c 24 24	 mov	 ecx, DWORD PTR lsamp$[rsp]
  0069d	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  006a3	c1 f9 08	 sar	 ecx, 8
  006a6	0b c1		 or	 eax, ecx
  006a8	8b 4c 24 24	 mov	 ecx, DWORD PTR lsamp$[rsp]
  006ac	c1 f9 18	 sar	 ecx, 24
  006af	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  006b5	0b c1		 or	 eax, ecx
  006b7	89 44 24 24	 mov	 DWORD PTR lsamp$[rsp], eax

; 3073 : 				fsamp = (float)((double)(lsamp) / MAX_32BIT);

  006bb	f2 0f 2a 44 24
	24		 cvtsi2sd xmm0, DWORD PTR lsamp$[rsp]
  006c1	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@41e0000000000000
  006c9	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  006cd	f3 0f 11 44 24
	28		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 3074 : 				*pbuf++ = (double) fsamp;

  006d3	f3 0f 5a 44 24
	28		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  006d9	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  006de	f2 0f 11 00	 movsd	 QWORD PTR [rax], xmm0
  006e2	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  006e7	48 83 c0 08	 add	 rax, 8
  006eb	48 89 44 24 30	 mov	 QWORD PTR pbuf$[rsp], rax

; 3075 : 			}

  006f0	e9 4e ff ff ff	 jmp	 $LN27@psf_sndRea
$LN28@psf_sndRea:

; 3076 : 		}

  006f5	eb 7d		 jmp	 SHORT $LN63@psf_sndRea
$LN62@psf_sndRea:

; 3077 : 		else{
; 3078 : 			for(i=0;i < blocksize;i++){

  006f7	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  006ff	eb 0a		 jmp	 SHORT $LN32@psf_sndRea
$LN30@psf_sndRea:
  00701	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00705	ff c0		 inc	 eax
  00707	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN32@psf_sndRea:
  0070b	8b 44 24 48	 mov	 eax, DWORD PTR blocksize$[rsp]
  0070f	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00713	7d 5f		 jge	 SHORT $LN31@psf_sndRea

; 3079 : 				lsamp = 0L;

  00715	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR lsamp$[rsp], 0

; 3080 : 				if(wavDoRead(sfdat,(char *)&lsamp,sizeof(int)))

  0071d	41 b8 04 00 00
	00		 mov	 r8d, 4
  00723	48 8d 54 24 24	 lea	 rdx, QWORD PTR lsamp$[rsp]
  00728	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0072d	e8 00 00 00 00	 call	 wavDoRead
  00732	85 c0		 test	 eax, eax
  00734	74 07		 je	 SHORT $LN65@psf_sndRea

; 3081 : 					return PSF_E_CANT_READ;				

  00736	b8 fc ff ff ff	 mov	 eax, -4
  0073b	eb 58		 jmp	 SHORT $LN1@psf_sndRea
$LN65@psf_sndRea:

; 3082 : 				fsamp = (float)((double)(lsamp) / MAX_32BIT);

  0073d	f2 0f 2a 44 24
	24		 cvtsi2sd xmm0, DWORD PTR lsamp$[rsp]
  00743	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@41e0000000000000
  0074b	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0074f	f3 0f 11 44 24
	28		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 3083 : 				*pbuf++ = (double) fsamp;

  00755	f3 0f 5a 44 24
	28		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  0075b	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  00760	f2 0f 11 00	 movsd	 QWORD PTR [rax], xmm0
  00764	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  00769	48 83 c0 08	 add	 rax, 8
  0076d	48 89 44 24 30	 mov	 QWORD PTR pbuf$[rsp], rax

; 3084 : 			}

  00772	eb 8d		 jmp	 SHORT $LN30@psf_sndRea
$LN31@psf_sndRea:
$LN63@psf_sndRea:

; 3085 : 		}
; 3086 : 		break;

  00774	eb 07		 jmp	 SHORT $LN4@psf_sndRea
$LN66@psf_sndRea:

; 3087 : 	default:
; 3088 : 		DBGFPRINTF((stderr, "psf_sndOpen: unsupported sample format\n"));
; 3089 : 		return PSF_E_UNSUPPORTED;

  00776	b8 f8 ff ff ff	 mov	 eax, -8
  0077b	eb 18		 jmp	 SHORT $LN1@psf_sndRea
$LN4@psf_sndRea:

; 3090 : 	}	
; 3091 : 	sfdat->curframepos += framesread;

  0077d	48 8b 44 24 40	 mov	 rax, QWORD PTR sfdat$[rsp]
  00782	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00785	03 44 24 50	 add	 eax, DWORD PTR framesread$[rsp]
  00789	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0078e	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 3092 : 
; 3093 : 	return framesread;

  00791	8b 44 24 50	 mov	 eax, DWORD PTR framesread$[rsp]
$LN1@psf_sndRea:

; 3094 : }

  00795	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00799	c3		 ret	 0
psf_sndReadDoubleFrames ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
i$ = 32
lsamp$ = 36
fsamp$ = 40
ssamp$ = 44
pbuf$ = 48
sfdat$ = 56
blocksize$ = 64
temp$ = 68
do_reverse$ = 72
framesread$ = 76
tv84 = 80
tv132 = 84
do_shift$ = 88
tv80 = 92
tv87 = 96
tv90 = 100
chans$ = 104
sfd$ = 128
buf$ = 136
nFrames$ = 144
psf_sndReadFloatFrames PROC

; 2791 : {

$LN71:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2792 : 	int chans;
; 2793 : 	DWORD framesread;
; 2794 : 	int blocksize,lsamp;
; 2795 :     int temp;
; 2796 : 	int i,do_reverse;
; 2797 : 	short ssamp;
; 2798 : 	float *pbuf = buf;

  00012	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0001a	48 89 44 24 30	 mov	 QWORD PTR pbuf$[rsp], rax

; 2799 : 	float fsamp;
; 2800 : 	PSFFILE *sfdat;
; 2801 :     int do_shift;
; 2802 : #ifdef _DEBUG
; 2803 : 	static int debug = 1;
; 2804 : #endif
; 2805 : 	if(sfd < 0 || sfd > psf_maxfiles)

  0001f	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR sfd$[rsp], 0
  00027	7c 0a		 jl	 SHORT $LN31@psf_sndRea
  00029	83 bc 24 80 00
	00 00 40	 cmp	 DWORD PTR sfd$[rsp], 64	; 00000040H
  00031	7e 0a		 jle	 SHORT $LN30@psf_sndRea
$LN31@psf_sndRea:

; 2806 : 		return PSF_E_BADARG;

  00033	b8 f6 ff ff ff	 mov	 eax, -10
  00038	e9 25 07 00 00	 jmp	 $LN1@psf_sndRea
$LN30@psf_sndRea:

; 2807 : 	if(buf==NULL)

  0003d	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  00046	75 0a		 jne	 SHORT $LN32@psf_sndRea

; 2808 : 		return PSF_E_BADARG;

  00048	b8 f6 ff ff ff	 mov	 eax, -10
  0004d	e9 10 07 00 00	 jmp	 $LN1@psf_sndRea
$LN32@psf_sndRea:

; 2809 : 	if(nFrames == 0)

  00052	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR nFrames$[rsp], 0
  0005a	75 0c		 jne	 SHORT $LN33@psf_sndRea

; 2810 : 		return nFrames;

  0005c	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  00063	e9 fa 06 00 00	 jmp	 $LN1@psf_sndRea
$LN33@psf_sndRea:

; 2811 : 	sfdat  = psf_files[sfd];

  00068	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR sfd$[rsp]
  00070	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:psf_files
  00077	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0007b	48 89 44 24 38	 mov	 QWORD PTR sfdat$[rsp], rax

; 2812 : #ifdef _DEBUG
; 2813 : 	assert(sfdat);
; 2814 : 	assert(sfdat->file);
; 2815 : 	assert(sfdat->filename);
; 2816 : 	/* must check our calcs! */
; 2817 : 	assert(sfdat->curframepos <= sfdat->nFrames);	 
; 2818 : #endif
; 2819 : 	/* how much do we have left? return immediately if none! */
; 2820 : 	chans = sfdat->fmt.Format.nChannels;

  00080	48 8b 44 24 38	 mov	 rax, QWORD PTR sfdat$[rsp]
  00085	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  00089	89 44 24 68	 mov	 DWORD PTR chans$[rsp], eax

; 2821 : 	framesread = min(sfdat->nFrames - sfdat->curframepos,nFrames);	

  0008d	48 8b 44 24 38	 mov	 rax, QWORD PTR sfdat$[rsp]
  00092	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00097	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  0009a	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0009d	2b c1		 sub	 eax, ecx
  0009f	3b 84 24 90 00
	00 00		 cmp	 eax, DWORD PTR nFrames$[rsp]
  000a6	73 18		 jae	 SHORT $LN65@psf_sndRea
  000a8	48 8b 44 24 38	 mov	 rax, QWORD PTR sfdat$[rsp]
  000ad	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sfdat$[rsp]
  000b2	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  000b5	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000b8	2b c1		 sub	 eax, ecx
  000ba	89 44 24 5c	 mov	 DWORD PTR tv80[rsp], eax
  000be	eb 0b		 jmp	 SHORT $LN66@psf_sndRea
$LN65@psf_sndRea:
  000c0	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  000c7	89 44 24 5c	 mov	 DWORD PTR tv80[rsp], eax
$LN66@psf_sndRea:
  000cb	8b 44 24 5c	 mov	 eax, DWORD PTR tv80[rsp]
  000cf	89 44 24 4c	 mov	 DWORD PTR framesread$[rsp], eax

; 2822 : 	if(framesread==0)

  000d3	83 7c 24 4c 00	 cmp	 DWORD PTR framesread$[rsp], 0
  000d8	75 09		 jne	 SHORT $LN34@psf_sndRea

; 2823 : 		return (long) framesread;

  000da	8b 44 24 4c	 mov	 eax, DWORD PTR framesread$[rsp]
  000de	e9 7f 06 00 00	 jmp	 $LN1@psf_sndRea
$LN34@psf_sndRea:

; 2824 : 	
; 2825 : 	blocksize =  framesread * chans;

  000e3	8b 44 24 4c	 mov	 eax, DWORD PTR framesread$[rsp]
  000e7	0f af 44 24 68	 imul	 eax, DWORD PTR chans$[rsp]
  000ec	89 44 24 40	 mov	 DWORD PTR blocksize$[rsp], eax

; 2826 : 	switch(sfdat->riff_format){

  000f0	48 8b 44 24 38	 mov	 rax, QWORD PTR sfdat$[rsp]
  000f5	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  000f8	89 44 24 50	 mov	 DWORD PTR tv84[rsp], eax
  000fc	83 7c 24 50 00	 cmp	 DWORD PTR tv84[rsp], 0
  00101	7e 75		 jle	 SHORT $LN37@psf_sndRea
  00103	83 7c 24 50 02	 cmp	 DWORD PTR tv84[rsp], 2
  00108	7e 10		 jle	 SHORT $LN35@psf_sndRea
  0010a	83 7c 24 50 02	 cmp	 DWORD PTR tv84[rsp], 2
  0010f	7e 67		 jle	 SHORT $LN37@psf_sndRea
  00111	83 7c 24 50 04	 cmp	 DWORD PTR tv84[rsp], 4
  00116	7e 31		 jle	 SHORT $LN36@psf_sndRea
  00118	eb 5e		 jmp	 SHORT $LN37@psf_sndRea
$LN35@psf_sndRea:

; 2827 : 	case(PSF_STDWAVE):
; 2828 : 	case(PSF_WAVE_EX):
; 2829 : 		do_reverse = (sfdat->is_little_endian ? 0 : 1 );

  0011a	48 8b 44 24 38	 mov	 rax, QWORD PTR sfdat$[rsp]
  0011f	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00123	74 0a		 je	 SHORT $LN67@psf_sndRea
  00125	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
  0012d	eb 08		 jmp	 SHORT $LN68@psf_sndRea
$LN67@psf_sndRea:
  0012f	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv87[rsp], 1
$LN68@psf_sndRea:
  00137	8b 44 24 60	 mov	 eax, DWORD PTR tv87[rsp]
  0013b	89 44 24 48	 mov	 DWORD PTR do_reverse$[rsp], eax

; 2830 :         do_shift = 1;

  0013f	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR do_shift$[rsp], 1

; 2831 : 		break;

  00147	eb 39		 jmp	 SHORT $LN2@psf_sndRea
$LN36@psf_sndRea:

; 2832 : 	case(PSF_AIFF):
; 2833 : 	case(PSF_AIFC):
; 2834 : 		do_reverse = (sfdat->is_little_endian ? 1 : 0 );

  00149	48 8b 44 24 38	 mov	 rax, QWORD PTR sfdat$[rsp]
  0014e	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00152	74 0a		 je	 SHORT $LN69@psf_sndRea
  00154	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv90[rsp], 1
  0015c	eb 08		 jmp	 SHORT $LN70@psf_sndRea
$LN69@psf_sndRea:
  0015e	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN70@psf_sndRea:
  00166	8b 44 24 64	 mov	 eax, DWORD PTR tv90[rsp]
  0016a	89 44 24 48	 mov	 DWORD PTR do_reverse$[rsp], eax

; 2835 :         do_shift = 0;

  0016e	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR do_shift$[rsp], 0

; 2836 : 		break;

  00176	eb 0a		 jmp	 SHORT $LN2@psf_sndRea
$LN37@psf_sndRea:

; 2837 : 	default:
; 2838 : 		return PSF_E_UNSUPPORTED;

  00178	b8 f8 ff ff ff	 mov	 eax, -8
  0017d	e9 e0 05 00 00	 jmp	 $LN1@psf_sndRea
$LN2@psf_sndRea:

; 2839 : 	}
; 2840 : 	if(sfdat->lastop == PSF_OP_WRITE)

  00182	48 8b 44 24 38	 mov	 rax, QWORD PTR sfdat$[rsp]
  00187	83 b8 98 00 00
	00 01		 cmp	 DWORD PTR [rax+152], 1
  0018e	75 0d		 jne	 SHORT $LN38@psf_sndRea

; 2841 : 		fflush(sfdat->file);

  00190	48 8b 44 24 38	 mov	 rax, QWORD PTR sfdat$[rsp]
  00195	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00198	e8 00 00 00 00	 call	 fflush
$LN38@psf_sndRea:

; 2842 : 	switch(sfdat->samptype){

  0019d	48 8b 44 24 38	 mov	 rax, QWORD PTR sfdat$[rsp]
  001a2	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  001a5	89 44 24 54	 mov	 DWORD PTR tv132[rsp], eax
  001a9	83 7c 24 54 02	 cmp	 DWORD PTR tv132[rsp], 2
  001ae	0f 84 96 01 00
	00		 je	 $LN46@psf_sndRea
  001b4	83 7c 24 54 03	 cmp	 DWORD PTR tv132[rsp], 3
  001b9	0f 84 bc 02 00
	00		 je	 $LN51@psf_sndRea
  001bf	83 7c 24 54 04	 cmp	 DWORD PTR tv132[rsp], 4
  001c4	0f 84 31 04 00
	00		 je	 $LN58@psf_sndRea
  001ca	83 7c 24 54 05	 cmp	 DWORD PTR tv132[rsp], 5
  001cf	74 05		 je	 SHORT $LN39@psf_sndRea
  001d1	e9 6d 05 00 00	 jmp	 $LN63@psf_sndRea
$LN39@psf_sndRea:

; 2843 : 	case(PSF_SAMP_IEEE_FLOAT):
; 2844 : 		
; 2845 : 		if(do_reverse){

  001d6	83 7c 24 48 00	 cmp	 DWORD PTR do_reverse$[rsp], 0
  001db	0f 84 d6 00 00
	00		 je	 $LN40@psf_sndRea

; 2846 : 			for(i=0;i < blocksize;i ++){

  001e1	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001e9	eb 0a		 jmp	 SHORT $LN8@psf_sndRea
$LN6@psf_sndRea:
  001eb	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001ef	ff c0		 inc	 eax
  001f1	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN8@psf_sndRea:
  001f5	8b 44 24 40	 mov	 eax, DWORD PTR blocksize$[rsp]
  001f9	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  001fd	0f 8d af 00 00
	00		 jge	 $LN7@psf_sndRea

; 2847 : 				if(wavDoRead(sfdat,(char *)&lsamp,sizeof(int)))

  00203	41 b8 04 00 00
	00		 mov	 r8d, 4
  00209	48 8d 54 24 24	 lea	 rdx, QWORD PTR lsamp$[rsp]
  0020e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00213	e8 00 00 00 00	 call	 wavDoRead
  00218	85 c0		 test	 eax, eax
  0021a	74 0a		 je	 SHORT $LN42@psf_sndRea

; 2848 : 					return PSF_E_CANT_READ;

  0021c	b8 fc ff ff ff	 mov	 eax, -4
  00221	e9 3c 05 00 00	 jmp	 $LN1@psf_sndRea
$LN42@psf_sndRea:

; 2849 : 				lsamp = REVDWBYTES(lsamp);

  00226	8b 44 24 24	 mov	 eax, DWORD PTR lsamp$[rsp]
  0022a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0022f	c1 e0 18	 shl	 eax, 24
  00232	8b 4c 24 24	 mov	 ecx, DWORD PTR lsamp$[rsp]
  00236	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  0023c	c1 e1 08	 shl	 ecx, 8
  0023f	0b c1		 or	 eax, ecx
  00241	8b 4c 24 24	 mov	 ecx, DWORD PTR lsamp$[rsp]
  00245	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  0024b	c1 f9 08	 sar	 ecx, 8
  0024e	0b c1		 or	 eax, ecx
  00250	8b 4c 24 24	 mov	 ecx, DWORD PTR lsamp$[rsp]
  00254	c1 f9 18	 sar	 ecx, 24
  00257	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0025d	0b c1		 or	 eax, ecx
  0025f	89 44 24 24	 mov	 DWORD PTR lsamp$[rsp], eax

; 2850 : 				fsamp = * (float *)&lsamp;

  00263	f3 0f 10 44 24
	24		 movss	 xmm0, DWORD PTR lsamp$[rsp]
  00269	f3 0f 11 44 24
	28		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 2851 : 				if(sfdat->rescale)

  0026f	48 8b 44 24 38	 mov	 rax, QWORD PTR sfdat$[rsp]
  00274	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  00278	74 16		 je	 SHORT $LN43@psf_sndRea

; 2852 : 					fsamp *= sfdat->rescale_fac;

  0027a	48 8b 44 24 38	 mov	 rax, QWORD PTR sfdat$[rsp]
  0027f	f3 0f 10 44 24
	28		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00285	f3 0f 59 40 24	 mulss	 xmm0, DWORD PTR [rax+36]
  0028a	f3 0f 11 44 24
	28		 movss	 DWORD PTR fsamp$[rsp], xmm0
$LN43@psf_sndRea:

; 2853 : 				*pbuf++ = fsamp;

  00290	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  00295	f3 0f 10 44 24
	28		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  0029b	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0
  0029f	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  002a4	48 83 c0 04	 add	 rax, 4
  002a8	48 89 44 24 30	 mov	 QWORD PTR pbuf$[rsp], rax

; 2854 : 			}			

  002ad	e9 39 ff ff ff	 jmp	 $LN6@psf_sndRea
$LN7@psf_sndRea:

; 2855 : 		}

  002b2	e9 8e 00 00 00	 jmp	 $LN41@psf_sndRea
$LN40@psf_sndRea:

; 2856 : 		else{
; 2857 : 			if(wavDoRead(sfdat,(char *) buf,blocksize * sizeof(float)))

  002b7	48 63 44 24 40	 movsxd	 rax, DWORD PTR blocksize$[rsp]
  002bc	48 c1 e0 02	 shl	 rax, 2
  002c0	44 8b c0	 mov	 r8d, eax
  002c3	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  002cb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sfdat$[rsp]
  002d0	e8 00 00 00 00	 call	 wavDoRead
  002d5	85 c0		 test	 eax, eax
  002d7	74 0a		 je	 SHORT $LN44@psf_sndRea

; 2858 : 				return PSF_E_CANT_READ;

  002d9	b8 fc ff ff ff	 mov	 eax, -4
  002de	e9 7f 04 00 00	 jmp	 $LN1@psf_sndRea
$LN44@psf_sndRea:

; 2859 : 			if(sfdat->rescale){

  002e3	48 8b 44 24 38	 mov	 rax, QWORD PTR sfdat$[rsp]
  002e8	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  002ec	74 57		 je	 SHORT $LN45@psf_sndRea

; 2860 : 				pbuf = buf;

  002ee	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  002f6	48 89 44 24 30	 mov	 QWORD PTR pbuf$[rsp], rax

; 2861 : 				for(i=0;i < blocksize; i++)

  002fb	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00303	eb 0a		 jmp	 SHORT $LN11@psf_sndRea
$LN9@psf_sndRea:
  00305	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00309	ff c0		 inc	 eax
  0030b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN11@psf_sndRea:
  0030f	8b 44 24 40	 mov	 eax, DWORD PTR blocksize$[rsp]
  00313	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00317	7d 2c		 jge	 SHORT $LN10@psf_sndRea

; 2862 : 					*pbuf++  *= sfdat->rescale_fac;

  00319	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  0031e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00323	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00327	f3 0f 59 41 24	 mulss	 xmm0, DWORD PTR [rcx+36]
  0032c	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  00331	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0
  00335	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  0033a	48 83 c0 04	 add	 rax, 4
  0033e	48 89 44 24 30	 mov	 QWORD PTR pbuf$[rsp], rax
  00343	eb c0		 jmp	 SHORT $LN9@psf_sndRea
$LN10@psf_sndRea:
$LN45@psf_sndRea:
$LN41@psf_sndRea:

; 2863 : 			}
; 2864 : 		}
; 2865 : 		break;

  00345	e9 00 04 00 00	 jmp	 $LN4@psf_sndRea
$LN46@psf_sndRea:

; 2866 : 	case(PSF_SAMP_16):
; 2867 : 		if(do_reverse){

  0034a	83 7c 24 48 00	 cmp	 DWORD PTR do_reverse$[rsp], 0
  0034f	0f 84 a6 00 00
	00		 je	 $LN47@psf_sndRea

; 2868 : 			for(i = 0; i < blocksize; i++){

  00355	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0035d	eb 0a		 jmp	 SHORT $LN14@psf_sndRea
$LN12@psf_sndRea:
  0035f	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00363	ff c0		 inc	 eax
  00365	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN14@psf_sndRea:
  00369	8b 44 24 40	 mov	 eax, DWORD PTR blocksize$[rsp]
  0036d	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00371	0f 8d 82 00 00
	00		 jge	 $LN13@psf_sndRea

; 2869 : 				if(wavDoRead(sfdat,(char *)&ssamp,sizeof(short)))

  00377	41 b8 02 00 00
	00		 mov	 r8d, 2
  0037d	48 8d 54 24 2c	 lea	 rdx, QWORD PTR ssamp$[rsp]
  00382	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00387	e8 00 00 00 00	 call	 wavDoRead
  0038c	85 c0		 test	 eax, eax
  0038e	74 0a		 je	 SHORT $LN49@psf_sndRea

; 2870 : 					return PSF_E_CANT_READ;

  00390	b8 fc ff ff ff	 mov	 eax, -4
  00395	e9 c8 03 00 00	 jmp	 $LN1@psf_sndRea
$LN49@psf_sndRea:

; 2871 : 				ssamp = (short) REVWBYTES(ssamp);

  0039a	0f bf 44 24 2c	 movsx	 eax, WORD PTR ssamp$[rsp]
  0039f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003a4	c1 e0 08	 shl	 eax, 8
  003a7	0f bf 4c 24 2c	 movsx	 ecx, WORD PTR ssamp$[rsp]
  003ac	c1 f9 08	 sar	 ecx, 8
  003af	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  003b5	0b c1		 or	 eax, ecx
  003b7	66 89 44 24 2c	 mov	 WORD PTR ssamp$[rsp], ax

; 2872 : 				fsamp = (float)((double) ssamp / MAX_16BIT);

  003bc	0f bf 44 24 2c	 movsx	 eax, WORD PTR ssamp$[rsp]
  003c1	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  003c5	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@40e0000000000000
  003cd	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  003d1	f3 0f 11 44 24
	28		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 2873 : 				*pbuf++ = fsamp;

  003d7	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  003dc	f3 0f 10 44 24
	28		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  003e2	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0
  003e6	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  003eb	48 83 c0 04	 add	 rax, 4
  003ef	48 89 44 24 30	 mov	 QWORD PTR pbuf$[rsp], rax

; 2874 : 			}

  003f4	e9 66 ff ff ff	 jmp	 $LN12@psf_sndRea
$LN13@psf_sndRea:

; 2875 : 		}

  003f9	eb 7b		 jmp	 SHORT $LN48@psf_sndRea
$LN47@psf_sndRea:

; 2876 : 		else{
; 2877 : 			for(i = 0; i < blocksize; i++){

  003fb	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00403	eb 0a		 jmp	 SHORT $LN17@psf_sndRea
$LN15@psf_sndRea:
  00405	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00409	ff c0		 inc	 eax
  0040b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN17@psf_sndRea:
  0040f	8b 44 24 40	 mov	 eax, DWORD PTR blocksize$[rsp]
  00413	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00417	7d 5d		 jge	 SHORT $LN16@psf_sndRea

; 2878 : 				if(wavDoRead(sfdat,(char *)&ssamp,sizeof(short)))

  00419	41 b8 02 00 00
	00		 mov	 r8d, 2
  0041f	48 8d 54 24 2c	 lea	 rdx, QWORD PTR ssamp$[rsp]
  00424	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00429	e8 00 00 00 00	 call	 wavDoRead
  0042e	85 c0		 test	 eax, eax
  00430	74 0a		 je	 SHORT $LN50@psf_sndRea

; 2879 : 					return PSF_E_CANT_READ;				

  00432	b8 fc ff ff ff	 mov	 eax, -4
  00437	e9 26 03 00 00	 jmp	 $LN1@psf_sndRea
$LN50@psf_sndRea:

; 2880 : 				fsamp = (float)((double) ssamp / MAX_16BIT);

  0043c	0f bf 44 24 2c	 movsx	 eax, WORD PTR ssamp$[rsp]
  00441	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  00445	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@40e0000000000000
  0044d	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00451	f3 0f 11 44 24
	28		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 2881 : 				*pbuf++ = fsamp;

  00457	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  0045c	f3 0f 10 44 24
	28		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00462	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0
  00466	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  0046b	48 83 c0 04	 add	 rax, 4
  0046f	48 89 44 24 30	 mov	 QWORD PTR pbuf$[rsp], rax

; 2882 : 			}

  00474	eb 8f		 jmp	 SHORT $LN15@psf_sndRea
$LN16@psf_sndRea:
$LN48@psf_sndRea:

; 2883 : 		}
; 2884 : 		break;

  00476	e9 cf 02 00 00	 jmp	 $LN4@psf_sndRea
$LN51@psf_sndRea:

; 2885 : 	case(PSF_SAMP_24):
; 2886 : 		if(do_reverse){

  0047b	83 7c 24 48 00	 cmp	 DWORD PTR do_reverse$[rsp], 0
  00480	0f 84 db 00 00
	00		 je	 $LN52@psf_sndRea

; 2887 : #ifdef _DEBUG
; 2888 : 			if(debug){
; 2889 : 				printf("do_reverse: riffformat=%d do_shift = %d little_endian = %d\n",
; 2890 : 					   sfdat->riff_format,do_shift,sfdat->is_little_endian);
; 2891 : 				debug = 0;
; 2892 : 			}
; 2893 : #endif            
; 2894 : 			for(i=0;i < blocksize;i++){

  00486	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0048e	eb 0a		 jmp	 SHORT $LN20@psf_sndRea
$LN18@psf_sndRea:
  00490	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00494	ff c0		 inc	 eax
  00496	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN20@psf_sndRea:
  0049a	8b 44 24 40	 mov	 eax, DWORD PTR blocksize$[rsp]
  0049e	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  004a2	0f 8d b4 00 00
	00		 jge	 $LN19@psf_sndRea

; 2895 :                 temp = 0;

  004a8	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR temp$[rsp], 0

; 2896 : 				if(wavDoRead(sfdat,(char *)&temp,3))

  004b0	41 b8 03 00 00
	00		 mov	 r8d, 3
  004b6	48 8d 54 24 44	 lea	 rdx, QWORD PTR temp$[rsp]
  004bb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sfdat$[rsp]
  004c0	e8 00 00 00 00	 call	 wavDoRead
  004c5	85 c0		 test	 eax, eax
  004c7	74 0a		 je	 SHORT $LN54@psf_sndRea

; 2897 : 					return PSF_E_CANT_READ;

  004c9	b8 fc ff ff ff	 mov	 eax, -4
  004ce	e9 8f 02 00 00	 jmp	 $LN1@psf_sndRea
$LN54@psf_sndRea:

; 2898 : 				lsamp = REVDWBYTES(temp);

  004d3	8b 44 24 44	 mov	 eax, DWORD PTR temp$[rsp]
  004d7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004dc	c1 e0 18	 shl	 eax, 24
  004df	8b 4c 24 44	 mov	 ecx, DWORD PTR temp$[rsp]
  004e3	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  004e9	c1 e1 08	 shl	 ecx, 8
  004ec	0b c1		 or	 eax, ecx
  004ee	8b 4c 24 44	 mov	 ecx, DWORD PTR temp$[rsp]
  004f2	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  004f8	c1 f9 08	 sar	 ecx, 8
  004fb	0b c1		 or	 eax, ecx
  004fd	8b 4c 24 44	 mov	 ecx, DWORD PTR temp$[rsp]
  00501	c1 f9 18	 sar	 ecx, 24
  00504	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0050a	0b c1		 or	 eax, ecx
  0050c	89 44 24 24	 mov	 DWORD PTR lsamp$[rsp], eax

; 2899 : 				if(do_shift)

  00510	83 7c 24 58 00	 cmp	 DWORD PTR do_shift$[rsp], 0
  00515	74 0b		 je	 SHORT $LN55@psf_sndRea

; 2900 : 					lsamp <<= 8;

  00517	8b 44 24 24	 mov	 eax, DWORD PTR lsamp$[rsp]
  0051b	c1 e0 08	 shl	 eax, 8
  0051e	89 44 24 24	 mov	 DWORD PTR lsamp$[rsp], eax
$LN55@psf_sndRea:

; 2901 : 				fsamp = (float)((double)(lsamp) / MAX_32BIT);

  00522	f2 0f 2a 44 24
	24		 cvtsi2sd xmm0, DWORD PTR lsamp$[rsp]
  00528	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@41e0000000000000
  00530	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00534	f3 0f 11 44 24
	28		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 2902 : 				*pbuf++ = fsamp;

  0053a	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  0053f	f3 0f 10 44 24
	28		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00545	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0
  00549	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  0054e	48 83 c0 04	 add	 rax, 4
  00552	48 89 44 24 30	 mov	 QWORD PTR pbuf$[rsp], rax

; 2903 : 			}

  00557	e9 34 ff ff ff	 jmp	 $LN18@psf_sndRea
$LN19@psf_sndRea:

; 2904 : 		}

  0055c	e9 95 00 00 00	 jmp	 $LN53@psf_sndRea
$LN52@psf_sndRea:

; 2905 : 		else{
; 2906 : 			for(i=0;i < blocksize;i++){

  00561	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00569	eb 0a		 jmp	 SHORT $LN23@psf_sndRea
$LN21@psf_sndRea:
  0056b	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0056f	ff c0		 inc	 eax
  00571	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN23@psf_sndRea:
  00575	8b 44 24 40	 mov	 eax, DWORD PTR blocksize$[rsp]
  00579	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0057d	7d 77		 jge	 SHORT $LN22@psf_sndRea

; 2907 : 				lsamp = 0;

  0057f	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR lsamp$[rsp], 0

; 2908 : 				if(wavDoRead(sfdat,(char *)&lsamp,3))

  00587	41 b8 03 00 00
	00		 mov	 r8d, 3
  0058d	48 8d 54 24 24	 lea	 rdx, QWORD PTR lsamp$[rsp]
  00592	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00597	e8 00 00 00 00	 call	 wavDoRead
  0059c	85 c0		 test	 eax, eax
  0059e	74 0a		 je	 SHORT $LN56@psf_sndRea

; 2909 : 					return PSF_E_CANT_READ;

  005a0	b8 fc ff ff ff	 mov	 eax, -4
  005a5	e9 b8 01 00 00	 jmp	 $LN1@psf_sndRea
$LN56@psf_sndRea:

; 2910 : 				if(do_shift)

  005aa	83 7c 24 58 00	 cmp	 DWORD PTR do_shift$[rsp], 0
  005af	74 0b		 je	 SHORT $LN57@psf_sndRea

; 2911 : 					lsamp <<= 8;

  005b1	8b 44 24 24	 mov	 eax, DWORD PTR lsamp$[rsp]
  005b5	c1 e0 08	 shl	 eax, 8
  005b8	89 44 24 24	 mov	 DWORD PTR lsamp$[rsp], eax
$LN57@psf_sndRea:

; 2912 : 				fsamp = (float)((double)(lsamp) / MAX_32BIT);

  005bc	f2 0f 2a 44 24
	24		 cvtsi2sd xmm0, DWORD PTR lsamp$[rsp]
  005c2	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@41e0000000000000
  005ca	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  005ce	f3 0f 11 44 24
	28		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 2913 : 				*pbuf++ = fsamp;

  005d4	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  005d9	f3 0f 10 44 24
	28		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  005df	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0
  005e3	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  005e8	48 83 c0 04	 add	 rax, 4
  005ec	48 89 44 24 30	 mov	 QWORD PTR pbuf$[rsp], rax

; 2914 : 			}

  005f1	e9 75 ff ff ff	 jmp	 $LN21@psf_sndRea
$LN22@psf_sndRea:
$LN53@psf_sndRea:

; 2915 : 		}
; 2916 : 		break;

  005f6	e9 4f 01 00 00	 jmp	 $LN4@psf_sndRea
$LN58@psf_sndRea:

; 2917 : 	case(PSF_SAMP_32):
; 2918 : 		if(do_reverse){

  005fb	83 7c 24 48 00	 cmp	 DWORD PTR do_reverse$[rsp], 0
  00600	0f 84 be 00 00
	00		 je	 $LN59@psf_sndRea

; 2919 : 			for(i=0;i < blocksize;i++){

  00606	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0060e	eb 0a		 jmp	 SHORT $LN26@psf_sndRea
$LN24@psf_sndRea:
  00610	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00614	ff c0		 inc	 eax
  00616	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN26@psf_sndRea:
  0061a	8b 44 24 40	 mov	 eax, DWORD PTR blocksize$[rsp]
  0061e	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00622	0f 8d 9a 00 00
	00		 jge	 $LN25@psf_sndRea

; 2920 : 				if(wavDoRead(sfdat,(char *)&lsamp,sizeof(int)))

  00628	41 b8 04 00 00
	00		 mov	 r8d, 4
  0062e	48 8d 54 24 24	 lea	 rdx, QWORD PTR lsamp$[rsp]
  00633	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00638	e8 00 00 00 00	 call	 wavDoRead
  0063d	85 c0		 test	 eax, eax
  0063f	74 0a		 je	 SHORT $LN61@psf_sndRea

; 2921 : 					return PSF_E_CANT_READ;

  00641	b8 fc ff ff ff	 mov	 eax, -4
  00646	e9 17 01 00 00	 jmp	 $LN1@psf_sndRea
$LN61@psf_sndRea:

; 2922 : 				lsamp = REVDWBYTES(lsamp);				

  0064b	8b 44 24 24	 mov	 eax, DWORD PTR lsamp$[rsp]
  0064f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00654	c1 e0 18	 shl	 eax, 24
  00657	8b 4c 24 24	 mov	 ecx, DWORD PTR lsamp$[rsp]
  0065b	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00661	c1 e1 08	 shl	 ecx, 8
  00664	0b c1		 or	 eax, ecx
  00666	8b 4c 24 24	 mov	 ecx, DWORD PTR lsamp$[rsp]
  0066a	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00670	c1 f9 08	 sar	 ecx, 8
  00673	0b c1		 or	 eax, ecx
  00675	8b 4c 24 24	 mov	 ecx, DWORD PTR lsamp$[rsp]
  00679	c1 f9 18	 sar	 ecx, 24
  0067c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00682	0b c1		 or	 eax, ecx
  00684	89 44 24 24	 mov	 DWORD PTR lsamp$[rsp], eax

; 2923 : 				fsamp = (float)((double)(lsamp) / MAX_32BIT);

  00688	f2 0f 2a 44 24
	24		 cvtsi2sd xmm0, DWORD PTR lsamp$[rsp]
  0068e	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@41e0000000000000
  00696	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0069a	f3 0f 11 44 24
	28		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 2924 : 				*pbuf++ = fsamp;

  006a0	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  006a5	f3 0f 10 44 24
	28		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  006ab	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0
  006af	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  006b4	48 83 c0 04	 add	 rax, 4
  006b8	48 89 44 24 30	 mov	 QWORD PTR pbuf$[rsp], rax

; 2925 : 			}

  006bd	e9 4e ff ff ff	 jmp	 $LN24@psf_sndRea
$LN25@psf_sndRea:

; 2926 : 		}

  006c2	eb 7d		 jmp	 SHORT $LN60@psf_sndRea
$LN59@psf_sndRea:

; 2927 : 		else{
; 2928 : 			for(i=0;i < blocksize;i++){

  006c4	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  006cc	eb 0a		 jmp	 SHORT $LN29@psf_sndRea
$LN27@psf_sndRea:
  006ce	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  006d2	ff c0		 inc	 eax
  006d4	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN29@psf_sndRea:
  006d8	8b 44 24 40	 mov	 eax, DWORD PTR blocksize$[rsp]
  006dc	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  006e0	7d 5f		 jge	 SHORT $LN28@psf_sndRea

; 2929 : 				lsamp = 0L;

  006e2	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR lsamp$[rsp], 0

; 2930 : 				if(wavDoRead(sfdat,(char *)&lsamp,sizeof(int)))

  006ea	41 b8 04 00 00
	00		 mov	 r8d, 4
  006f0	48 8d 54 24 24	 lea	 rdx, QWORD PTR lsamp$[rsp]
  006f5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sfdat$[rsp]
  006fa	e8 00 00 00 00	 call	 wavDoRead
  006ff	85 c0		 test	 eax, eax
  00701	74 07		 je	 SHORT $LN62@psf_sndRea

; 2931 : 					return PSF_E_CANT_READ;				

  00703	b8 fc ff ff ff	 mov	 eax, -4
  00708	eb 58		 jmp	 SHORT $LN1@psf_sndRea
$LN62@psf_sndRea:

; 2932 : 				fsamp = (float)((double)(lsamp) / MAX_32BIT);

  0070a	f2 0f 2a 44 24
	24		 cvtsi2sd xmm0, DWORD PTR lsamp$[rsp]
  00710	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@41e0000000000000
  00718	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0071c	f3 0f 11 44 24
	28		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 2933 : 				*pbuf++ = fsamp;

  00722	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  00727	f3 0f 10 44 24
	28		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  0072d	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0
  00731	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  00736	48 83 c0 04	 add	 rax, 4
  0073a	48 89 44 24 30	 mov	 QWORD PTR pbuf$[rsp], rax

; 2934 : 			}

  0073f	eb 8d		 jmp	 SHORT $LN27@psf_sndRea
$LN28@psf_sndRea:
$LN60@psf_sndRea:

; 2935 : 		}
; 2936 : 		break;

  00741	eb 07		 jmp	 SHORT $LN4@psf_sndRea
$LN63@psf_sndRea:

; 2937 : 	default:
; 2938 : 		DBGFPRINTF((stderr, "psf_sndOpen: unsupported sample format\n"));
; 2939 : 		return PSF_E_UNSUPPORTED;

  00743	b8 f8 ff ff ff	 mov	 eax, -8
  00748	eb 18		 jmp	 SHORT $LN1@psf_sndRea
$LN4@psf_sndRea:

; 2940 : 	}	
; 2941 : 	sfdat->curframepos += framesread;

  0074a	48 8b 44 24 38	 mov	 rax, QWORD PTR sfdat$[rsp]
  0074f	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00752	03 44 24 4c	 add	 eax, DWORD PTR framesread$[rsp]
  00756	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0075b	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 2942 : 
; 2943 : 	return framesread;

  0075e	8b 44 24 4c	 mov	 eax, DWORD PTR framesread$[rsp]
$LN1@psf_sndRea:

; 2944 : }

  00762	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00766	c3		 ret	 0
psf_sndReadFloatFrames ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
tv82 = 32
byteoffset$ = 36
sfdat$ = 40
pos_target$ = 48
cur_pos$ = 56
data_end$ = 64
sfd$ = 96
offset$ = 104
mode$ = 112
psf_sndSeek PROC

; 3188 : {

$LN19:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3189 : 	long byteoffset;    /* can be negative - limited to 2GB moves*/
; 3190 :     fpos_t data_end,pos_target,cur_pos;
; 3191 : 	PSFFILE *sfdat;
; 3192 : 	
; 3193 : 
; 3194 : 	if(sfd < 0 || sfd > psf_maxfiles)

  00011	83 7c 24 60 00	 cmp	 DWORD PTR sfd$[rsp], 0
  00016	7c 07		 jl	 SHORT $LN5@psf_sndSee
  00018	83 7c 24 60 40	 cmp	 DWORD PTR sfd$[rsp], 64	; 00000040H
  0001d	7e 0a		 jle	 SHORT $LN4@psf_sndSee
$LN5@psf_sndSee:

; 3195 : 		return PSF_E_BADARG;

  0001f	b8 f6 ff ff ff	 mov	 eax, -10
  00024	e9 ac 01 00 00	 jmp	 $LN1@psf_sndSee
$LN4@psf_sndSee:

; 3196 : 	
; 3197 : 	sfdat  = psf_files[sfd];

  00029	48 63 44 24 60	 movsxd	 rax, DWORD PTR sfd$[rsp]
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:psf_files
  00035	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00039	48 89 44 24 28	 mov	 QWORD PTR sfdat$[rsp], rax

; 3198 : 	if(sfdat==NULL)

  0003e	48 83 7c 24 28
	00		 cmp	 QWORD PTR sfdat$[rsp], 0
  00044	75 0a		 jne	 SHORT $LN6@psf_sndSee

; 3199 : 		return PSF_E_BADARG;

  00046	b8 f6 ff ff ff	 mov	 eax, -10
  0004b	e9 85 01 00 00	 jmp	 $LN1@psf_sndSee
$LN6@psf_sndSee:

; 3200 : #ifdef _DEBUG		
; 3201 : 	assert(sfdat->file);
; 3202 : 	assert(sfdat->filename);
; 3203 : #endif
; 3204 : 	/* RWD NB:dataoffset test only valid for files with headers! */
; 3205 : 	if(POS64(sfdat->dataoffset)==0)

  00050	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  00055	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  0005a	75 0a		 jne	 SHORT $LN7@psf_sndSee

; 3206 : 		return PSF_E_BADARG;

  0005c	b8 f6 ff ff ff	 mov	 eax, -10
  00061	e9 6f 01 00 00	 jmp	 $LN1@psf_sndSee
$LN7@psf_sndSee:

; 3207 : 	/* or, it indicates a RAW file.... */
; 3208 : 
; 3209 : 	byteoffset =  offset *  sfdat->fmt.Format.nBlockAlign;

  00066	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  0006b	0f b7 40 5c	 movzx	 eax, WORD PTR [rax+92]
  0006f	8b 4c 24 68	 mov	 ecx, DWORD PTR offset$[rsp]
  00073	0f af c8	 imul	 ecx, eax
  00076	8b c1		 mov	 eax, ecx
  00078	89 44 24 24	 mov	 DWORD PTR byteoffset$[rsp], eax

; 3210 :     POS64(data_end) = POS64(sfdat->dataoffset) + (sfdat->nFrames * sfdat->fmt.Format.nBlockAlign);

  0007c	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  00081	0f b7 40 5c	 movzx	 eax, WORD PTR [rax+92]
  00085	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0008a	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  0008d	0f af c8	 imul	 ecx, eax
  00090	8b c1		 mov	 eax, ecx
  00092	8b c0		 mov	 eax, eax
  00094	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00099	48 03 41 38	 add	 rax, QWORD PTR [rcx+56]
  0009d	48 89 44 24 40	 mov	 QWORD PTR data_end$[rsp], rax

; 3211 : 	switch(mode){

  000a2	8b 44 24 70	 mov	 eax, DWORD PTR mode$[rsp]
  000a6	89 44 24 20	 mov	 DWORD PTR tv82[rsp], eax
  000aa	83 7c 24 20 00	 cmp	 DWORD PTR tv82[rsp], 0
  000af	74 13		 je	 SHORT $LN8@psf_sndSee
  000b1	83 7c 24 20 01	 cmp	 DWORD PTR tv82[rsp], 1
  000b6	74 78		 je	 SHORT $LN12@psf_sndSee
  000b8	83 7c 24 20 02	 cmp	 DWORD PTR tv82[rsp], 2
  000bd	74 3a		 je	 SHORT $LN10@psf_sndSee
  000bf	e9 91 00 00 00	 jmp	 $LN2@psf_sndSee
$LN8@psf_sndSee:

; 3212 : 	case PSF_SEEK_SET:  
; 3213 : 	    POS64(pos_target) =  POS64(sfdat->dataoffset) + byteoffset;

  000c4	48 63 44 24 24	 movsxd	 rax, DWORD PTR byteoffset$[rsp]
  000c9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sfdat$[rsp]
  000ce	48 03 41 38	 add	 rax, QWORD PTR [rcx+56]
  000d2	48 89 44 24 30	 mov	 QWORD PTR pos_target$[rsp], rax

; 3214 : 	    if(fsetpos(sfdat->file,&pos_target))

  000d7	48 8d 54 24 30	 lea	 rdx, QWORD PTR pos_target$[rsp]
  000dc	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  000e1	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000e4	e8 00 00 00 00	 call	 fsetpos
  000e9	85 c0		 test	 eax, eax
  000eb	74 0a		 je	 SHORT $LN9@psf_sndSee

; 3215 : 		    return PSF_E_CANT_SEEK;

  000ed	b8 f5 ff ff ff	 mov	 eax, -11
  000f2	e9 de 00 00 00	 jmp	 $LN1@psf_sndSee
$LN9@psf_sndSee:

; 3216 : 	    break;

  000f7	eb 5c		 jmp	 SHORT $LN2@psf_sndSee
$LN10@psf_sndSee:

; 3217 : 	case PSF_SEEK_END:	    
; 3218 :         /* NB can't just seek to end of file as there may be junk after data chunk! */
; 3219 :         POS64(pos_target) = POS64(data_end) + byteoffset;

  000f9	48 63 44 24 24	 movsxd	 rax, DWORD PTR byteoffset$[rsp]
  000fe	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data_end$[rsp]
  00103	48 03 c8	 add	 rcx, rax
  00106	48 8b c1	 mov	 rax, rcx
  00109	48 89 44 24 30	 mov	 QWORD PTR pos_target$[rsp], rax

; 3220 : 	    if(fsetpos(sfdat->file,&pos_target))

  0010e	48 8d 54 24 30	 lea	 rdx, QWORD PTR pos_target$[rsp]
  00113	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  00118	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0011b	e8 00 00 00 00	 call	 fsetpos
  00120	85 c0		 test	 eax, eax
  00122	74 0a		 je	 SHORT $LN11@psf_sndSee

; 3221 : 		    return PSF_E_CANT_SEEK;

  00124	b8 f5 ff ff ff	 mov	 eax, -11
  00129	e9 a7 00 00 00	 jmp	 $LN1@psf_sndSee
$LN11@psf_sndSee:

; 3222 : 	    break;

  0012e	eb 25		 jmp	 SHORT $LN2@psf_sndSee
$LN12@psf_sndSee:

; 3223 : 	case PSF_SEEK_CUR:
; 3224 :         /* should be safe using fseek for SEEK_END */
; 3225 :         /* Currently UNDECIDED whether to allow seeks beyond end of file! */
; 3226 : 	    if(fseek(sfdat->file,byteoffset,SEEK_CUR))

  00130	41 b8 01 00 00
	00		 mov	 r8d, 1
  00136	8b 54 24 24	 mov	 edx, DWORD PTR byteoffset$[rsp]
  0013a	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  0013f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00142	e8 00 00 00 00	 call	 fseek
  00147	85 c0		 test	 eax, eax
  00149	74 0a		 je	 SHORT $LN13@psf_sndSee

; 3227 : 		    return PSF_E_CANT_SEEK;

  0014b	b8 f5 ff ff ff	 mov	 eax, -11
  00150	e9 80 00 00 00	 jmp	 $LN1@psf_sndSee
$LN13@psf_sndSee:
$LN2@psf_sndSee:

; 3228 : 	    break;
; 3229 : 	}
; 3230 : 	if(fgetpos(sfdat->file,&cur_pos))

  00155	48 8d 54 24 38	 lea	 rdx, QWORD PTR cur_pos$[rsp]
  0015a	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  0015f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00162	e8 00 00 00 00	 call	 fgetpos
  00167	85 c0		 test	 eax, eax
  00169	74 07		 je	 SHORT $LN14@psf_sndSee

; 3231 : 	    return PSF_E_CANT_SEEK;

  0016b	b8 f5 ff ff ff	 mov	 eax, -11
  00170	eb 63		 jmp	 SHORT $LN1@psf_sndSee
$LN14@psf_sndSee:

; 3232 : 	if(POS64(cur_pos) >= POS64(sfdat->dataoffset)){

  00172	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  00177	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0017b	48 39 44 24 38	 cmp	 QWORD PTR cur_pos$[rsp], rax
  00180	7c 4e		 jl	 SHORT $LN15@psf_sndSee

; 3233 : 		sfdat->curframepos = (DWORD)(POS64(cur_pos) -  POS64(sfdat->dataoffset))  / sfdat->fmt.Format.nBlockAlign;

  00182	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  00187	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0018b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cur_pos$[rsp]
  00190	48 2b c8	 sub	 rcx, rax
  00193	48 8b c1	 mov	 rax, rcx
  00196	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0019b	0f b7 49 5c	 movzx	 ecx, WORD PTR [rcx+92]
  0019f	33 d2		 xor	 edx, edx
  001a1	f7 f1		 div	 ecx
  001a3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sfdat$[rsp]
  001a8	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 3234 : 		if(!sfdat->isRead)	{		/*RWD NEW*/

  001ab	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  001b0	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  001b4	75 14		 jne	 SHORT $LN17@psf_sndSee

; 3235 : 			/* we are rewinding a file open for writing */
; 3236 : 		    POS64(sfdat->lastwritepos) = sfdat->curframepos;

  001b6	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  001bb	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  001be	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sfdat$[rsp]
  001c3	48 89 81 90 00
	00 00		 mov	 QWORD PTR [rcx+144], rax
$LN17@psf_sndSee:

; 3237 : 		}
; 3238 : 		return PSF_E_NOERROR;

  001ca	33 c0		 xor	 eax, eax
  001cc	eb 07		 jmp	 SHORT $LN1@psf_sndSee

; 3239 : 	}

  001ce	eb 05		 jmp	 SHORT $LN16@psf_sndSee
$LN15@psf_sndSee:

; 3240 : 	else
; 3241 : 		return PSF_E_CANT_SEEK;

  001d0	b8 f5 ff ff ff	 mov	 eax, -11
$LN16@psf_sndSee:
$LN1@psf_sndSee:

; 3242 : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
psf_sndSeek ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
pos$ = 32
sfdat$ = 40
tv78 = 48
sfd$ = 80
psf_sndTell PROC

; 3157 : {

$LN7:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3158 : 	fpos_t pos;
; 3159 : 	PSFFILE *sfdat;
; 3160 : 	
; 3161 : 	if(sfd < 0 || sfd > psf_maxfiles)

  00008	83 7c 24 50 00	 cmp	 DWORD PTR sfd$[rsp], 0
  0000d	7c 07		 jl	 SHORT $LN3@psf_sndTel
  0000f	83 7c 24 50 40	 cmp	 DWORD PTR sfd$[rsp], 64	; 00000040H
  00014	7e 0a		 jle	 SHORT $LN2@psf_sndTel
$LN3@psf_sndTel:

; 3162 : 		return PSF_E_BADARG;

  00016	b8 f6 ff ff ff	 mov	 eax, -10
  0001b	e9 80 00 00 00	 jmp	 $LN1@psf_sndTel
$LN2@psf_sndTel:

; 3163 : 	
; 3164 : 	sfdat  = psf_files[sfd];

  00020	48 63 44 24 50	 movsxd	 rax, DWORD PTR sfd$[rsp]
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:psf_files
  0002c	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00030	48 89 44 24 28	 mov	 QWORD PTR sfdat$[rsp], rax

; 3165 : 	if(sfdat==NULL)

  00035	48 83 7c 24 28
	00		 cmp	 QWORD PTR sfdat$[rsp], 0
  0003b	75 07		 jne	 SHORT $LN4@psf_sndTel

; 3166 : 		return PSF_E_BADARG;

  0003d	b8 f6 ff ff ff	 mov	 eax, -10
  00042	eb 5c		 jmp	 SHORT $LN1@psf_sndTel
$LN4@psf_sndTel:

; 3167 : #ifdef _DEBUG		
; 3168 : 	assert(sfdat->file);
; 3169 : 	assert(sfdat->filename);
; 3170 : #endif
; 3171 : 	
; 3172 : 	if(fgetpos(sfdat->file,&pos))

  00044	48 8d 54 24 20	 lea	 rdx, QWORD PTR pos$[rsp]
  00049	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  0004e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00051	e8 00 00 00 00	 call	 fgetpos
  00056	85 c0		 test	 eax, eax
  00058	74 07		 je	 SHORT $LN5@psf_sndTel

; 3173 : 	    return PSF_E_CANT_SEEK;

  0005a	b8 f5 ff ff ff	 mov	 eax, -11
  0005f	eb 3f		 jmp	 SHORT $LN1@psf_sndTel
$LN5@psf_sndTel:

; 3174 : 	POS64(pos) -= POS64(sfdat->dataoffset);

  00061	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  00066	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0006a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pos$[rsp]
  0006f	48 2b c8	 sub	 rcx, rax
  00072	48 8b c1	 mov	 rax, rcx
  00075	48 89 44 24 20	 mov	 QWORD PTR pos$[rsp], rax

; 3175 : 	POS64(pos) /= sfdat->fmt.Format.nBlockAlign;

  0007a	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  0007f	0f b7 40 5c	 movzx	 eax, WORD PTR [rax+92]
  00083	48 89 44 24 30	 mov	 QWORD PTR tv78[rsp], rax
  00088	48 8b 44 24 20	 mov	 rax, QWORD PTR pos$[rsp]
  0008d	48 99		 cdq
  0008f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv78[rsp]
  00094	48 f7 f9	 idiv	 rcx
  00097	48 89 44 24 20	 mov	 QWORD PTR pos$[rsp], rax

; 3176 : #ifdef _DEBUG
; 3177 : 	if(sfdat->lastop == PSF_OP_READ)
; 3178 : 		assert(pos== sfdat->curframepos);
; 3179 : 	else if(sfdat->lastop == PSF_OP_WRITE)
; 3180 : 		/* RWD this will be out (but == curframepos) if lastop was a read . so maybe say >=, or test for lastop ? */
; 3181 : 		assert(pos == sfdat->lastwritepos);
; 3182 : #endif
; 3183 : 	return (int) POS64(pos);			 

  0009c	8b 44 24 20	 mov	 eax, DWORD PTR pos$[rsp]
$LN1@psf_sndTel:

; 3184 : }

  000a0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a4	c3		 ret	 0
psf_sndTell ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
j$ = 32
ssamp$1 = 36
sfdat$ = 40
i$ = 48
ssamp$2 = 52
chans$ = 56
tv205 = 60
fval$3 = 64
fval$4 = 72
tv217 = 80
tv89 = 88
tv213 = 96
tv168 = 104
sfd$ = 128
buf$ = 136
nFrames$ = 144
psf_sndWriteShortFrames PROC

; 1995 : {

$LN28:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1996 : 	int chans;	 
; 1997 : 	DWORD i;
; 1998 : 	int j;
; 1999 : 	PSFFILE *sfdat;
; 2000 : 	
; 2001 : 	if(sfd < 0 || sfd > psf_maxfiles)

  00012	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR sfd$[rsp], 0
  0001a	7c 0a		 jl	 SHORT $LN15@psf_sndWri
  0001c	83 bc 24 80 00
	00 00 40	 cmp	 DWORD PTR sfd$[rsp], 64	; 00000040H
  00024	7e 0a		 jle	 SHORT $LN14@psf_sndWri
$LN15@psf_sndWri:

; 2002 : 		return PSF_E_BADARG;

  00026	b8 f6 ff ff ff	 mov	 eax, -10
  0002b	e9 73 03 00 00	 jmp	 $LN1@psf_sndWri
$LN14@psf_sndWri:

; 2003 : 	
; 2004 : 	sfdat  = psf_files[sfd];

  00030	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR sfd$[rsp]
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:psf_files
  0003f	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00043	48 89 44 24 28	 mov	 QWORD PTR sfdat$[rsp], rax

; 2005 : 	
; 2006 : #ifdef _DEBUG		
; 2007 : 	assert(sfdat->file);
; 2008 : 	assert(sfdat->filename);
; 2009 : #endif
; 2010 : 
; 2011 : 	if(buf==NULL)

  00048	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  00051	75 0a		 jne	 SHORT $LN16@psf_sndWri

; 2012 : 		return PSF_E_BADARG;

  00053	b8 f6 ff ff ff	 mov	 eax, -10
  00058	e9 46 03 00 00	 jmp	 $LN1@psf_sndWri
$LN16@psf_sndWri:

; 2013 : 	if(nFrames == 0)

  0005d	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR nFrames$[rsp], 0
  00065	75 0c		 jne	 SHORT $LN17@psf_sndWri

; 2014 : 		return nFrames;

  00067	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  0006e	e9 30 03 00 00	 jmp	 $LN1@psf_sndWri
$LN17@psf_sndWri:

; 2015 : 	if(sfdat->isRead)

  00073	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  00078	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  0007c	74 0a		 je	 SHORT $LN18@psf_sndWri

; 2016 : 		return PSF_E_FILE_READONLY;

  0007e	b8 f3 ff ff ff	 mov	 eax, -13
  00083	e9 1b 03 00 00	 jmp	 $LN1@psf_sndWri
$LN18@psf_sndWri:

; 2017 : 	chans = sfdat->fmt.Format.nChannels;

  00088	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  0008d	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  00091	89 44 24 38	 mov	 DWORD PTR chans$[rsp], eax

; 2018 : 		
; 2019 : 	/* well, it can't be ~less~ efficient than converting twice! */
; 2020 : 	if(!sfdat->is_little_endian){	

  00095	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  0009a	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0009e	0f 85 5c 01 00
	00		 jne	 $LN19@psf_sndWri

; 2021 : 		short ssamp;
; 2022 : 		double fval;
; 2023 : 		for(i=0; i < nFrames; i++){

  000a4	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000ac	eb 0a		 jmp	 SHORT $LN4@psf_sndWri
$LN2@psf_sndWri:
  000ae	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  000b2	ff c0		 inc	 eax
  000b4	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@psf_sndWri:
  000b8	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  000bf	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  000c3	0f 83 32 01 00
	00		 jae	 $LN3@psf_sndWri

; 2024 : 			for(j=0;j < chans; j++) {

  000c9	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  000d1	eb 0a		 jmp	 SHORT $LN7@psf_sndWri
$LN5@psf_sndWri:
  000d3	8b 44 24 20	 mov	 eax, DWORD PTR j$[rsp]
  000d7	ff c0		 inc	 eax
  000d9	89 44 24 20	 mov	 DWORD PTR j$[rsp], eax
$LN7@psf_sndWri:
  000dd	8b 44 24 38	 mov	 eax, DWORD PTR chans$[rsp]
  000e1	39 44 24 20	 cmp	 DWORD PTR j$[rsp], eax
  000e5	0f 8d 0b 01 00
	00		 jge	 $LN6@psf_sndWri

; 2025 : 				ssamp = *buf++;

  000eb	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  000f3	0f b7 00	 movzx	 eax, WORD PTR [rax]
  000f6	66 89 44 24 24	 mov	 WORD PTR ssamp$1[rsp], ax
  000fb	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00103	48 83 c0 02	 add	 rax, 2
  00107	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 2026 : 				fval = ((double) ssamp / MAX_16BIT);		

  0010f	0f bf 44 24 24	 movsx	 eax, WORD PTR ssamp$1[rsp]
  00114	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  00118	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@40e0000000000000
  00120	f2 0f 11 44 24
	40		 movsd	 QWORD PTR fval$3[rsp], xmm0

; 2027 : 				if(sfdat->pPeaks && (sfdat->pPeaks[j].val < (float)(fabs(fval)))){

  00126	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  0012b	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00133	74 77		 je	 SHORT $LN21@psf_sndWri
  00135	48 63 44 24 20	 movsxd	 rax, DWORD PTR j$[rsp]
  0013a	48 89 44 24 58	 mov	 QWORD PTR tv89[rsp], rax
  0013f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00144	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  0014b	48 89 4c 24 50	 mov	 QWORD PTR tv217[rsp], rcx
  00150	f2 0f 10 44 24
	40		 movsd	 xmm0, QWORD PTR fval$3[rsp]
  00156	e8 00 00 00 00	 call	 fabs
  0015b	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0015f	48 8b 44 24 50	 mov	 rax, QWORD PTR tv217[rsp]
  00164	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv89[rsp]
  00169	0f 2f 04 c8	 comiss	 xmm0, DWORD PTR [rax+rcx*8]
  0016d	76 3d		 jbe	 SHORT $LN21@psf_sndWri

; 2028 : 					sfdat->pPeaks[j].pos = sfdat->nFrames + i;

  0016f	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  00174	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00177	03 44 24 30	 add	 eax, DWORD PTR i$[rsp]
  0017b	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR j$[rsp]
  00180	48 8b 54 24 28	 mov	 rdx, QWORD PTR sfdat$[rsp]
  00185	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  0018c	89 44 ca 04	 mov	 DWORD PTR [rdx+rcx*8+4], eax

; 2029 : 					sfdat->pPeaks[j].val = (float)fval;

  00190	f2 0f 5a 44 24
	40		 cvtsd2ss xmm0, QWORD PTR fval$3[rsp]
  00196	48 63 44 24 20	 movsxd	 rax, DWORD PTR j$[rsp]
  0019b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sfdat$[rsp]
  001a0	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  001a7	f3 0f 11 04 c1	 movss	 DWORD PTR [rcx+rax*8], xmm0
$LN21@psf_sndWri:

; 2030 : 				}
; 2031 : 								
; 2032 : 				ssamp = (short) REVWBYTES(ssamp);

  001ac	0f bf 44 24 24	 movsx	 eax, WORD PTR ssamp$1[rsp]
  001b1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001b6	c1 e0 08	 shl	 eax, 8
  001b9	0f bf 4c 24 24	 movsx	 ecx, WORD PTR ssamp$1[rsp]
  001be	c1 f9 08	 sar	 ecx, 8
  001c1	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  001c7	0b c1		 or	 eax, ecx
  001c9	66 89 44 24 24	 mov	 WORD PTR ssamp$1[rsp], ax

; 2033 : 				if(wavDoWrite(sfdat,(char *) &ssamp,sizeof(short))){

  001ce	41 b8 02 00 00
	00		 mov	 r8d, 2
  001d4	48 8d 54 24 24	 lea	 rdx, QWORD PTR ssamp$1[rsp]
  001d9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sfdat$[rsp]
  001de	e8 00 00 00 00	 call	 wavDoWrite
  001e3	85 c0		 test	 eax, eax
  001e5	74 0a		 je	 SHORT $LN22@psf_sndWri

; 2034 : 					DBGFPRINTF((stderr, "wavOpenWrite: write error\n"));
; 2035 : 					return PSF_E_CANT_WRITE;

  001e7	b8 fd ff ff ff	 mov	 eax, -3
  001ec	e9 b2 01 00 00	 jmp	 $LN1@psf_sndWri
$LN22@psf_sndWri:

; 2036 : 				}
; 2037 : 			}

  001f1	e9 dd fe ff ff	 jmp	 $LN5@psf_sndWri
$LN6@psf_sndWri:

; 2038 : 		}

  001f6	e9 b3 fe ff ff	 jmp	 $LN2@psf_sndWri
$LN3@psf_sndWri:

; 2039 : 	}

  001fb	e9 32 01 00 00	 jmp	 $LN20@psf_sndWri
$LN19@psf_sndWri:

; 2040 : 	else {
; 2041 : 		short ssamp;
; 2042 : 		double fval;
; 2043 : 		for(i=0; i < nFrames; i++){

  00200	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00208	eb 0a		 jmp	 SHORT $LN10@psf_sndWri
$LN8@psf_sndWri:
  0020a	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0020e	ff c0		 inc	 eax
  00210	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@psf_sndWri:
  00214	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  0021b	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0021f	0f 83 0d 01 00
	00		 jae	 $LN9@psf_sndWri

; 2044 : 			for(j=0;j < chans; j++) {

  00225	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  0022d	eb 0a		 jmp	 SHORT $LN13@psf_sndWri
$LN11@psf_sndWri:
  0022f	8b 44 24 20	 mov	 eax, DWORD PTR j$[rsp]
  00233	ff c0		 inc	 eax
  00235	89 44 24 20	 mov	 DWORD PTR j$[rsp], eax
$LN13@psf_sndWri:
  00239	8b 44 24 38	 mov	 eax, DWORD PTR chans$[rsp]
  0023d	39 44 24 20	 cmp	 DWORD PTR j$[rsp], eax
  00241	0f 8d e6 00 00
	00		 jge	 $LN12@psf_sndWri

; 2045 : 				ssamp = *buf++;

  00247	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0024f	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00252	66 89 44 24 34	 mov	 WORD PTR ssamp$2[rsp], ax
  00257	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0025f	48 83 c0 02	 add	 rax, 2
  00263	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 2046 : 				fval = ((double) ssamp / MAX_16BIT);		

  0026b	0f bf 44 24 34	 movsx	 eax, WORD PTR ssamp$2[rsp]
  00270	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  00274	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@40e0000000000000
  0027c	f2 0f 11 44 24
	48		 movsd	 QWORD PTR fval$4[rsp], xmm0

; 2047 : 				if(sfdat->pPeaks && (sfdat->pPeaks[j].val < (float)(fabs(fval)))){

  00282	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  00287	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  0028f	74 77		 je	 SHORT $LN23@psf_sndWri
  00291	48 63 44 24 20	 movsxd	 rax, DWORD PTR j$[rsp]
  00296	48 89 44 24 68	 mov	 QWORD PTR tv168[rsp], rax
  0029b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sfdat$[rsp]
  002a0	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  002a7	48 89 4c 24 60	 mov	 QWORD PTR tv213[rsp], rcx
  002ac	f2 0f 10 44 24
	48		 movsd	 xmm0, QWORD PTR fval$4[rsp]
  002b2	e8 00 00 00 00	 call	 fabs
  002b7	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  002bb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv213[rsp]
  002c0	48 8b 44 24 68	 mov	 rax, QWORD PTR tv168[rsp]
  002c5	0f 2f 04 c1	 comiss	 xmm0, DWORD PTR [rcx+rax*8]
  002c9	76 3d		 jbe	 SHORT $LN23@psf_sndWri

; 2048 : 					sfdat->pPeaks[j].pos = sfdat->nFrames + i;

  002cb	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  002d0	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  002d3	03 44 24 30	 add	 eax, DWORD PTR i$[rsp]
  002d7	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR j$[rsp]
  002dc	48 8b 54 24 28	 mov	 rdx, QWORD PTR sfdat$[rsp]
  002e1	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  002e8	89 44 ca 04	 mov	 DWORD PTR [rdx+rcx*8+4], eax

; 2049 : 					sfdat->pPeaks[j].val = (float)fval;

  002ec	f2 0f 5a 44 24
	48		 cvtsd2ss xmm0, QWORD PTR fval$4[rsp]
  002f2	48 63 44 24 20	 movsxd	 rax, DWORD PTR j$[rsp]
  002f7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sfdat$[rsp]
  002fc	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00303	f3 0f 11 04 c1	 movss	 DWORD PTR [rcx+rax*8], xmm0
$LN23@psf_sndWri:

; 2050 : 				}
; 2051 : 				
; 2052 : 				if(wavDoWrite(sfdat,(char *) &ssamp,sizeof(short))){

  00308	41 b8 02 00 00
	00		 mov	 r8d, 2
  0030e	48 8d 54 24 34	 lea	 rdx, QWORD PTR ssamp$2[rsp]
  00313	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00318	e8 00 00 00 00	 call	 wavDoWrite
  0031d	85 c0		 test	 eax, eax
  0031f	74 07		 je	 SHORT $LN24@psf_sndWri

; 2053 : 					DBGFPRINTF((stderr, "wavOpenWrite: write error\n"));
; 2054 : 					return PSF_E_CANT_WRITE;

  00321	b8 fd ff ff ff	 mov	 eax, -3
  00326	eb 7b		 jmp	 SHORT $LN1@psf_sndWri
$LN24@psf_sndWri:

; 2055 : 				}
; 2056 : 			}

  00328	e9 02 ff ff ff	 jmp	 $LN11@psf_sndWri
$LN12@psf_sndWri:

; 2057 : 		}			

  0032d	e9 d8 fe ff ff	 jmp	 $LN8@psf_sndWri
$LN9@psf_sndWri:
$LN20@psf_sndWri:

; 2058 : 	}
; 2059 : 	POS64(sfdat->lastwritepos) += nFrames;						

  00332	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  00339	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0033e	48 03 81 90 00
	00 00		 add	 rax, QWORD PTR [rcx+144]
  00345	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0034a	48 89 81 90 00
	00 00		 mov	 QWORD PTR [rcx+144], rax

; 2060 : 	sfdat->nFrames = max(sfdat->nFrames, ((DWORD) POS64(sfdat->lastwritepos)));

  00351	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  00356	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0035b	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00361	39 48 14	 cmp	 DWORD PTR [rax+20], ecx
  00364	76 0e		 jbe	 SHORT $LN26@psf_sndWri
  00366	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  0036b	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0036e	89 44 24 3c	 mov	 DWORD PTR tv205[rsp], eax
  00372	eb 0f		 jmp	 SHORT $LN27@psf_sndWri
$LN26@psf_sndWri:
  00374	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  00379	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0037f	89 44 24 3c	 mov	 DWORD PTR tv205[rsp], eax
$LN27@psf_sndWri:
  00383	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  00388	8b 4c 24 3c	 mov	 ecx, DWORD PTR tv205[rsp]
  0038c	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 2061 : 	fflush(sfdat->file);

  0038f	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  00394	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00397	e8 00 00 00 00	 call	 fflush

; 2062 : 	return nFrames;

  0039c	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
$LN1@psf_sndWri:

; 2063 : }

  003a3	48 83 c4 78	 add	 rsp, 120		; 00000078H
  003a7	c3		 ret	 0
psf_sndWriteShortFrames ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
fsamp$ = 32
j$ = 36
i$ = 40
sfdat$ = 48
lsamp$ = 56
absfsamp$ = 60
chans$ = 64
ssamp$1 = 68
ssamp$2 = 72
do_reverse$ = 76
tv76 = 80
tv92 = 84
do_shift$ = 88
pbuf$ = 96
tv135 = 104
tv137 = 108
tv192 = 112
tv194 = 116
tv232 = 120
tv234 = 124
tv300 = 128
tv302 = 132
tv356 = 136
tv358 = 140
tv420 = 144
tv422 = 148
tv469 = 152
tv471 = 156
tv528 = 160
tv530 = 164
tv580 = 168
tv79 = 172
tv82 = 176
tv263 = 184
tv331 = 192
sfd$ = 224
buf$ = 232
nFrames$ = 240
psf_sndWriteDoubleFrames PROC

; 1739 : {

$LN143:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 1740 : 	int chans,lsamp;	
; 1741 : 	DWORD i;
; 1742 : 	int j,do_reverse;
; 1743 : 	const double *pbuf = buf;

  00015	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0001d	48 89 44 24 60	 mov	 QWORD PTR pbuf$[rsp], rax

; 1744 : 	float fsamp,absfsamp;
; 1745 : 	PSFFILE *sfdat;
; 1746 :     int do_shift = 1;

  00022	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR do_shift$[rsp], 1

; 1747 : 
; 1748 : 	if(sfd < 0 || sfd > psf_maxfiles)

  0002a	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR sfd$[rsp], 0
  00032	7c 0a		 jl	 SHORT $LN55@psf_sndWri
  00034	83 bc 24 e0 00
	00 00 40	 cmp	 DWORD PTR sfd$[rsp], 64	; 00000040H
  0003c	7e 0a		 jle	 SHORT $LN54@psf_sndWri
$LN55@psf_sndWri:

; 1749 : 		return PSF_E_BADARG;

  0003e	b8 f6 ff ff ff	 mov	 eax, -10
  00043	e9 69 11 00 00	 jmp	 $LN1@psf_sndWri
$LN54@psf_sndWri:

; 1750 : 	
; 1751 : 	sfdat  = psf_files[sfd];	

  00048	48 63 84 24 e0
	00 00 00	 movsxd	 rax, DWORD PTR sfd$[rsp]
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:psf_files
  00057	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0005b	48 89 44 24 30	 mov	 QWORD PTR sfdat$[rsp], rax

; 1752 : #ifdef _DEBUG		
; 1753 : 	assert(sfdat->file);
; 1754 : 	assert(sfdat->filename);	
; 1755 : #endif
; 1756 : 	if(buf==NULL)

  00060	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  00069	75 0a		 jne	 SHORT $LN56@psf_sndWri

; 1757 : 		return PSF_E_BADARG;

  0006b	b8 f6 ff ff ff	 mov	 eax, -10
  00070	e9 3c 11 00 00	 jmp	 $LN1@psf_sndWri
$LN56@psf_sndWri:

; 1758 : 	if(nFrames == 0)

  00075	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR nFrames$[rsp], 0
  0007d	75 0c		 jne	 SHORT $LN57@psf_sndWri

; 1759 : 		return nFrames;

  0007f	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  00086	e9 26 11 00 00	 jmp	 $LN1@psf_sndWri
$LN57@psf_sndWri:

; 1760 : 	if(sfdat->isRead)

  0008b	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00090	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00094	74 0a		 je	 SHORT $LN58@psf_sndWri

; 1761 : 		return PSF_E_FILE_READONLY;

  00096	b8 f3 ff ff ff	 mov	 eax, -13
  0009b	e9 11 11 00 00	 jmp	 $LN1@psf_sndWri
$LN58@psf_sndWri:

; 1762 : 	chans = sfdat->fmt.Format.nChannels;

  000a0	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  000a5	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  000a9	89 44 24 40	 mov	 DWORD PTR chans$[rsp], eax

; 1763 : 	
; 1764 : 	switch(sfdat->riff_format){

  000ad	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  000b2	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  000b5	89 44 24 50	 mov	 DWORD PTR tv76[rsp], eax
  000b9	83 7c 24 50 00	 cmp	 DWORD PTR tv76[rsp], 0
  000be	0f 8e 87 00 00
	00		 jle	 $LN61@psf_sndWri
  000c4	83 7c 24 50 02	 cmp	 DWORD PTR tv76[rsp], 2
  000c9	7e 10		 jle	 SHORT $LN59@psf_sndWri
  000cb	83 7c 24 50 02	 cmp	 DWORD PTR tv76[rsp], 2
  000d0	7e 79		 jle	 SHORT $LN61@psf_sndWri
  000d2	83 7c 24 50 04	 cmp	 DWORD PTR tv76[rsp], 4
  000d7	7e 3a		 jle	 SHORT $LN60@psf_sndWri
  000d9	eb 70		 jmp	 SHORT $LN61@psf_sndWri
$LN59@psf_sndWri:

; 1765 : 	case(PSF_STDWAVE):
; 1766 : 	case(PSF_WAVE_EX):
; 1767 : 		do_reverse = (sfdat->is_little_endian ? 0 : 1 );

  000db	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  000e0	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  000e4	74 0d		 je	 SHORT $LN105@psf_sndWri
  000e6	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv79[rsp], 0
  000f1	eb 0b		 jmp	 SHORT $LN106@psf_sndWri
$LN105@psf_sndWri:
  000f3	c7 84 24 ac 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv79[rsp], 1
$LN106@psf_sndWri:
  000fe	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR tv79[rsp]
  00105	89 44 24 4c	 mov	 DWORD PTR do_reverse$[rsp], eax

; 1768 :         do_shift = 1;

  00109	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR do_shift$[rsp], 1

; 1769 : 		break;

  00111	eb 42		 jmp	 SHORT $LN2@psf_sndWri
$LN60@psf_sndWri:

; 1770 : 	case(PSF_AIFF):
; 1771 : 	case(PSF_AIFC):
; 1772 : 		do_reverse = (sfdat->is_little_endian ? 1 : 0 );

  00113	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00118	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0011c	74 0d		 je	 SHORT $LN107@psf_sndWri
  0011e	c7 84 24 b0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv82[rsp], 1
  00129	eb 0b		 jmp	 SHORT $LN108@psf_sndWri
$LN107@psf_sndWri:
  0012b	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv82[rsp], 0
$LN108@psf_sndWri:
  00136	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv82[rsp]
  0013d	89 44 24 4c	 mov	 DWORD PTR do_reverse$[rsp], eax

; 1773 :         do_shift = 0;

  00141	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR do_shift$[rsp], 0

; 1774 : 		break;

  00149	eb 0a		 jmp	 SHORT $LN2@psf_sndWri
$LN61@psf_sndWri:

; 1775 : 	default:
; 1776 : 		return PSF_E_UNSUPPORTED;

  0014b	b8 f8 ff ff ff	 mov	 eax, -8
  00150	e9 5c 10 00 00	 jmp	 $LN1@psf_sndWri
$LN2@psf_sndWri:

; 1777 : 	}
; 1778 : 	if(sfdat->lastop  == PSF_OP_READ)

  00155	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  0015a	83 b8 98 00 00
	00 00		 cmp	 DWORD PTR [rax+152], 0
  00161	75 0d		 jne	 SHORT $LN62@psf_sndWri

; 1779 : 		fflush(sfdat->file);

  00163	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00168	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0016b	e8 00 00 00 00	 call	 fflush
$LN62@psf_sndWri:

; 1780 : 	switch(sfdat->samptype){

  00170	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00175	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00178	89 44 24 54	 mov	 DWORD PTR tv92[rsp], eax
  0017c	83 7c 24 54 02	 cmp	 DWORD PTR tv92[rsp], 2
  00181	0f 84 97 03 00
	00		 je	 $LN72@psf_sndWri
  00187	83 7c 24 54 03	 cmp	 DWORD PTR tv92[rsp], 3
  0018c	0f 84 ce 07 00
	00		 je	 $LN83@psf_sndWri
  00192	83 7c 24 54 04	 cmp	 DWORD PTR tv92[rsp], 4
  00197	0f 84 d2 0b 00
	00		 je	 $LN96@psf_sndWri
  0019d	83 7c 24 54 05	 cmp	 DWORD PTR tv92[rsp], 5
  001a2	74 05		 je	 SHORT $LN63@psf_sndWri
  001a4	e9 7e 0f 00 00	 jmp	 $LN103@psf_sndWri
$LN63@psf_sndWri:

; 1781 : 	case(PSF_SAMP_IEEE_FLOAT):		
; 1782 : 		if(do_reverse){				

  001a9	83 7c 24 4c 00	 cmp	 DWORD PTR do_reverse$[rsp], 0
  001ae	0f 84 d2 01 00
	00		 je	 $LN64@psf_sndWri

; 1783 : 			for(i=0; i < nFrames; i++){

  001b4	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001bc	eb 0a		 jmp	 SHORT $LN8@psf_sndWri
$LN6@psf_sndWri:
  001be	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  001c2	ff c0		 inc	 eax
  001c4	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN8@psf_sndWri:
  001c8	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  001cf	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  001d3	0f 83 a8 01 00
	00		 jae	 $LN7@psf_sndWri

; 1784 : 				for(j=0;j < chans; j++) {

  001d9	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  001e1	eb 0a		 jmp	 SHORT $LN11@psf_sndWri
$LN9@psf_sndWri:
  001e3	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  001e7	ff c0		 inc	 eax
  001e9	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN11@psf_sndWri:
  001ed	8b 44 24 40	 mov	 eax, DWORD PTR chans$[rsp]
  001f1	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  001f5	0f 8d 81 01 00
	00		 jge	 $LN10@psf_sndWri

; 1785 : 					fsamp = (float) *pbuf++;

  001fb	48 8b 44 24 60	 mov	 rax, QWORD PTR pbuf$[rsp]
  00200	f2 0f 5a 00	 cvtsd2ss xmm0, QWORD PTR [rax]
  00204	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0
  0020a	48 8b 44 24 60	 mov	 rax, QWORD PTR pbuf$[rsp]
  0020f	48 83 c0 08	 add	 rax, 8
  00213	48 89 44 24 60	 mov	 QWORD PTR pbuf$[rsp], rax

; 1786 : 					if(sfdat->clip_floats){

  00218	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  0021d	83 78 1c 00	 cmp	 DWORD PTR [rax+28], 0
  00221	74 6e		 je	 SHORT $LN66@psf_sndWri

; 1787 : 						fsamp = min(fsamp,1.0f);

  00223	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0022b	0f 2f 44 24 20	 comiss	 xmm0, DWORD PTR fsamp$[rsp]
  00230	76 0e		 jbe	 SHORT $LN109@psf_sndWri
  00232	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00238	f3 0f 11 44 24
	68		 movss	 DWORD PTR tv135[rsp], xmm0
  0023e	eb 0e		 jmp	 SHORT $LN110@psf_sndWri
$LN109@psf_sndWri:
  00240	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00248	f3 0f 11 44 24
	68		 movss	 DWORD PTR tv135[rsp], xmm0
$LN110@psf_sndWri:
  0024e	f3 0f 10 44 24
	68		 movss	 xmm0, DWORD PTR tv135[rsp]
  00254	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1788 : 						fsamp = max(fsamp,-1.0f);

  0025a	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00260	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@bf800000
  00267	76 0e		 jbe	 SHORT $LN111@psf_sndWri
  00269	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  0026f	f3 0f 11 44 24
	6c		 movss	 DWORD PTR tv137[rsp], xmm0
  00275	eb 0e		 jmp	 SHORT $LN112@psf_sndWri
$LN111@psf_sndWri:
  00277	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0027f	f3 0f 11 44 24
	6c		 movss	 DWORD PTR tv137[rsp], xmm0
$LN112@psf_sndWri:
  00285	f3 0f 10 44 24
	6c		 movss	 xmm0, DWORD PTR tv137[rsp]
  0028b	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0
$LN66@psf_sndWri:

; 1789 : 					}
; 1790 : 					absfsamp = (float) fabs((double)fsamp);

  00291	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  00297	e8 00 00 00 00	 call	 fabs
  0029c	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  002a0	f3 0f 11 44 24
	3c		 movss	 DWORD PTR absfsamp$[rsp], xmm0

; 1791 : 					if(sfdat->pPeaks && (sfdat->pPeaks[j].val < absfsamp)){

  002a6	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  002ab	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  002b3	74 5a		 je	 SHORT $LN67@psf_sndWri
  002b5	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  002ba	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  002bf	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  002c6	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  002cc	0f 2f 04 c1	 comiss	 xmm0, DWORD PTR [rcx+rax*8]
  002d0	76 3d		 jbe	 SHORT $LN67@psf_sndWri

; 1792 : 						sfdat->pPeaks[j].pos = sfdat->nFrames + i;

  002d2	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  002d7	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  002da	03 44 24 28	 add	 eax, DWORD PTR i$[rsp]
  002de	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  002e3	48 8b 54 24 30	 mov	 rdx, QWORD PTR sfdat$[rsp]
  002e8	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  002ef	89 44 ca 04	 mov	 DWORD PTR [rdx+rcx*8+4], eax

; 1793 : 						sfdat->pPeaks[j].val = absfsamp;

  002f3	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  002f8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  002fd	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00304	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  0030a	f3 0f 11 04 c1	 movss	 DWORD PTR [rcx+rax*8], xmm0
$LN67@psf_sndWri:

; 1794 : 					}
; 1795 : 					lsamp = * (int *) &fsamp;

  0030f	8b 44 24 20	 mov	 eax, DWORD PTR fsamp$[rsp]
  00313	89 44 24 38	 mov	 DWORD PTR lsamp$[rsp], eax

; 1796 : 					lsamp = REVDWBYTES(lsamp);

  00317	8b 44 24 38	 mov	 eax, DWORD PTR lsamp$[rsp]
  0031b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00320	c1 e0 18	 shl	 eax, 24
  00323	8b 4c 24 38	 mov	 ecx, DWORD PTR lsamp$[rsp]
  00327	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  0032d	c1 e1 08	 shl	 ecx, 8
  00330	0b c1		 or	 eax, ecx
  00332	8b 4c 24 38	 mov	 ecx, DWORD PTR lsamp$[rsp]
  00336	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  0033c	c1 f9 08	 sar	 ecx, 8
  0033f	0b c1		 or	 eax, ecx
  00341	8b 4c 24 38	 mov	 ecx, DWORD PTR lsamp$[rsp]
  00345	c1 f9 18	 sar	 ecx, 24
  00348	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0034e	0b c1		 or	 eax, ecx
  00350	89 44 24 38	 mov	 DWORD PTR lsamp$[rsp], eax

; 1797 : 					if(wavDoWrite(sfdat,(char *) &lsamp,sizeof(int))){

  00354	41 b8 04 00 00
	00		 mov	 r8d, 4
  0035a	48 8d 54 24 38	 lea	 rdx, QWORD PTR lsamp$[rsp]
  0035f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00364	e8 00 00 00 00	 call	 wavDoWrite
  00369	85 c0		 test	 eax, eax
  0036b	74 0a		 je	 SHORT $LN68@psf_sndWri

; 1798 : 						DBGFPRINTF((stderr, "wavOpenWrite: write error\n"));
; 1799 : 						return PSF_E_CANT_WRITE;

  0036d	b8 fd ff ff ff	 mov	 eax, -3
  00372	e9 3a 0e 00 00	 jmp	 $LN1@psf_sndWri
$LN68@psf_sndWri:

; 1800 : 					}
; 1801 : 				}							

  00377	e9 67 fe ff ff	 jmp	 $LN9@psf_sndWri
$LN10@psf_sndWri:

; 1802 : 			}			

  0037c	e9 3d fe ff ff	 jmp	 $LN6@psf_sndWri
$LN7@psf_sndWri:

; 1803 : 		}

  00381	e9 93 01 00 00	 jmp	 $LN65@psf_sndWri
$LN64@psf_sndWri:

; 1804 : 		else {			
; 1805 : 			for(i=0; i < nFrames; i++, pbuf += chans){

  00386	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0038e	eb 1d		 jmp	 SHORT $LN14@psf_sndWri
$LN12@psf_sndWri:
  00390	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00394	ff c0		 inc	 eax
  00396	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
  0039a	48 63 44 24 40	 movsxd	 rax, DWORD PTR chans$[rsp]
  0039f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pbuf$[rsp]
  003a4	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  003a8	48 89 44 24 60	 mov	 QWORD PTR pbuf$[rsp], rax
$LN14@psf_sndWri:
  003ad	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  003b4	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  003b8	0f 83 5b 01 00
	00		 jae	 $LN13@psf_sndWri

; 1806 : 				for(j=0;j < chans; j++) {

  003be	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  003c6	eb 0a		 jmp	 SHORT $LN17@psf_sndWri
$LN15@psf_sndWri:
  003c8	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  003cc	ff c0		 inc	 eax
  003ce	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN17@psf_sndWri:
  003d2	8b 44 24 40	 mov	 eax, DWORD PTR chans$[rsp]
  003d6	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  003da	0f 8d 34 01 00
	00		 jge	 $LN16@psf_sndWri

; 1807 : 					fsamp = (float) pbuf[j];

  003e0	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  003e5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pbuf$[rsp]
  003ea	f2 0f 5a 04 c1	 cvtsd2ss xmm0, QWORD PTR [rcx+rax*8]
  003ef	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1808 : 					if(sfdat->clip_floats){

  003f5	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  003fa	83 78 1c 00	 cmp	 DWORD PTR [rax+28], 0
  003fe	74 6e		 je	 SHORT $LN69@psf_sndWri

; 1809 : 						fsamp = min(fsamp,1.0f);

  00400	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00408	0f 2f 44 24 20	 comiss	 xmm0, DWORD PTR fsamp$[rsp]
  0040d	76 0e		 jbe	 SHORT $LN113@psf_sndWri
  0040f	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00415	f3 0f 11 44 24
	70		 movss	 DWORD PTR tv192[rsp], xmm0
  0041b	eb 0e		 jmp	 SHORT $LN114@psf_sndWri
$LN113@psf_sndWri:
  0041d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00425	f3 0f 11 44 24
	70		 movss	 DWORD PTR tv192[rsp], xmm0
$LN114@psf_sndWri:
  0042b	f3 0f 10 44 24
	70		 movss	 xmm0, DWORD PTR tv192[rsp]
  00431	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1810 : 						fsamp = max(fsamp,-1.0f);

  00437	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  0043d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@bf800000
  00444	76 0e		 jbe	 SHORT $LN115@psf_sndWri
  00446	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  0044c	f3 0f 11 44 24
	74		 movss	 DWORD PTR tv194[rsp], xmm0
  00452	eb 0e		 jmp	 SHORT $LN116@psf_sndWri
$LN115@psf_sndWri:
  00454	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0045c	f3 0f 11 44 24
	74		 movss	 DWORD PTR tv194[rsp], xmm0
$LN116@psf_sndWri:
  00462	f3 0f 10 44 24
	74		 movss	 xmm0, DWORD PTR tv194[rsp]
  00468	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0
$LN69@psf_sndWri:

; 1811 : 					}
; 1812 :                     if(wavDoWrite(sfdat,(char*)&fsamp,sizeof(float))){

  0046e	41 b8 04 00 00
	00		 mov	 r8d, 4
  00474	48 8d 54 24 20	 lea	 rdx, QWORD PTR fsamp$[rsp]
  00479	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0047e	e8 00 00 00 00	 call	 wavDoWrite
  00483	85 c0		 test	 eax, eax
  00485	74 0a		 je	 SHORT $LN70@psf_sndWri

; 1813 :                         DBGFPRINTF((stderr, "wavOpenWrite: write error\n"));
; 1814 : 					    return PSF_E_CANT_WRITE;

  00487	b8 fd ff ff ff	 mov	 eax, -3
  0048c	e9 20 0d 00 00	 jmp	 $LN1@psf_sndWri
$LN70@psf_sndWri:

; 1815 : 					}
; 1816 : 					absfsamp = (float)fabs((double)fsamp);

  00491	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  00497	e8 00 00 00 00	 call	 fabs
  0049c	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  004a0	f3 0f 11 44 24
	3c		 movss	 DWORD PTR absfsamp$[rsp], xmm0

; 1817 : 					if(sfdat->pPeaks && (sfdat->pPeaks[j].val < absfsamp)){

  004a6	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  004ab	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  004b3	74 5a		 je	 SHORT $LN71@psf_sndWri
  004b5	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  004ba	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  004bf	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  004c6	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  004cc	0f 2f 04 c1	 comiss	 xmm0, DWORD PTR [rcx+rax*8]
  004d0	76 3d		 jbe	 SHORT $LN71@psf_sndWri

; 1818 : 						sfdat->pPeaks[j].pos = sfdat->nFrames + i;

  004d2	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  004d7	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  004da	03 44 24 28	 add	 eax, DWORD PTR i$[rsp]
  004de	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  004e3	48 8b 54 24 30	 mov	 rdx, QWORD PTR sfdat$[rsp]
  004e8	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  004ef	89 44 ca 04	 mov	 DWORD PTR [rdx+rcx*8+4], eax

; 1819 : 						sfdat->pPeaks[j].val = absfsamp;

  004f3	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  004f8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  004fd	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00504	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  0050a	f3 0f 11 04 c1	 movss	 DWORD PTR [rcx+rax*8], xmm0
$LN71@psf_sndWri:

; 1820 : 					}					
; 1821 : 				}								

  0050f	e9 b4 fe ff ff	 jmp	 $LN15@psf_sndWri
$LN16@psf_sndWri:

; 1822 : 			}			

  00514	e9 77 fe ff ff	 jmp	 $LN12@psf_sndWri
$LN13@psf_sndWri:
$LN65@psf_sndWri:

; 1823 : 		}
; 1824 : 		break;

  00519	e9 13 0c 00 00	 jmp	 $LN4@psf_sndWri
$LN72@psf_sndWri:

; 1825 : 	case(PSF_SAMP_16):
; 1826 : 		/* TODO: optimise all this with func pointers etc */
; 1827 : 		if(do_reverse){	

  0051e	83 7c 24 4c 00	 cmp	 DWORD PTR do_reverse$[rsp], 0
  00523	0f 84 1e 02 00
	00		 je	 $LN73@psf_sndWri

; 1828 : 			short ssamp;
; 1829 : 			for(i=0; i < nFrames; i++){

  00529	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00531	eb 0a		 jmp	 SHORT $LN20@psf_sndWri
$LN18@psf_sndWri:
  00533	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00537	ff c0		 inc	 eax
  00539	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN20@psf_sndWri:
  0053d	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  00544	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00548	0f 83 f4 01 00
	00		 jae	 $LN19@psf_sndWri

; 1830 : 				for(j=0;j < chans; j++) {

  0054e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00556	eb 0a		 jmp	 SHORT $LN23@psf_sndWri
$LN21@psf_sndWri:
  00558	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  0055c	ff c0		 inc	 eax
  0055e	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN23@psf_sndWri:
  00562	8b 44 24 40	 mov	 eax, DWORD PTR chans$[rsp]
  00566	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  0056a	0f 8d cd 01 00
	00		 jge	 $LN22@psf_sndWri

; 1831 : 					fsamp = (float)  *buf++;

  00570	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00578	f2 0f 5a 00	 cvtsd2ss xmm0, QWORD PTR [rax]
  0057c	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0
  00582	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0058a	48 83 c0 08	 add	 rax, 8
  0058e	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 1832 : 					/* clip now! we may have a flag to rescale first...one day */
; 1833 : 					fsamp = min(fsamp,1.0f);

  00596	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0059e	0f 2f 44 24 20	 comiss	 xmm0, DWORD PTR fsamp$[rsp]
  005a3	76 0e		 jbe	 SHORT $LN117@psf_sndWri
  005a5	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  005ab	f3 0f 11 44 24
	78		 movss	 DWORD PTR tv232[rsp], xmm0
  005b1	eb 0e		 jmp	 SHORT $LN118@psf_sndWri
$LN117@psf_sndWri:
  005b3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  005bb	f3 0f 11 44 24
	78		 movss	 DWORD PTR tv232[rsp], xmm0
$LN118@psf_sndWri:
  005c1	f3 0f 10 44 24
	78		 movss	 xmm0, DWORD PTR tv232[rsp]
  005c7	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1834 : 					fsamp = max(fsamp,-1.0f);

  005cd	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  005d3	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@bf800000
  005da	76 0e		 jbe	 SHORT $LN119@psf_sndWri
  005dc	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  005e2	f3 0f 11 44 24
	7c		 movss	 DWORD PTR tv234[rsp], xmm0
  005e8	eb 0e		 jmp	 SHORT $LN120@psf_sndWri
$LN119@psf_sndWri:
  005ea	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  005f2	f3 0f 11 44 24
	7c		 movss	 DWORD PTR tv234[rsp], xmm0
$LN120@psf_sndWri:
  005f8	f3 0f 10 44 24
	7c		 movss	 xmm0, DWORD PTR tv234[rsp]
  005fe	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1835 : 					absfsamp = (float) fabs((double)fsamp);

  00604	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  0060a	e8 00 00 00 00	 call	 fabs
  0060f	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00613	f3 0f 11 44 24
	3c		 movss	 DWORD PTR absfsamp$[rsp], xmm0

; 1836 : 					if(sfdat->pPeaks && (sfdat->pPeaks[j].val < absfsamp)){

  00619	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  0061e	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00626	74 5a		 je	 SHORT $LN75@psf_sndWri
  00628	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  0062d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00632	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00639	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  0063f	0f 2f 04 c1	 comiss	 xmm0, DWORD PTR [rcx+rax*8]
  00643	76 3d		 jbe	 SHORT $LN75@psf_sndWri

; 1837 : 						sfdat->pPeaks[j].pos = sfdat->nFrames + i;

  00645	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  0064a	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0064d	03 44 24 28	 add	 eax, DWORD PTR i$[rsp]
  00651	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  00656	48 8b 54 24 30	 mov	 rdx, QWORD PTR sfdat$[rsp]
  0065b	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  00662	89 44 ca 04	 mov	 DWORD PTR [rdx+rcx*8+4], eax

; 1838 : 						sfdat->pPeaks[j].val = absfsamp;

  00666	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  0066b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00670	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00677	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  0067d	f3 0f 11 04 c1	 movss	 DWORD PTR [rcx+rax*8], xmm0
$LN75@psf_sndWri:

; 1839 : 					}
; 1840 : 					if(sfdat->dithertype == PSF_DITHER_TPDF)

  00682	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00687	83 b8 9c 00 00
	00 01		 cmp	 DWORD PTR [rax+156], 1
  0068e	75 4b		 jne	 SHORT $LN76@psf_sndWri

; 1841 : 						ssamp = (short) psf_round(fsamp * 32766.0 + 2.0 * trirand());

  00690	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  00696	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@40dfff8000000000
  0069e	f2 0f 11 84 24
	b8 00 00 00	 movsd	 QWORD PTR tv263[rsp], xmm0
  006a7	e8 00 00 00 00	 call	 trirand
  006ac	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  006b0	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4000000000000000
  006b8	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  006bc	0f 28 c1	 movaps	 xmm0, xmm1
  006bf	f2 0f 10 8c 24
	b8 00 00 00	 movsd	 xmm1, QWORD PTR tv263[rsp]
  006c8	f2 0f 58 c8	 addsd	 xmm1, xmm0
  006cc	0f 28 c1	 movaps	 xmm0, xmm1
  006cf	e8 00 00 00 00	 call	 psf_round
  006d4	66 89 44 24 44	 mov	 WORD PTR ssamp$1[rsp], ax
  006d9	eb 18		 jmp	 SHORT $LN77@psf_sndWri
$LN76@psf_sndWri:

; 1842 : 					else
; 1843 : 						ssamp = (short) psf_round(fsamp * MAX_16BIT);

  006db	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  006e1	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@40e0000000000000
  006e9	e8 00 00 00 00	 call	 psf_round
  006ee	66 89 44 24 44	 mov	 WORD PTR ssamp$1[rsp], ax
$LN77@psf_sndWri:

; 1844 : 					ssamp = (short) REVWBYTES(ssamp);

  006f3	0f bf 44 24 44	 movsx	 eax, WORD PTR ssamp$1[rsp]
  006f8	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006fd	c1 e0 08	 shl	 eax, 8
  00700	0f bf 4c 24 44	 movsx	 ecx, WORD PTR ssamp$1[rsp]
  00705	c1 f9 08	 sar	 ecx, 8
  00708	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0070e	0b c1		 or	 eax, ecx
  00710	66 89 44 24 44	 mov	 WORD PTR ssamp$1[rsp], ax

; 1845 : 					if( wavDoWrite(sfdat,(char *) &ssamp,sizeof(short))){

  00715	41 b8 02 00 00
	00		 mov	 r8d, 2
  0071b	48 8d 54 24 44	 lea	 rdx, QWORD PTR ssamp$1[rsp]
  00720	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00725	e8 00 00 00 00	 call	 wavDoWrite
  0072a	85 c0		 test	 eax, eax
  0072c	74 0a		 je	 SHORT $LN78@psf_sndWri

; 1846 : 						DBGFPRINTF((stderr, "wavOpenWrite: write error\n"));
; 1847 : 						return PSF_E_CANT_WRITE;

  0072e	b8 fd ff ff ff	 mov	 eax, -3
  00733	e9 79 0a 00 00	 jmp	 $LN1@psf_sndWri
$LN78@psf_sndWri:

; 1848 : 					}
; 1849 : 				}	

  00738	e9 1b fe ff ff	 jmp	 $LN21@psf_sndWri
$LN22@psf_sndWri:

; 1850 : 			}

  0073d	e9 f1 fd ff ff	 jmp	 $LN18@psf_sndWri
$LN19@psf_sndWri:

; 1851 : 		}

  00742	e9 14 02 00 00	 jmp	 $LN74@psf_sndWri
$LN73@psf_sndWri:

; 1852 : 		else {
; 1853 : 			short ssamp;
; 1854 : 			for(i=0; i < nFrames; i++, buf += chans){

  00747	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0074f	eb 23		 jmp	 SHORT $LN26@psf_sndWri
$LN24@psf_sndWri:
  00751	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00755	ff c0		 inc	 eax
  00757	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
  0075b	48 63 44 24 40	 movsxd	 rax, DWORD PTR chans$[rsp]
  00760	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00768	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  0076c	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax
$LN26@psf_sndWri:
  00774	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  0077b	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  0077f	0f 83 d6 01 00
	00		 jae	 $LN25@psf_sndWri

; 1855 : 				for(j=0;j < chans; j++) {					 

  00785	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  0078d	eb 0a		 jmp	 SHORT $LN29@psf_sndWri
$LN27@psf_sndWri:
  0078f	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  00793	ff c0		 inc	 eax
  00795	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN29@psf_sndWri:
  00799	8b 44 24 40	 mov	 eax, DWORD PTR chans$[rsp]
  0079d	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  007a1	0f 8d af 01 00
	00		 jge	 $LN28@psf_sndWri

; 1856 : 					fsamp = (float) buf[j];

  007a7	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  007ac	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  007b4	f2 0f 5a 04 c1	 cvtsd2ss xmm0, QWORD PTR [rcx+rax*8]
  007b9	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1857 : 					/* clip now! we may have a flag to rescale first...one day */
; 1858 : 					fsamp = min(fsamp,1.0f);

  007bf	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  007c7	0f 2f 44 24 20	 comiss	 xmm0, DWORD PTR fsamp$[rsp]
  007cc	76 11		 jbe	 SHORT $LN121@psf_sndWri
  007ce	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  007d4	f3 0f 11 84 24
	80 00 00 00	 movss	 DWORD PTR tv300[rsp], xmm0
  007dd	eb 11		 jmp	 SHORT $LN122@psf_sndWri
$LN121@psf_sndWri:
  007df	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  007e7	f3 0f 11 84 24
	80 00 00 00	 movss	 DWORD PTR tv300[rsp], xmm0
$LN122@psf_sndWri:
  007f0	f3 0f 10 84 24
	80 00 00 00	 movss	 xmm0, DWORD PTR tv300[rsp]
  007f9	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1859 : 					fsamp = max(fsamp,-1.0f);

  007ff	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00805	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@bf800000
  0080c	76 11		 jbe	 SHORT $LN123@psf_sndWri
  0080e	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00814	f3 0f 11 84 24
	84 00 00 00	 movss	 DWORD PTR tv302[rsp], xmm0
  0081d	eb 11		 jmp	 SHORT $LN124@psf_sndWri
$LN123@psf_sndWri:
  0081f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00827	f3 0f 11 84 24
	84 00 00 00	 movss	 DWORD PTR tv302[rsp], xmm0
$LN124@psf_sndWri:
  00830	f3 0f 10 84 24
	84 00 00 00	 movss	 xmm0, DWORD PTR tv302[rsp]
  00839	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1860 : 					absfsamp = (float) fabs((double)fsamp);

  0083f	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  00845	e8 00 00 00 00	 call	 fabs
  0084a	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0084e	f3 0f 11 44 24
	3c		 movss	 DWORD PTR absfsamp$[rsp], xmm0

; 1861 : 					if(sfdat->pPeaks && (sfdat->pPeaks[j].val < absfsamp)){

  00854	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00859	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00861	74 5a		 je	 SHORT $LN79@psf_sndWri
  00863	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  00868	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0086d	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00874	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  0087a	0f 2f 04 c1	 comiss	 xmm0, DWORD PTR [rcx+rax*8]
  0087e	76 3d		 jbe	 SHORT $LN79@psf_sndWri

; 1862 : 						sfdat->pPeaks[j].pos = sfdat->nFrames + i;

  00880	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00885	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00888	03 44 24 28	 add	 eax, DWORD PTR i$[rsp]
  0088c	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  00891	48 8b 54 24 30	 mov	 rdx, QWORD PTR sfdat$[rsp]
  00896	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  0089d	89 44 ca 04	 mov	 DWORD PTR [rdx+rcx*8+4], eax

; 1863 : 						sfdat->pPeaks[j].val = absfsamp;

  008a1	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  008a6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  008ab	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  008b2	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  008b8	f3 0f 11 04 c1	 movss	 DWORD PTR [rcx+rax*8], xmm0
$LN79@psf_sndWri:

; 1864 : 					}
; 1865 : 					if(sfdat->dithertype == PSF_DITHER_TPDF)

  008bd	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  008c2	83 b8 9c 00 00
	00 01		 cmp	 DWORD PTR [rax+156], 1
  008c9	75 4b		 jne	 SHORT $LN80@psf_sndWri

; 1866 : 						ssamp = (short) psf_round(fsamp * 32766.0 + 2.0 * trirand());

  008cb	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  008d1	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@40dfff8000000000
  008d9	f2 0f 11 84 24
	c0 00 00 00	 movsd	 QWORD PTR tv331[rsp], xmm0
  008e2	e8 00 00 00 00	 call	 trirand
  008e7	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  008eb	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4000000000000000
  008f3	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  008f7	0f 28 c1	 movaps	 xmm0, xmm1
  008fa	f2 0f 10 8c 24
	c0 00 00 00	 movsd	 xmm1, QWORD PTR tv331[rsp]
  00903	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00907	0f 28 c1	 movaps	 xmm0, xmm1
  0090a	e8 00 00 00 00	 call	 psf_round
  0090f	66 89 44 24 48	 mov	 WORD PTR ssamp$2[rsp], ax
  00914	eb 18		 jmp	 SHORT $LN81@psf_sndWri
$LN80@psf_sndWri:

; 1867 : 					else
; 1868 : 						ssamp = (short) psf_round(fsamp * MAX_16BIT);

  00916	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  0091c	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@40e0000000000000
  00924	e8 00 00 00 00	 call	 psf_round
  00929	66 89 44 24 48	 mov	 WORD PTR ssamp$2[rsp], ax
$LN81@psf_sndWri:

; 1869 : 					
; 1870 : 					if(wavDoWrite(sfdat,(char *) &ssamp,sizeof(short))){

  0092e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00934	48 8d 54 24 48	 lea	 rdx, QWORD PTR ssamp$2[rsp]
  00939	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0093e	e8 00 00 00 00	 call	 wavDoWrite
  00943	85 c0		 test	 eax, eax
  00945	74 0a		 je	 SHORT $LN82@psf_sndWri

; 1871 : 						DBGFPRINTF((stderr, "wavOpenWrite: write error\n"));
; 1872 : 						return PSF_E_CANT_WRITE;

  00947	b8 fd ff ff ff	 mov	 eax, -3
  0094c	e9 60 08 00 00	 jmp	 $LN1@psf_sndWri
$LN82@psf_sndWri:

; 1873 : 					}
; 1874 : 				}			

  00951	e9 39 fe ff ff	 jmp	 $LN27@psf_sndWri
$LN28@psf_sndWri:

; 1875 : 			}			

  00956	e9 f6 fd ff ff	 jmp	 $LN24@psf_sndWri
$LN25@psf_sndWri:
$LN74@psf_sndWri:

; 1876 : 		}
; 1877 : 		break;

  0095b	e9 d1 07 00 00	 jmp	 $LN4@psf_sndWri
$LN83@psf_sndWri:

; 1878 : 	case(PSF_SAMP_24):			 
; 1879 : 		if(do_reverse){				

  00960	83 7c 24 4c 00	 cmp	 DWORD PTR do_reverse$[rsp], 0
  00965	0f 84 1b 02 00
	00		 je	 $LN84@psf_sndWri

; 1880 : 			for(i=0; i < nFrames; i++){

  0096b	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00973	eb 0a		 jmp	 SHORT $LN32@psf_sndWri
$LN30@psf_sndWri:
  00975	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00979	ff c0		 inc	 eax
  0097b	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN32@psf_sndWri:
  0097f	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  00986	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  0098a	0f 83 f1 01 00
	00		 jae	 $LN31@psf_sndWri

; 1881 : 				for(j=0;j < chans; j++) {

  00990	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00998	eb 0a		 jmp	 SHORT $LN35@psf_sndWri
$LN33@psf_sndWri:
  0099a	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  0099e	ff c0		 inc	 eax
  009a0	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN35@psf_sndWri:
  009a4	8b 44 24 40	 mov	 eax, DWORD PTR chans$[rsp]
  009a8	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  009ac	0f 8d ca 01 00
	00		 jge	 $LN34@psf_sndWri

; 1882 : 					fsamp =(float)  *buf++;

  009b2	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  009ba	f2 0f 5a 00	 cvtsd2ss xmm0, QWORD PTR [rax]
  009be	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0
  009c4	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  009cc	48 83 c0 08	 add	 rax, 8
  009d0	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 1883 : 					/* clip now! we may have a flag to rescale first...one day */
; 1884 : 					fsamp = min(fsamp,1.0f);

  009d8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  009e0	0f 2f 44 24 20	 comiss	 xmm0, DWORD PTR fsamp$[rsp]
  009e5	76 11		 jbe	 SHORT $LN125@psf_sndWri
  009e7	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  009ed	f3 0f 11 84 24
	88 00 00 00	 movss	 DWORD PTR tv356[rsp], xmm0
  009f6	eb 11		 jmp	 SHORT $LN126@psf_sndWri
$LN125@psf_sndWri:
  009f8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00a00	f3 0f 11 84 24
	88 00 00 00	 movss	 DWORD PTR tv356[rsp], xmm0
$LN126@psf_sndWri:
  00a09	f3 0f 10 84 24
	88 00 00 00	 movss	 xmm0, DWORD PTR tv356[rsp]
  00a12	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1885 : 					fsamp = max(fsamp,-1.0f);

  00a18	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00a1e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@bf800000
  00a25	76 11		 jbe	 SHORT $LN127@psf_sndWri
  00a27	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00a2d	f3 0f 11 84 24
	8c 00 00 00	 movss	 DWORD PTR tv358[rsp], xmm0
  00a36	eb 11		 jmp	 SHORT $LN128@psf_sndWri
$LN127@psf_sndWri:
  00a38	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00a40	f3 0f 11 84 24
	8c 00 00 00	 movss	 DWORD PTR tv358[rsp], xmm0
$LN128@psf_sndWri:
  00a49	f3 0f 10 84 24
	8c 00 00 00	 movss	 xmm0, DWORD PTR tv358[rsp]
  00a52	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1886 : 					absfsamp = (float) fabs((double)fsamp);

  00a58	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  00a5e	e8 00 00 00 00	 call	 fabs
  00a63	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00a67	f3 0f 11 44 24
	3c		 movss	 DWORD PTR absfsamp$[rsp], xmm0

; 1887 : 					if(sfdat->pPeaks && (sfdat->pPeaks[j].val < absfsamp)){

  00a6d	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00a72	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00a7a	74 5a		 je	 SHORT $LN86@psf_sndWri
  00a7c	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  00a81	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00a86	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00a8d	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  00a93	0f 2f 04 c1	 comiss	 xmm0, DWORD PTR [rcx+rax*8]
  00a97	76 3d		 jbe	 SHORT $LN86@psf_sndWri

; 1888 : 						sfdat->pPeaks[j].pos = sfdat->nFrames + i;

  00a99	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00a9e	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00aa1	03 44 24 28	 add	 eax, DWORD PTR i$[rsp]
  00aa5	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  00aaa	48 8b 54 24 30	 mov	 rdx, QWORD PTR sfdat$[rsp]
  00aaf	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  00ab6	89 44 ca 04	 mov	 DWORD PTR [rdx+rcx*8+4], eax

; 1889 : 						sfdat->pPeaks[j].val = absfsamp;

  00aba	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  00abf	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00ac4	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00acb	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  00ad1	f3 0f 11 04 c1	 movss	 DWORD PTR [rcx+rax*8], xmm0
$LN86@psf_sndWri:

; 1890 : 					}
; 1891 : 					lsamp = psf_round(fsamp * MAX_32BIT);					

  00ad6	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  00adc	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@41e0000000000000
  00ae4	e8 00 00 00 00	 call	 psf_round
  00ae9	89 44 24 38	 mov	 DWORD PTR lsamp$[rsp], eax

; 1892 : 					lsamp = REVDWBYTES(lsamp);

  00aed	8b 44 24 38	 mov	 eax, DWORD PTR lsamp$[rsp]
  00af1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00af6	c1 e0 18	 shl	 eax, 24
  00af9	8b 4c 24 38	 mov	 ecx, DWORD PTR lsamp$[rsp]
  00afd	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00b03	c1 e1 08	 shl	 ecx, 8
  00b06	0b c1		 or	 eax, ecx
  00b08	8b 4c 24 38	 mov	 ecx, DWORD PTR lsamp$[rsp]
  00b0c	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00b12	c1 f9 08	 sar	 ecx, 8
  00b15	0b c1		 or	 eax, ecx
  00b17	8b 4c 24 38	 mov	 ecx, DWORD PTR lsamp$[rsp]
  00b1b	c1 f9 18	 sar	 ecx, 24
  00b1e	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00b24	0b c1		 or	 eax, ecx
  00b26	89 44 24 38	 mov	 DWORD PTR lsamp$[rsp], eax

; 1893 :                     if(do_shift){

  00b2a	83 7c 24 58 00	 cmp	 DWORD PTR do_shift$[rsp], 0
  00b2f	74 23		 je	 SHORT $LN87@psf_sndWri

; 1894 : 						if(sfdat->is_little_endian)

  00b31	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00b36	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00b3a	74 0d		 je	 SHORT $LN88@psf_sndWri

; 1895 : 							lsamp >>= 8;

  00b3c	8b 44 24 38	 mov	 eax, DWORD PTR lsamp$[rsp]
  00b40	c1 f8 08	 sar	 eax, 8
  00b43	89 44 24 38	 mov	 DWORD PTR lsamp$[rsp], eax
  00b47	eb 0b		 jmp	 SHORT $LN89@psf_sndWri
$LN88@psf_sndWri:

; 1896 : 						else
; 1897 : 							lsamp <<= 8;

  00b49	8b 44 24 38	 mov	 eax, DWORD PTR lsamp$[rsp]
  00b4d	c1 e0 08	 shl	 eax, 8
  00b50	89 44 24 38	 mov	 DWORD PTR lsamp$[rsp], eax
$LN89@psf_sndWri:
$LN87@psf_sndWri:

; 1898 : 					}
; 1899 : 					if( wavDoWrite(sfdat,(char *) &lsamp,3)){

  00b54	41 b8 03 00 00
	00		 mov	 r8d, 3
  00b5a	48 8d 54 24 38	 lea	 rdx, QWORD PTR lsamp$[rsp]
  00b5f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00b64	e8 00 00 00 00	 call	 wavDoWrite
  00b69	85 c0		 test	 eax, eax
  00b6b	74 0a		 je	 SHORT $LN90@psf_sndWri

; 1900 : 						DBGFPRINTF((stderr, "wavOpenWrite: write error\n"));
; 1901 : 						return PSF_E_CANT_WRITE;

  00b6d	b8 fd ff ff ff	 mov	 eax, -3
  00b72	e9 3a 06 00 00	 jmp	 $LN1@psf_sndWri
$LN90@psf_sndWri:

; 1902 : 					}
; 1903 : 				}			

  00b77	e9 1e fe ff ff	 jmp	 $LN33@psf_sndWri
$LN34@psf_sndWri:

; 1904 : 			}

  00b7c	e9 f4 fd ff ff	 jmp	 $LN30@psf_sndWri
$LN31@psf_sndWri:

; 1905 : 		}

  00b81	e9 e4 01 00 00	 jmp	 $LN85@psf_sndWri
$LN84@psf_sndWri:

; 1906 : 		else {			
; 1907 : 			for(i=0; i < nFrames; i++, buf += chans){

  00b86	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00b8e	eb 23		 jmp	 SHORT $LN38@psf_sndWri
$LN36@psf_sndWri:
  00b90	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00b94	ff c0		 inc	 eax
  00b96	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
  00b9a	48 63 44 24 40	 movsxd	 rax, DWORD PTR chans$[rsp]
  00b9f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00ba7	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00bab	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax
$LN38@psf_sndWri:
  00bb3	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  00bba	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00bbe	0f 83 a6 01 00
	00		 jae	 $LN37@psf_sndWri

; 1908 : 				for(j=0;j < chans; j++) {					 

  00bc4	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00bcc	eb 0a		 jmp	 SHORT $LN41@psf_sndWri
$LN39@psf_sndWri:
  00bce	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  00bd2	ff c0		 inc	 eax
  00bd4	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN41@psf_sndWri:
  00bd8	8b 44 24 40	 mov	 eax, DWORD PTR chans$[rsp]
  00bdc	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  00be0	0f 8d 7f 01 00
	00		 jge	 $LN40@psf_sndWri

; 1909 : 					fsamp = (float)  buf[j];

  00be6	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  00beb	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00bf3	f2 0f 5a 04 c1	 cvtsd2ss xmm0, QWORD PTR [rcx+rax*8]
  00bf8	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1910 : 					/* clip now! we may have a flag to rescale first...one day */
; 1911 : 					fsamp = min(fsamp,1.0f);

  00bfe	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00c06	0f 2f 44 24 20	 comiss	 xmm0, DWORD PTR fsamp$[rsp]
  00c0b	76 11		 jbe	 SHORT $LN129@psf_sndWri
  00c0d	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00c13	f3 0f 11 84 24
	90 00 00 00	 movss	 DWORD PTR tv420[rsp], xmm0
  00c1c	eb 11		 jmp	 SHORT $LN130@psf_sndWri
$LN129@psf_sndWri:
  00c1e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00c26	f3 0f 11 84 24
	90 00 00 00	 movss	 DWORD PTR tv420[rsp], xmm0
$LN130@psf_sndWri:
  00c2f	f3 0f 10 84 24
	90 00 00 00	 movss	 xmm0, DWORD PTR tv420[rsp]
  00c38	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1912 : 					fsamp = max(fsamp,-1.0f);

  00c3e	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00c44	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@bf800000
  00c4b	76 11		 jbe	 SHORT $LN131@psf_sndWri
  00c4d	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00c53	f3 0f 11 84 24
	94 00 00 00	 movss	 DWORD PTR tv422[rsp], xmm0
  00c5c	eb 11		 jmp	 SHORT $LN132@psf_sndWri
$LN131@psf_sndWri:
  00c5e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00c66	f3 0f 11 84 24
	94 00 00 00	 movss	 DWORD PTR tv422[rsp], xmm0
$LN132@psf_sndWri:
  00c6f	f3 0f 10 84 24
	94 00 00 00	 movss	 xmm0, DWORD PTR tv422[rsp]
  00c78	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1913 : 					absfsamp = (float) fabs((double)fsamp);

  00c7e	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  00c84	e8 00 00 00 00	 call	 fabs
  00c89	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00c8d	f3 0f 11 44 24
	3c		 movss	 DWORD PTR absfsamp$[rsp], xmm0

; 1914 : 					if(sfdat->pPeaks && (sfdat->pPeaks[j].val < absfsamp)){

  00c93	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00c98	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00ca0	74 5a		 je	 SHORT $LN91@psf_sndWri
  00ca2	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  00ca7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00cac	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00cb3	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  00cb9	0f 2f 04 c1	 comiss	 xmm0, DWORD PTR [rcx+rax*8]
  00cbd	76 3d		 jbe	 SHORT $LN91@psf_sndWri

; 1915 : 						sfdat->pPeaks[j].pos = sfdat->nFrames + i;

  00cbf	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00cc4	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00cc7	03 44 24 28	 add	 eax, DWORD PTR i$[rsp]
  00ccb	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  00cd0	48 8b 54 24 30	 mov	 rdx, QWORD PTR sfdat$[rsp]
  00cd5	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  00cdc	89 44 ca 04	 mov	 DWORD PTR [rdx+rcx*8+4], eax

; 1916 : 						sfdat->pPeaks[j].val = absfsamp;

  00ce0	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  00ce5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00cea	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00cf1	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  00cf7	f3 0f 11 04 c1	 movss	 DWORD PTR [rcx+rax*8], xmm0
$LN91@psf_sndWri:

; 1917 : 					}
; 1918 : 					lsamp = psf_round(fsamp * MAX_32BIT);

  00cfc	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  00d02	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@41e0000000000000
  00d0a	e8 00 00 00 00	 call	 psf_round
  00d0f	89 44 24 38	 mov	 DWORD PTR lsamp$[rsp], eax

; 1919 : 					if(do_shift){

  00d13	83 7c 24 58 00	 cmp	 DWORD PTR do_shift$[rsp], 0
  00d18	74 23		 je	 SHORT $LN92@psf_sndWri

; 1920 : 						if(sfdat->is_little_endian)

  00d1a	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00d1f	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00d23	74 0d		 je	 SHORT $LN93@psf_sndWri

; 1921 : 							lsamp >>= 8;

  00d25	8b 44 24 38	 mov	 eax, DWORD PTR lsamp$[rsp]
  00d29	c1 f8 08	 sar	 eax, 8
  00d2c	89 44 24 38	 mov	 DWORD PTR lsamp$[rsp], eax
  00d30	eb 0b		 jmp	 SHORT $LN94@psf_sndWri
$LN93@psf_sndWri:

; 1922 : 						else
; 1923 : 							lsamp <<= 8;

  00d32	8b 44 24 38	 mov	 eax, DWORD PTR lsamp$[rsp]
  00d36	c1 e0 08	 shl	 eax, 8
  00d39	89 44 24 38	 mov	 DWORD PTR lsamp$[rsp], eax
$LN94@psf_sndWri:
$LN92@psf_sndWri:

; 1924 : 					}
; 1925 : 					if(wavDoWrite(sfdat,(char *) &lsamp,3)){

  00d3d	41 b8 03 00 00
	00		 mov	 r8d, 3
  00d43	48 8d 54 24 38	 lea	 rdx, QWORD PTR lsamp$[rsp]
  00d48	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00d4d	e8 00 00 00 00	 call	 wavDoWrite
  00d52	85 c0		 test	 eax, eax
  00d54	74 0a		 je	 SHORT $LN95@psf_sndWri

; 1926 : 						DBGFPRINTF((stderr, "wavOpenWrite: write error\n"));
; 1927 : 						return PSF_E_CANT_WRITE;

  00d56	b8 fd ff ff ff	 mov	 eax, -3
  00d5b	e9 51 04 00 00	 jmp	 $LN1@psf_sndWri
$LN95@psf_sndWri:

; 1928 : 					}
; 1929 : 				}				

  00d60	e9 69 fe ff ff	 jmp	 $LN39@psf_sndWri
$LN40@psf_sndWri:

; 1930 : 			}			

  00d65	e9 26 fe ff ff	 jmp	 $LN36@psf_sndWri
$LN37@psf_sndWri:
$LN85@psf_sndWri:

; 1931 : 		}
; 1932 : 		break;

  00d6a	e9 c2 03 00 00	 jmp	 $LN4@psf_sndWri
$LN96@psf_sndWri:

; 1933 : 	case(PSF_SAMP_32):
; 1934 : 		if(do_reverse){				

  00d6f	83 7c 24 4c 00	 cmp	 DWORD PTR do_reverse$[rsp], 0
  00d74	0f 84 f1 01 00
	00		 je	 $LN97@psf_sndWri

; 1935 : 			for(i=0; i < nFrames; i++){

  00d7a	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00d82	eb 0a		 jmp	 SHORT $LN44@psf_sndWri
$LN42@psf_sndWri:
  00d84	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00d88	ff c0		 inc	 eax
  00d8a	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN44@psf_sndWri:
  00d8e	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  00d95	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00d99	0f 83 c7 01 00
	00		 jae	 $LN43@psf_sndWri

; 1936 : 				for(j=0;j < chans; j++) {

  00d9f	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00da7	eb 0a		 jmp	 SHORT $LN47@psf_sndWri
$LN45@psf_sndWri:
  00da9	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  00dad	ff c0		 inc	 eax
  00daf	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN47@psf_sndWri:
  00db3	8b 44 24 40	 mov	 eax, DWORD PTR chans$[rsp]
  00db7	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  00dbb	0f 8d a0 01 00
	00		 jge	 $LN46@psf_sndWri

; 1937 : 					fsamp = (float) *buf++;

  00dc1	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00dc9	f2 0f 5a 00	 cvtsd2ss xmm0, QWORD PTR [rax]
  00dcd	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0
  00dd3	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00ddb	48 83 c0 08	 add	 rax, 8
  00ddf	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 1938 : 					/* clip now! we may have a flag to rescale first...one day */
; 1939 : 					fsamp = min(fsamp,1.0f);

  00de7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00def	0f 2f 44 24 20	 comiss	 xmm0, DWORD PTR fsamp$[rsp]
  00df4	76 11		 jbe	 SHORT $LN133@psf_sndWri
  00df6	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00dfc	f3 0f 11 84 24
	98 00 00 00	 movss	 DWORD PTR tv469[rsp], xmm0
  00e05	eb 11		 jmp	 SHORT $LN134@psf_sndWri
$LN133@psf_sndWri:
  00e07	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00e0f	f3 0f 11 84 24
	98 00 00 00	 movss	 DWORD PTR tv469[rsp], xmm0
$LN134@psf_sndWri:
  00e18	f3 0f 10 84 24
	98 00 00 00	 movss	 xmm0, DWORD PTR tv469[rsp]
  00e21	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1940 : 					fsamp = max(fsamp,-1.0f);

  00e27	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00e2d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@bf800000
  00e34	76 11		 jbe	 SHORT $LN135@psf_sndWri
  00e36	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00e3c	f3 0f 11 84 24
	9c 00 00 00	 movss	 DWORD PTR tv471[rsp], xmm0
  00e45	eb 11		 jmp	 SHORT $LN136@psf_sndWri
$LN135@psf_sndWri:
  00e47	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00e4f	f3 0f 11 84 24
	9c 00 00 00	 movss	 DWORD PTR tv471[rsp], xmm0
$LN136@psf_sndWri:
  00e58	f3 0f 10 84 24
	9c 00 00 00	 movss	 xmm0, DWORD PTR tv471[rsp]
  00e61	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1941 : 					absfsamp = (float) fabs((double)fsamp);

  00e67	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  00e6d	e8 00 00 00 00	 call	 fabs
  00e72	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00e76	f3 0f 11 44 24
	3c		 movss	 DWORD PTR absfsamp$[rsp], xmm0

; 1942 : 					if(sfdat->pPeaks && (sfdat->pPeaks[j].val < absfsamp)){

  00e7c	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00e81	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00e89	74 5a		 je	 SHORT $LN99@psf_sndWri
  00e8b	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  00e90	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00e95	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00e9c	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  00ea2	0f 2f 04 c1	 comiss	 xmm0, DWORD PTR [rcx+rax*8]
  00ea6	76 3d		 jbe	 SHORT $LN99@psf_sndWri

; 1943 : 						sfdat->pPeaks[j].pos = sfdat->nFrames + i;

  00ea8	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00ead	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00eb0	03 44 24 28	 add	 eax, DWORD PTR i$[rsp]
  00eb4	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  00eb9	48 8b 54 24 30	 mov	 rdx, QWORD PTR sfdat$[rsp]
  00ebe	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  00ec5	89 44 ca 04	 mov	 DWORD PTR [rdx+rcx*8+4], eax

; 1944 : 						sfdat->pPeaks[j].val = absfsamp;

  00ec9	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  00ece	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00ed3	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00eda	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  00ee0	f3 0f 11 04 c1	 movss	 DWORD PTR [rcx+rax*8], xmm0
$LN99@psf_sndWri:

; 1945 : 					}
; 1946 : 					lsamp = psf_round(fsamp * MAX_32BIT);					

  00ee5	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  00eeb	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@41e0000000000000
  00ef3	e8 00 00 00 00	 call	 psf_round
  00ef8	89 44 24 38	 mov	 DWORD PTR lsamp$[rsp], eax

; 1947 : 					lsamp = REVDWBYTES(lsamp);

  00efc	8b 44 24 38	 mov	 eax, DWORD PTR lsamp$[rsp]
  00f00	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00f05	c1 e0 18	 shl	 eax, 24
  00f08	8b 4c 24 38	 mov	 ecx, DWORD PTR lsamp$[rsp]
  00f0c	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00f12	c1 e1 08	 shl	 ecx, 8
  00f15	0b c1		 or	 eax, ecx
  00f17	8b 4c 24 38	 mov	 ecx, DWORD PTR lsamp$[rsp]
  00f1b	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00f21	c1 f9 08	 sar	 ecx, 8
  00f24	0b c1		 or	 eax, ecx
  00f26	8b 4c 24 38	 mov	 ecx, DWORD PTR lsamp$[rsp]
  00f2a	c1 f9 18	 sar	 ecx, 24
  00f2d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00f33	0b c1		 or	 eax, ecx
  00f35	89 44 24 38	 mov	 DWORD PTR lsamp$[rsp], eax

; 1948 : 					if( wavDoWrite(sfdat,(char *) &lsamp,sizeof(int))){

  00f39	41 b8 04 00 00
	00		 mov	 r8d, 4
  00f3f	48 8d 54 24 38	 lea	 rdx, QWORD PTR lsamp$[rsp]
  00f44	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00f49	e8 00 00 00 00	 call	 wavDoWrite
  00f4e	85 c0		 test	 eax, eax
  00f50	74 0a		 je	 SHORT $LN100@psf_sndWri

; 1949 : 						DBGFPRINTF((stderr, "wavOpenWrite: write error\n"));
; 1950 : 						return PSF_E_CANT_WRITE;

  00f52	b8 fd ff ff ff	 mov	 eax, -3
  00f57	e9 55 02 00 00	 jmp	 $LN1@psf_sndWri
$LN100@psf_sndWri:

; 1951 : 					}
; 1952 : 				}		

  00f5c	e9 48 fe ff ff	 jmp	 $LN45@psf_sndWri
$LN46@psf_sndWri:

; 1953 : 			}

  00f61	e9 1e fe ff ff	 jmp	 $LN42@psf_sndWri
$LN43@psf_sndWri:

; 1954 : 		}

  00f66	e9 ba 01 00 00	 jmp	 $LN98@psf_sndWri
$LN97@psf_sndWri:

; 1955 : 		else {			
; 1956 : 			for(i=0; i < nFrames; i++, buf += chans){

  00f6b	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00f73	eb 23		 jmp	 SHORT $LN50@psf_sndWri
$LN48@psf_sndWri:
  00f75	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00f79	ff c0		 inc	 eax
  00f7b	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
  00f7f	48 63 44 24 40	 movsxd	 rax, DWORD PTR chans$[rsp]
  00f84	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00f8c	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00f90	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax
$LN50@psf_sndWri:
  00f98	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  00f9f	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00fa3	0f 83 7c 01 00
	00		 jae	 $LN49@psf_sndWri

; 1957 : 				for(j=0;j < chans; j++) {					 

  00fa9	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00fb1	eb 0a		 jmp	 SHORT $LN53@psf_sndWri
$LN51@psf_sndWri:
  00fb3	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  00fb7	ff c0		 inc	 eax
  00fb9	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN53@psf_sndWri:
  00fbd	8b 44 24 40	 mov	 eax, DWORD PTR chans$[rsp]
  00fc1	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  00fc5	0f 8d 55 01 00
	00		 jge	 $LN52@psf_sndWri

; 1958 : 					fsamp = (float) buf[j];

  00fcb	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  00fd0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00fd8	f2 0f 5a 04 c1	 cvtsd2ss xmm0, QWORD PTR [rcx+rax*8]
  00fdd	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1959 : 					/* clip now! we may have a flag to rescale first...one day */
; 1960 : 					fsamp = min(fsamp,1.0f);

  00fe3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00feb	0f 2f 44 24 20	 comiss	 xmm0, DWORD PTR fsamp$[rsp]
  00ff0	76 11		 jbe	 SHORT $LN137@psf_sndWri
  00ff2	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00ff8	f3 0f 11 84 24
	a0 00 00 00	 movss	 DWORD PTR tv528[rsp], xmm0
  01001	eb 11		 jmp	 SHORT $LN138@psf_sndWri
$LN137@psf_sndWri:
  01003	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0100b	f3 0f 11 84 24
	a0 00 00 00	 movss	 DWORD PTR tv528[rsp], xmm0
$LN138@psf_sndWri:
  01014	f3 0f 10 84 24
	a0 00 00 00	 movss	 xmm0, DWORD PTR tv528[rsp]
  0101d	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1961 : 					fsamp = max(fsamp,-1.0f);

  01023	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  01029	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@bf800000
  01030	76 11		 jbe	 SHORT $LN139@psf_sndWri
  01032	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  01038	f3 0f 11 84 24
	a4 00 00 00	 movss	 DWORD PTR tv530[rsp], xmm0
  01041	eb 11		 jmp	 SHORT $LN140@psf_sndWri
$LN139@psf_sndWri:
  01043	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0104b	f3 0f 11 84 24
	a4 00 00 00	 movss	 DWORD PTR tv530[rsp], xmm0
$LN140@psf_sndWri:
  01054	f3 0f 10 84 24
	a4 00 00 00	 movss	 xmm0, DWORD PTR tv530[rsp]
  0105d	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1962 : 					absfsamp = (float) fabs((double)fsamp);

  01063	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  01069	e8 00 00 00 00	 call	 fabs
  0106e	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  01072	f3 0f 11 44 24
	3c		 movss	 DWORD PTR absfsamp$[rsp], xmm0

; 1963 : 					if(sfdat->pPeaks && (sfdat->pPeaks[j].val < absfsamp)){

  01078	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  0107d	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  01085	74 5a		 je	 SHORT $LN101@psf_sndWri
  01087	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  0108c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  01091	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  01098	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  0109e	0f 2f 04 c1	 comiss	 xmm0, DWORD PTR [rcx+rax*8]
  010a2	76 3d		 jbe	 SHORT $LN101@psf_sndWri

; 1964 : 						sfdat->pPeaks[j].pos = sfdat->nFrames + i;

  010a4	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  010a9	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  010ac	03 44 24 28	 add	 eax, DWORD PTR i$[rsp]
  010b0	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  010b5	48 8b 54 24 30	 mov	 rdx, QWORD PTR sfdat$[rsp]
  010ba	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  010c1	89 44 ca 04	 mov	 DWORD PTR [rdx+rcx*8+4], eax

; 1965 : 						sfdat->pPeaks[j].val = absfsamp;

  010c5	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  010ca	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  010cf	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  010d6	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  010dc	f3 0f 11 04 c1	 movss	 DWORD PTR [rcx+rax*8], xmm0
$LN101@psf_sndWri:

; 1966 : 					}
; 1967 : 					lsamp = psf_round(fsamp * MAX_32BIT);

  010e1	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  010e7	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@41e0000000000000
  010ef	e8 00 00 00 00	 call	 psf_round
  010f4	89 44 24 38	 mov	 DWORD PTR lsamp$[rsp], eax

; 1968 : 					
; 1969 : 					if(wavDoWrite(sfdat,(char *) &lsamp,sizeof(int))){

  010f8	41 b8 04 00 00
	00		 mov	 r8d, 4
  010fe	48 8d 54 24 38	 lea	 rdx, QWORD PTR lsamp$[rsp]
  01103	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  01108	e8 00 00 00 00	 call	 wavDoWrite
  0110d	85 c0		 test	 eax, eax
  0110f	74 0a		 je	 SHORT $LN102@psf_sndWri

; 1970 : 						DBGFPRINTF((stderr, "wavOpenWrite: write error\n"));
; 1971 : 						return PSF_E_CANT_WRITE;

  01111	b8 fd ff ff ff	 mov	 eax, -3
  01116	e9 96 00 00 00	 jmp	 $LN1@psf_sndWri
$LN102@psf_sndWri:

; 1972 : 					}
; 1973 : 				}			

  0111b	e9 93 fe ff ff	 jmp	 $LN51@psf_sndWri
$LN52@psf_sndWri:

; 1974 : 			}			

  01120	e9 50 fe ff ff	 jmp	 $LN48@psf_sndWri
$LN49@psf_sndWri:
$LN98@psf_sndWri:

; 1975 : 		}
; 1976 : 		break;

  01125	eb 0a		 jmp	 SHORT $LN4@psf_sndWri
$LN103@psf_sndWri:

; 1977 : 	default:
; 1978 : 		DBGFPRINTF((stderr, "wavOpenWrite: unsupported sample format\n"));
; 1979 : 		return PSF_E_UNSUPPORTED;		

  01127	b8 f8 ff ff ff	 mov	 eax, -8
  0112c	e9 80 00 00 00	 jmp	 $LN1@psf_sndWri
$LN4@psf_sndWri:

; 1980 : 
; 1981 : 	}
; 1982 : 	POS64(sfdat->lastwritepos) += nFrames;

  01131	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  01138	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0113d	48 03 81 90 00
	00 00		 add	 rax, QWORD PTR [rcx+144]
  01144	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  01149	48 89 81 90 00
	00 00		 mov	 QWORD PTR [rcx+144], rax

; 1983 :     /* keep this as is for now, don't optimize, work in progress, etc */
; 1984 : 	sfdat->curframepos =  (DWORD) POS64(sfdat->lastwritepos);

  01150	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  01155	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0115a	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  01160	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 1985 : 	sfdat->nFrames = max(sfdat->nFrames, ((DWORD) POS64(sfdat->lastwritepos)));

  01163	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  01168	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0116d	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  01173	39 48 14	 cmp	 DWORD PTR [rax+20], ecx
  01176	76 11		 jbe	 SHORT $LN141@psf_sndWri
  01178	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  0117d	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  01180	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv580[rsp], eax
  01187	eb 12		 jmp	 SHORT $LN142@psf_sndWri
$LN141@psf_sndWri:
  01189	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  0118e	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  01194	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv580[rsp], eax
$LN142@psf_sndWri:
  0119b	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  011a0	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv580[rsp]
  011a7	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 1986 : /*	fflush(sfdat->file);*/	/* ? need this if reading/seeking as well as  write, etc */
; 1987 : 	return nFrames; 

  011aa	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
$LN1@psf_sndWri:

; 1988 : 		
; 1989 : }

  011b1	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  011b8	c3		 ret	 0
psf_sndWriteDoubleFrames ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
fsamp$ = 32
j$ = 36
i$ = 40
sfdat$ = 48
lsamp$ = 56
absfsamp$ = 60
chans$ = 64
ssamp$1 = 68
ssamp$2 = 72
do_reverse$ = 76
tv76 = 80
tv92 = 84
do_shift$ = 88
pbuf$ = 96
tv133 = 104
tv135 = 108
tv190 = 112
tv192 = 116
tv233 = 120
tv235 = 124
tv300 = 128
tv302 = 132
tv355 = 136
tv357 = 140
tv418 = 144
tv420 = 148
tv466 = 152
tv468 = 156
tv524 = 160
tv526 = 164
tv576 = 168
tv79 = 172
tv82 = 176
tv264 = 184
tv331 = 192
sfd$ = 224
buf$ = 232
nFrames$ = 240
psf_sndWriteFloatFrames PROC

; 1485 : {

$LN143:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 1486 : 	int chans,lsamp;	
; 1487 : 	DWORD i;
; 1488 : 	int j,do_reverse;
; 1489 : 	const float *pbuf = buf;

  00015	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0001d	48 89 44 24 60	 mov	 QWORD PTR pbuf$[rsp], rax

; 1490 : 	float fsamp,absfsamp;
; 1491 :     int do_shift = 1;

  00022	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR do_shift$[rsp], 1

; 1492 : 	PSFFILE *sfdat;
; 1493 : 
; 1494 : 	if(sfd < 0 || sfd > psf_maxfiles)

  0002a	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR sfd$[rsp], 0
  00032	7c 0a		 jl	 SHORT $LN55@psf_sndWri
  00034	83 bc 24 e0 00
	00 00 40	 cmp	 DWORD PTR sfd$[rsp], 64	; 00000040H
  0003c	7e 0a		 jle	 SHORT $LN54@psf_sndWri
$LN55@psf_sndWri:

; 1495 : 		return PSF_E_BADARG;

  0003e	b8 f6 ff ff ff	 mov	 eax, -10
  00043	e9 7e 11 00 00	 jmp	 $LN1@psf_sndWri
$LN54@psf_sndWri:

; 1496 : 	
; 1497 : 	sfdat  = psf_files[sfd];

  00048	48 63 84 24 e0
	00 00 00	 movsxd	 rax, DWORD PTR sfd$[rsp]
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:psf_files
  00057	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0005b	48 89 44 24 30	 mov	 QWORD PTR sfdat$[rsp], rax

; 1498 : 	
; 1499 : #ifdef _DEBUG		
; 1500 : 	assert(sfdat->file);
; 1501 : 	assert(sfdat->filename);	
; 1502 : #endif
; 1503 : 
; 1504 : 	if(buf==NULL)

  00060	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  00069	75 0a		 jne	 SHORT $LN56@psf_sndWri

; 1505 : 		return PSF_E_BADARG;

  0006b	b8 f6 ff ff ff	 mov	 eax, -10
  00070	e9 51 11 00 00	 jmp	 $LN1@psf_sndWri
$LN56@psf_sndWri:

; 1506 : 	if(nFrames == 0)

  00075	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR nFrames$[rsp], 0
  0007d	75 0c		 jne	 SHORT $LN57@psf_sndWri

; 1507 : 		return nFrames;

  0007f	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  00086	e9 3b 11 00 00	 jmp	 $LN1@psf_sndWri
$LN57@psf_sndWri:

; 1508 : 	if(sfdat->isRead)

  0008b	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00090	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00094	74 0a		 je	 SHORT $LN58@psf_sndWri

; 1509 : 		return PSF_E_FILE_READONLY;

  00096	b8 f3 ff ff ff	 mov	 eax, -13
  0009b	e9 26 11 00 00	 jmp	 $LN1@psf_sndWri
$LN58@psf_sndWri:

; 1510 : 	chans = sfdat->fmt.Format.nChannels;

  000a0	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  000a5	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  000a9	89 44 24 40	 mov	 DWORD PTR chans$[rsp], eax

; 1511 : 	
; 1512 : 	switch(sfdat->riff_format){

  000ad	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  000b2	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  000b5	89 44 24 50	 mov	 DWORD PTR tv76[rsp], eax
  000b9	83 7c 24 50 00	 cmp	 DWORD PTR tv76[rsp], 0
  000be	0f 8e 87 00 00
	00		 jle	 $LN61@psf_sndWri
  000c4	83 7c 24 50 02	 cmp	 DWORD PTR tv76[rsp], 2
  000c9	7e 10		 jle	 SHORT $LN59@psf_sndWri
  000cb	83 7c 24 50 02	 cmp	 DWORD PTR tv76[rsp], 2
  000d0	7e 79		 jle	 SHORT $LN61@psf_sndWri
  000d2	83 7c 24 50 04	 cmp	 DWORD PTR tv76[rsp], 4
  000d7	7e 3a		 jle	 SHORT $LN60@psf_sndWri
  000d9	eb 70		 jmp	 SHORT $LN61@psf_sndWri
$LN59@psf_sndWri:

; 1513 : 	case(PSF_STDWAVE):
; 1514 : 	case(PSF_WAVE_EX):
; 1515 : 		do_reverse = (sfdat->is_little_endian ? 0 : 1 );

  000db	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  000e0	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  000e4	74 0d		 je	 SHORT $LN105@psf_sndWri
  000e6	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv79[rsp], 0
  000f1	eb 0b		 jmp	 SHORT $LN106@psf_sndWri
$LN105@psf_sndWri:
  000f3	c7 84 24 ac 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv79[rsp], 1
$LN106@psf_sndWri:
  000fe	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR tv79[rsp]
  00105	89 44 24 4c	 mov	 DWORD PTR do_reverse$[rsp], eax

; 1516 :         do_shift = 1;

  00109	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR do_shift$[rsp], 1

; 1517 : 		break;

  00111	eb 42		 jmp	 SHORT $LN2@psf_sndWri
$LN60@psf_sndWri:

; 1518 : 	case(PSF_AIFF):
; 1519 : 	case(PSF_AIFC):
; 1520 : 		do_reverse = (sfdat->is_little_endian ? 1 : 0 );

  00113	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00118	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0011c	74 0d		 je	 SHORT $LN107@psf_sndWri
  0011e	c7 84 24 b0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv82[rsp], 1
  00129	eb 0b		 jmp	 SHORT $LN108@psf_sndWri
$LN107@psf_sndWri:
  0012b	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv82[rsp], 0
$LN108@psf_sndWri:
  00136	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv82[rsp]
  0013d	89 44 24 4c	 mov	 DWORD PTR do_reverse$[rsp], eax

; 1521 :         do_shift = 0;

  00141	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR do_shift$[rsp], 0

; 1522 : 		break;

  00149	eb 0a		 jmp	 SHORT $LN2@psf_sndWri
$LN61@psf_sndWri:

; 1523 : 	default:
; 1524 : 		return PSF_E_UNSUPPORTED;

  0014b	b8 f8 ff ff ff	 mov	 eax, -8
  00150	e9 71 10 00 00	 jmp	 $LN1@psf_sndWri
$LN2@psf_sndWri:

; 1525 : 	}
; 1526 : 	if(sfdat->lastop  == PSF_OP_READ)

  00155	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  0015a	83 b8 98 00 00
	00 00		 cmp	 DWORD PTR [rax+152], 0
  00161	75 0d		 jne	 SHORT $LN62@psf_sndWri

; 1527 : 		fflush(sfdat->file);

  00163	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00168	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0016b	e8 00 00 00 00	 call	 fflush
$LN62@psf_sndWri:

; 1528 : 	switch(sfdat->samptype){

  00170	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00175	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00178	89 44 24 54	 mov	 DWORD PTR tv92[rsp], eax
  0017c	83 7c 24 54 02	 cmp	 DWORD PTR tv92[rsp], 2
  00181	0f 84 ac 03 00
	00		 je	 $LN72@psf_sndWri
  00187	83 7c 24 54 03	 cmp	 DWORD PTR tv92[rsp], 3
  0018c	0f 84 e3 07 00
	00		 je	 $LN83@psf_sndWri
  00192	83 7c 24 54 04	 cmp	 DWORD PTR tv92[rsp], 4
  00197	0f 84 e7 0b 00
	00		 je	 $LN96@psf_sndWri
  0019d	83 7c 24 54 05	 cmp	 DWORD PTR tv92[rsp], 5
  001a2	74 05		 je	 SHORT $LN63@psf_sndWri
  001a4	e9 93 0f 00 00	 jmp	 $LN103@psf_sndWri
$LN63@psf_sndWri:

; 1529 : 	case(PSF_SAMP_IEEE_FLOAT):		
; 1530 : 		if(do_reverse){				

  001a9	83 7c 24 4c 00	 cmp	 DWORD PTR do_reverse$[rsp], 0
  001ae	0f 84 d5 01 00
	00		 je	 $LN64@psf_sndWri

; 1531 : 			for(i=0; i < nFrames; i++){

  001b4	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001bc	eb 0a		 jmp	 SHORT $LN8@psf_sndWri
$LN6@psf_sndWri:
  001be	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  001c2	ff c0		 inc	 eax
  001c4	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN8@psf_sndWri:
  001c8	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  001cf	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  001d3	0f 83 ab 01 00
	00		 jae	 $LN7@psf_sndWri

; 1532 : 				for(j=0;j < chans; j++) {

  001d9	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  001e1	eb 0a		 jmp	 SHORT $LN11@psf_sndWri
$LN9@psf_sndWri:
  001e3	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  001e7	ff c0		 inc	 eax
  001e9	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN11@psf_sndWri:
  001ed	8b 44 24 40	 mov	 eax, DWORD PTR chans$[rsp]
  001f1	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  001f5	0f 8d 84 01 00
	00		 jge	 $LN10@psf_sndWri

; 1533 : 					fsamp = *pbuf;

  001fb	48 8b 44 24 60	 mov	 rax, QWORD PTR pbuf$[rsp]
  00200	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00204	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1534 : 					if(sfdat->clip_floats){

  0020a	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  0020f	83 78 1c 00	 cmp	 DWORD PTR [rax+28], 0
  00213	74 6e		 je	 SHORT $LN66@psf_sndWri

; 1535 : 						fsamp = min(fsamp,1.0f);

  00215	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0021d	0f 2f 44 24 20	 comiss	 xmm0, DWORD PTR fsamp$[rsp]
  00222	76 0e		 jbe	 SHORT $LN109@psf_sndWri
  00224	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  0022a	f3 0f 11 44 24
	68		 movss	 DWORD PTR tv133[rsp], xmm0
  00230	eb 0e		 jmp	 SHORT $LN110@psf_sndWri
$LN109@psf_sndWri:
  00232	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0023a	f3 0f 11 44 24
	68		 movss	 DWORD PTR tv133[rsp], xmm0
$LN110@psf_sndWri:
  00240	f3 0f 10 44 24
	68		 movss	 xmm0, DWORD PTR tv133[rsp]
  00246	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1536 : 						fsamp = max(fsamp,-1.0f);

  0024c	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00252	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@bf800000
  00259	76 0e		 jbe	 SHORT $LN111@psf_sndWri
  0025b	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00261	f3 0f 11 44 24
	6c		 movss	 DWORD PTR tv135[rsp], xmm0
  00267	eb 0e		 jmp	 SHORT $LN112@psf_sndWri
$LN111@psf_sndWri:
  00269	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00271	f3 0f 11 44 24
	6c		 movss	 DWORD PTR tv135[rsp], xmm0
$LN112@psf_sndWri:
  00277	f3 0f 10 44 24
	6c		 movss	 xmm0, DWORD PTR tv135[rsp]
  0027d	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0
$LN66@psf_sndWri:

; 1537 : 					}
; 1538 : 					absfsamp = (float) fabs((double)fsamp);

  00283	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  00289	e8 00 00 00 00	 call	 fabs
  0028e	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00292	f3 0f 11 44 24
	3c		 movss	 DWORD PTR absfsamp$[rsp], xmm0

; 1539 : 					if(sfdat->pPeaks && (sfdat->pPeaks[j].val < absfsamp)){

  00298	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  0029d	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  002a5	74 5a		 je	 SHORT $LN67@psf_sndWri
  002a7	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  002ac	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  002b1	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  002b8	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  002be	0f 2f 04 c1	 comiss	 xmm0, DWORD PTR [rcx+rax*8]
  002c2	76 3d		 jbe	 SHORT $LN67@psf_sndWri

; 1540 : 						sfdat->pPeaks[j].pos = sfdat->nFrames + i;

  002c4	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  002c9	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  002cc	03 44 24 28	 add	 eax, DWORD PTR i$[rsp]
  002d0	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  002d5	48 8b 54 24 30	 mov	 rdx, QWORD PTR sfdat$[rsp]
  002da	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  002e1	89 44 ca 04	 mov	 DWORD PTR [rdx+rcx*8+4], eax

; 1541 : 						sfdat->pPeaks[j].val = absfsamp;

  002e5	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  002ea	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  002ef	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  002f6	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  002fc	f3 0f 11 04 c1	 movss	 DWORD PTR [rcx+rax*8], xmm0
$LN67@psf_sndWri:

; 1542 : 					}
; 1543 : 					lsamp = * (int *) pbuf++;

  00301	48 8b 44 24 60	 mov	 rax, QWORD PTR pbuf$[rsp]
  00306	8b 00		 mov	 eax, DWORD PTR [rax]
  00308	89 44 24 38	 mov	 DWORD PTR lsamp$[rsp], eax
  0030c	48 8b 44 24 60	 mov	 rax, QWORD PTR pbuf$[rsp]
  00311	48 83 c0 04	 add	 rax, 4
  00315	48 89 44 24 60	 mov	 QWORD PTR pbuf$[rsp], rax

; 1544 : 					lsamp = REVDWBYTES(lsamp);

  0031a	8b 44 24 38	 mov	 eax, DWORD PTR lsamp$[rsp]
  0031e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00323	c1 e0 18	 shl	 eax, 24
  00326	8b 4c 24 38	 mov	 ecx, DWORD PTR lsamp$[rsp]
  0032a	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00330	c1 e1 08	 shl	 ecx, 8
  00333	0b c1		 or	 eax, ecx
  00335	8b 4c 24 38	 mov	 ecx, DWORD PTR lsamp$[rsp]
  00339	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  0033f	c1 f9 08	 sar	 ecx, 8
  00342	0b c1		 or	 eax, ecx
  00344	8b 4c 24 38	 mov	 ecx, DWORD PTR lsamp$[rsp]
  00348	c1 f9 18	 sar	 ecx, 24
  0034b	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00351	0b c1		 or	 eax, ecx
  00353	89 44 24 38	 mov	 DWORD PTR lsamp$[rsp], eax

; 1545 : 					if(wavDoWrite(sfdat,(char *) &lsamp,sizeof(int))){

  00357	41 b8 04 00 00
	00		 mov	 r8d, 4
  0035d	48 8d 54 24 38	 lea	 rdx, QWORD PTR lsamp$[rsp]
  00362	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00367	e8 00 00 00 00	 call	 wavDoWrite
  0036c	85 c0		 test	 eax, eax
  0036e	74 0a		 je	 SHORT $LN68@psf_sndWri

; 1546 : 						DBGFPRINTF((stderr, "wavOpenWrite: write error\n"));
; 1547 : 						return PSF_E_CANT_WRITE;

  00370	b8 fd ff ff ff	 mov	 eax, -3
  00375	e9 4c 0e 00 00	 jmp	 $LN1@psf_sndWri
$LN68@psf_sndWri:

; 1548 : 					}
; 1549 : 				}							

  0037a	e9 64 fe ff ff	 jmp	 $LN9@psf_sndWri
$LN10@psf_sndWri:

; 1550 : 			}			

  0037f	e9 3a fe ff ff	 jmp	 $LN6@psf_sndWri
$LN7@psf_sndWri:

; 1551 : 		}

  00384	e9 a5 01 00 00	 jmp	 $LN65@psf_sndWri
$LN64@psf_sndWri:

; 1552 : 		else {			
; 1553 : 			for(i=0; i < nFrames; i++, pbuf += chans){

  00389	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00391	eb 1d		 jmp	 SHORT $LN14@psf_sndWri
$LN12@psf_sndWri:
  00393	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00397	ff c0		 inc	 eax
  00399	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
  0039d	48 63 44 24 40	 movsxd	 rax, DWORD PTR chans$[rsp]
  003a2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pbuf$[rsp]
  003a7	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  003ab	48 89 44 24 60	 mov	 QWORD PTR pbuf$[rsp], rax
$LN14@psf_sndWri:
  003b0	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  003b7	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  003bb	0f 83 38 01 00
	00		 jae	 $LN13@psf_sndWri

; 1554 : 				for(j=0;j < chans; j++) {

  003c1	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  003c9	eb 0a		 jmp	 SHORT $LN17@psf_sndWri
$LN15@psf_sndWri:
  003cb	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  003cf	ff c0		 inc	 eax
  003d1	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN17@psf_sndWri:
  003d5	8b 44 24 40	 mov	 eax, DWORD PTR chans$[rsp]
  003d9	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  003dd	0f 8d 11 01 00
	00		 jge	 $LN16@psf_sndWri

; 1555 : 					fsamp = pbuf[j];

  003e3	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  003e8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pbuf$[rsp]
  003ed	f3 0f 10 04 81	 movss	 xmm0, DWORD PTR [rcx+rax*4]
  003f2	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1556 : 					if(sfdat->clip_floats){

  003f8	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  003fd	83 78 1c 00	 cmp	 DWORD PTR [rax+28], 0
  00401	74 6e		 je	 SHORT $LN69@psf_sndWri

; 1557 : 						fsamp = min(fsamp,1.0f);

  00403	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0040b	0f 2f 44 24 20	 comiss	 xmm0, DWORD PTR fsamp$[rsp]
  00410	76 0e		 jbe	 SHORT $LN113@psf_sndWri
  00412	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00418	f3 0f 11 44 24
	70		 movss	 DWORD PTR tv190[rsp], xmm0
  0041e	eb 0e		 jmp	 SHORT $LN114@psf_sndWri
$LN113@psf_sndWri:
  00420	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00428	f3 0f 11 44 24
	70		 movss	 DWORD PTR tv190[rsp], xmm0
$LN114@psf_sndWri:
  0042e	f3 0f 10 44 24
	70		 movss	 xmm0, DWORD PTR tv190[rsp]
  00434	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1558 : 						fsamp = max(fsamp,-1.0f);

  0043a	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00440	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@bf800000
  00447	76 0e		 jbe	 SHORT $LN115@psf_sndWri
  00449	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  0044f	f3 0f 11 44 24
	74		 movss	 DWORD PTR tv192[rsp], xmm0
  00455	eb 0e		 jmp	 SHORT $LN116@psf_sndWri
$LN115@psf_sndWri:
  00457	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0045f	f3 0f 11 44 24
	74		 movss	 DWORD PTR tv192[rsp], xmm0
$LN116@psf_sndWri:
  00465	f3 0f 10 44 24
	74		 movss	 xmm0, DWORD PTR tv192[rsp]
  0046b	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0
$LN69@psf_sndWri:

; 1559 : 					}
; 1560 : 					absfsamp = (float)fabs((double)fsamp);

  00471	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  00477	e8 00 00 00 00	 call	 fabs
  0047c	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00480	f3 0f 11 44 24
	3c		 movss	 DWORD PTR absfsamp$[rsp], xmm0

; 1561 : 					if(sfdat->pPeaks && (sfdat->pPeaks[j].val < absfsamp)){

  00486	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  0048b	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00493	74 5a		 je	 SHORT $LN70@psf_sndWri
  00495	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  0049a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0049f	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  004a6	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  004ac	0f 2f 04 c1	 comiss	 xmm0, DWORD PTR [rcx+rax*8]
  004b0	76 3d		 jbe	 SHORT $LN70@psf_sndWri

; 1562 : 						sfdat->pPeaks[j].pos = sfdat->nFrames + i;

  004b2	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  004b7	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  004ba	03 44 24 28	 add	 eax, DWORD PTR i$[rsp]
  004be	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  004c3	48 8b 54 24 30	 mov	 rdx, QWORD PTR sfdat$[rsp]
  004c8	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  004cf	89 44 ca 04	 mov	 DWORD PTR [rdx+rcx*8+4], eax

; 1563 : 						sfdat->pPeaks[j].val = absfsamp;

  004d3	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  004d8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  004dd	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  004e4	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  004ea	f3 0f 11 04 c1	 movss	 DWORD PTR [rcx+rax*8], xmm0
$LN70@psf_sndWri:

; 1564 : 					}					
; 1565 : 				}								

  004ef	e9 d7 fe ff ff	 jmp	 $LN15@psf_sndWri
$LN16@psf_sndWri:

; 1566 : 			}

  004f4	e9 9a fe ff ff	 jmp	 $LN12@psf_sndWri
$LN13@psf_sndWri:

; 1567 : 			if(wavDoWrite(sfdat,(char *)buf,nFrames * chans * sizeof(float))){

  004f9	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  00500	0f af 44 24 40	 imul	 eax, DWORD PTR chans$[rsp]
  00505	8b c0		 mov	 eax, eax
  00507	48 c1 e0 02	 shl	 rax, 2
  0050b	44 8b c0	 mov	 r8d, eax
  0050e	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00516	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0051b	e8 00 00 00 00	 call	 wavDoWrite
  00520	85 c0		 test	 eax, eax
  00522	74 0a		 je	 SHORT $LN71@psf_sndWri

; 1568 : 				DBGFPRINTF((stderr, "wavOpenWrite: write error\n"));
; 1569 : 				return PSF_E_CANT_WRITE;				

  00524	b8 fd ff ff ff	 mov	 eax, -3
  00529	e9 98 0c 00 00	 jmp	 $LN1@psf_sndWri
$LN71@psf_sndWri:
$LN65@psf_sndWri:

; 1570 : 			}
; 1571 : 		}
; 1572 : 		break;

  0052e	e9 13 0c 00 00	 jmp	 $LN4@psf_sndWri
$LN72@psf_sndWri:

; 1573 : 	case(PSF_SAMP_16):
; 1574 : 		/* TODO: optimise all this with func pointers etc */
; 1575 : 		if(do_reverse){	

  00533	83 7c 24 4c 00	 cmp	 DWORD PTR do_reverse$[rsp], 0
  00538	0f 84 1e 02 00
	00		 je	 $LN73@psf_sndWri

; 1576 : 			short ssamp;
; 1577 : 			for(i=0; i < nFrames; i++){

  0053e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00546	eb 0a		 jmp	 SHORT $LN20@psf_sndWri
$LN18@psf_sndWri:
  00548	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0054c	ff c0		 inc	 eax
  0054e	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN20@psf_sndWri:
  00552	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  00559	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  0055d	0f 83 f4 01 00
	00		 jae	 $LN19@psf_sndWri

; 1578 : 				for(j=0;j < chans; j++) {

  00563	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  0056b	eb 0a		 jmp	 SHORT $LN23@psf_sndWri
$LN21@psf_sndWri:
  0056d	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  00571	ff c0		 inc	 eax
  00573	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN23@psf_sndWri:
  00577	8b 44 24 40	 mov	 eax, DWORD PTR chans$[rsp]
  0057b	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  0057f	0f 8d cd 01 00
	00		 jge	 $LN22@psf_sndWri

; 1579 : 					fsamp = *buf++;

  00585	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0058d	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00591	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0
  00597	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0059f	48 83 c0 04	 add	 rax, 4
  005a3	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 1580 : 					/* clip now! we may have a flag to rescale first...one day */
; 1581 : 					fsamp = min(fsamp,1.0f);

  005ab	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  005b3	0f 2f 44 24 20	 comiss	 xmm0, DWORD PTR fsamp$[rsp]
  005b8	76 0e		 jbe	 SHORT $LN117@psf_sndWri
  005ba	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  005c0	f3 0f 11 44 24
	78		 movss	 DWORD PTR tv233[rsp], xmm0
  005c6	eb 0e		 jmp	 SHORT $LN118@psf_sndWri
$LN117@psf_sndWri:
  005c8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  005d0	f3 0f 11 44 24
	78		 movss	 DWORD PTR tv233[rsp], xmm0
$LN118@psf_sndWri:
  005d6	f3 0f 10 44 24
	78		 movss	 xmm0, DWORD PTR tv233[rsp]
  005dc	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1582 : 					fsamp = max(fsamp,-1.0f);

  005e2	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  005e8	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@bf800000
  005ef	76 0e		 jbe	 SHORT $LN119@psf_sndWri
  005f1	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  005f7	f3 0f 11 44 24
	7c		 movss	 DWORD PTR tv235[rsp], xmm0
  005fd	eb 0e		 jmp	 SHORT $LN120@psf_sndWri
$LN119@psf_sndWri:
  005ff	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00607	f3 0f 11 44 24
	7c		 movss	 DWORD PTR tv235[rsp], xmm0
$LN120@psf_sndWri:
  0060d	f3 0f 10 44 24
	7c		 movss	 xmm0, DWORD PTR tv235[rsp]
  00613	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1583 : 					absfsamp = (float) fabs((double)fsamp);

  00619	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  0061f	e8 00 00 00 00	 call	 fabs
  00624	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00628	f3 0f 11 44 24
	3c		 movss	 DWORD PTR absfsamp$[rsp], xmm0

; 1584 : 					if(sfdat->pPeaks && (sfdat->pPeaks[j].val < absfsamp)){

  0062e	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00633	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  0063b	74 5a		 je	 SHORT $LN75@psf_sndWri
  0063d	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  00642	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00647	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  0064e	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  00654	0f 2f 04 c1	 comiss	 xmm0, DWORD PTR [rcx+rax*8]
  00658	76 3d		 jbe	 SHORT $LN75@psf_sndWri

; 1585 : 						sfdat->pPeaks[j].pos = sfdat->nFrames + i;

  0065a	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  0065f	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00662	03 44 24 28	 add	 eax, DWORD PTR i$[rsp]
  00666	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  0066b	48 8b 54 24 30	 mov	 rdx, QWORD PTR sfdat$[rsp]
  00670	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  00677	89 44 ca 04	 mov	 DWORD PTR [rdx+rcx*8+4], eax

; 1586 : 						sfdat->pPeaks[j].val = absfsamp;

  0067b	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  00680	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00685	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  0068c	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  00692	f3 0f 11 04 c1	 movss	 DWORD PTR [rcx+rax*8], xmm0
$LN75@psf_sndWri:

; 1587 : 					}
; 1588 : 					if(sfdat->dithertype == PSF_DITHER_TPDF)

  00697	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  0069c	83 b8 9c 00 00
	00 01		 cmp	 DWORD PTR [rax+156], 1
  006a3	75 4b		 jne	 SHORT $LN76@psf_sndWri

; 1589 : 						ssamp = (short) psf_round(fsamp * 32766.0 + 2.0 * trirand());

  006a5	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  006ab	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@40dfff8000000000
  006b3	f2 0f 11 84 24
	b8 00 00 00	 movsd	 QWORD PTR tv264[rsp], xmm0
  006bc	e8 00 00 00 00	 call	 trirand
  006c1	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  006c5	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4000000000000000
  006cd	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  006d1	0f 28 c1	 movaps	 xmm0, xmm1
  006d4	f2 0f 10 8c 24
	b8 00 00 00	 movsd	 xmm1, QWORD PTR tv264[rsp]
  006dd	f2 0f 58 c8	 addsd	 xmm1, xmm0
  006e1	0f 28 c1	 movaps	 xmm0, xmm1
  006e4	e8 00 00 00 00	 call	 psf_round
  006e9	66 89 44 24 44	 mov	 WORD PTR ssamp$1[rsp], ax
  006ee	eb 18		 jmp	 SHORT $LN77@psf_sndWri
$LN76@psf_sndWri:

; 1590 : 					else
; 1591 : 						ssamp = (short) psf_round(fsamp * MAX_16BIT);

  006f0	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  006f6	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@40e0000000000000
  006fe	e8 00 00 00 00	 call	 psf_round
  00703	66 89 44 24 44	 mov	 WORD PTR ssamp$1[rsp], ax
$LN77@psf_sndWri:

; 1592 : 					ssamp = (short) REVWBYTES(ssamp);

  00708	0f bf 44 24 44	 movsx	 eax, WORD PTR ssamp$1[rsp]
  0070d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00712	c1 e0 08	 shl	 eax, 8
  00715	0f bf 4c 24 44	 movsx	 ecx, WORD PTR ssamp$1[rsp]
  0071a	c1 f9 08	 sar	 ecx, 8
  0071d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00723	0b c1		 or	 eax, ecx
  00725	66 89 44 24 44	 mov	 WORD PTR ssamp$1[rsp], ax

; 1593 : 					if( wavDoWrite(sfdat,(char *) &ssamp,sizeof(short))){

  0072a	41 b8 02 00 00
	00		 mov	 r8d, 2
  00730	48 8d 54 24 44	 lea	 rdx, QWORD PTR ssamp$1[rsp]
  00735	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0073a	e8 00 00 00 00	 call	 wavDoWrite
  0073f	85 c0		 test	 eax, eax
  00741	74 0a		 je	 SHORT $LN78@psf_sndWri

; 1594 : 						DBGFPRINTF((stderr, "wavOpenWrite: write error\n"));
; 1595 : 						return PSF_E_CANT_WRITE;

  00743	b8 fd ff ff ff	 mov	 eax, -3
  00748	e9 79 0a 00 00	 jmp	 $LN1@psf_sndWri
$LN78@psf_sndWri:

; 1596 : 					}
; 1597 : 				}	

  0074d	e9 1b fe ff ff	 jmp	 $LN21@psf_sndWri
$LN22@psf_sndWri:

; 1598 : 			}

  00752	e9 f1 fd ff ff	 jmp	 $LN18@psf_sndWri
$LN19@psf_sndWri:

; 1599 : 		}

  00757	e9 14 02 00 00	 jmp	 $LN74@psf_sndWri
$LN73@psf_sndWri:

; 1600 : 		else {
; 1601 : 			short ssamp;
; 1602 : 			for(i=0; i < nFrames; i++, buf += chans){

  0075c	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00764	eb 23		 jmp	 SHORT $LN26@psf_sndWri
$LN24@psf_sndWri:
  00766	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0076a	ff c0		 inc	 eax
  0076c	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
  00770	48 63 44 24 40	 movsxd	 rax, DWORD PTR chans$[rsp]
  00775	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0077d	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  00781	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax
$LN26@psf_sndWri:
  00789	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  00790	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00794	0f 83 d6 01 00
	00		 jae	 $LN25@psf_sndWri

; 1603 : 				for(j=0;j < chans; j++) {					 

  0079a	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  007a2	eb 0a		 jmp	 SHORT $LN29@psf_sndWri
$LN27@psf_sndWri:
  007a4	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  007a8	ff c0		 inc	 eax
  007aa	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN29@psf_sndWri:
  007ae	8b 44 24 40	 mov	 eax, DWORD PTR chans$[rsp]
  007b2	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  007b6	0f 8d af 01 00
	00		 jge	 $LN28@psf_sndWri

; 1604 : 					fsamp = buf[j];

  007bc	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  007c1	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  007c9	f3 0f 10 04 81	 movss	 xmm0, DWORD PTR [rcx+rax*4]
  007ce	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1605 : 					/* clip now! we may have a flag to rescale first...one day */
; 1606 : 					fsamp = min(fsamp,1.0f);

  007d4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  007dc	0f 2f 44 24 20	 comiss	 xmm0, DWORD PTR fsamp$[rsp]
  007e1	76 11		 jbe	 SHORT $LN121@psf_sndWri
  007e3	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  007e9	f3 0f 11 84 24
	80 00 00 00	 movss	 DWORD PTR tv300[rsp], xmm0
  007f2	eb 11		 jmp	 SHORT $LN122@psf_sndWri
$LN121@psf_sndWri:
  007f4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  007fc	f3 0f 11 84 24
	80 00 00 00	 movss	 DWORD PTR tv300[rsp], xmm0
$LN122@psf_sndWri:
  00805	f3 0f 10 84 24
	80 00 00 00	 movss	 xmm0, DWORD PTR tv300[rsp]
  0080e	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1607 : 					fsamp = max(fsamp,-1.0f);

  00814	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  0081a	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@bf800000
  00821	76 11		 jbe	 SHORT $LN123@psf_sndWri
  00823	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00829	f3 0f 11 84 24
	84 00 00 00	 movss	 DWORD PTR tv302[rsp], xmm0
  00832	eb 11		 jmp	 SHORT $LN124@psf_sndWri
$LN123@psf_sndWri:
  00834	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0083c	f3 0f 11 84 24
	84 00 00 00	 movss	 DWORD PTR tv302[rsp], xmm0
$LN124@psf_sndWri:
  00845	f3 0f 10 84 24
	84 00 00 00	 movss	 xmm0, DWORD PTR tv302[rsp]
  0084e	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1608 : 					absfsamp = (float) fabs((double)fsamp);

  00854	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  0085a	e8 00 00 00 00	 call	 fabs
  0085f	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00863	f3 0f 11 44 24
	3c		 movss	 DWORD PTR absfsamp$[rsp], xmm0

; 1609 : 					if(sfdat->pPeaks && (sfdat->pPeaks[j].val < absfsamp)){

  00869	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  0086e	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00876	74 5a		 je	 SHORT $LN79@psf_sndWri
  00878	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  0087d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00882	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00889	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  0088f	0f 2f 04 c1	 comiss	 xmm0, DWORD PTR [rcx+rax*8]
  00893	76 3d		 jbe	 SHORT $LN79@psf_sndWri

; 1610 : 						sfdat->pPeaks[j].pos = sfdat->nFrames + i;

  00895	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  0089a	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0089d	03 44 24 28	 add	 eax, DWORD PTR i$[rsp]
  008a1	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  008a6	48 8b 54 24 30	 mov	 rdx, QWORD PTR sfdat$[rsp]
  008ab	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  008b2	89 44 ca 04	 mov	 DWORD PTR [rdx+rcx*8+4], eax

; 1611 : 						sfdat->pPeaks[j].val = absfsamp;

  008b6	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  008bb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  008c0	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  008c7	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  008cd	f3 0f 11 04 c1	 movss	 DWORD PTR [rcx+rax*8], xmm0
$LN79@psf_sndWri:

; 1612 : 					}
; 1613 : 					if(sfdat->dithertype == PSF_DITHER_TPDF)

  008d2	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  008d7	83 b8 9c 00 00
	00 01		 cmp	 DWORD PTR [rax+156], 1
  008de	75 4b		 jne	 SHORT $LN80@psf_sndWri

; 1614 : 						ssamp = (short) psf_round(fsamp * 32766.0 + 2.0 * trirand());

  008e0	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  008e6	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@40dfff8000000000
  008ee	f2 0f 11 84 24
	c0 00 00 00	 movsd	 QWORD PTR tv331[rsp], xmm0
  008f7	e8 00 00 00 00	 call	 trirand
  008fc	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00900	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4000000000000000
  00908	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  0090c	0f 28 c1	 movaps	 xmm0, xmm1
  0090f	f2 0f 10 8c 24
	c0 00 00 00	 movsd	 xmm1, QWORD PTR tv331[rsp]
  00918	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0091c	0f 28 c1	 movaps	 xmm0, xmm1
  0091f	e8 00 00 00 00	 call	 psf_round
  00924	66 89 44 24 48	 mov	 WORD PTR ssamp$2[rsp], ax
  00929	eb 18		 jmp	 SHORT $LN81@psf_sndWri
$LN80@psf_sndWri:

; 1615 : 					else
; 1616 : 						ssamp = (short) psf_round(fsamp * MAX_16BIT);

  0092b	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  00931	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@40e0000000000000
  00939	e8 00 00 00 00	 call	 psf_round
  0093e	66 89 44 24 48	 mov	 WORD PTR ssamp$2[rsp], ax
$LN81@psf_sndWri:

; 1617 : 					
; 1618 : 					if(wavDoWrite(sfdat,(char *) &ssamp,sizeof(short))){

  00943	41 b8 02 00 00
	00		 mov	 r8d, 2
  00949	48 8d 54 24 48	 lea	 rdx, QWORD PTR ssamp$2[rsp]
  0094e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00953	e8 00 00 00 00	 call	 wavDoWrite
  00958	85 c0		 test	 eax, eax
  0095a	74 0a		 je	 SHORT $LN82@psf_sndWri

; 1619 : 						DBGFPRINTF((stderr, "wavOpenWrite: write error\n"));
; 1620 : 						return PSF_E_CANT_WRITE;

  0095c	b8 fd ff ff ff	 mov	 eax, -3
  00961	e9 60 08 00 00	 jmp	 $LN1@psf_sndWri
$LN82@psf_sndWri:

; 1621 : 					}
; 1622 : 				}			

  00966	e9 39 fe ff ff	 jmp	 $LN27@psf_sndWri
$LN28@psf_sndWri:

; 1623 : 			}			

  0096b	e9 f6 fd ff ff	 jmp	 $LN24@psf_sndWri
$LN25@psf_sndWri:
$LN74@psf_sndWri:

; 1624 : 		}
; 1625 : 		break;

  00970	e9 d1 07 00 00	 jmp	 $LN4@psf_sndWri
$LN83@psf_sndWri:

; 1626 : 	case(PSF_SAMP_24):			 
; 1627 : 		if(do_reverse){            

  00975	83 7c 24 4c 00	 cmp	 DWORD PTR do_reverse$[rsp], 0
  0097a	0f 84 1b 02 00
	00		 je	 $LN84@psf_sndWri

; 1628 : 			for(i=0; i < nFrames; i++){

  00980	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00988	eb 0a		 jmp	 SHORT $LN32@psf_sndWri
$LN30@psf_sndWri:
  0098a	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0098e	ff c0		 inc	 eax
  00990	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN32@psf_sndWri:
  00994	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  0099b	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  0099f	0f 83 f1 01 00
	00		 jae	 $LN31@psf_sndWri

; 1629 : 				for(j=0;j < chans; j++) {

  009a5	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  009ad	eb 0a		 jmp	 SHORT $LN35@psf_sndWri
$LN33@psf_sndWri:
  009af	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  009b3	ff c0		 inc	 eax
  009b5	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN35@psf_sndWri:
  009b9	8b 44 24 40	 mov	 eax, DWORD PTR chans$[rsp]
  009bd	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  009c1	0f 8d ca 01 00
	00		 jge	 $LN34@psf_sndWri

; 1630 : 					fsamp = *buf++;

  009c7	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  009cf	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  009d3	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0
  009d9	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  009e1	48 83 c0 04	 add	 rax, 4
  009e5	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 1631 : 					/* clip now! we may have a flag to rescale first...one day */
; 1632 : 					fsamp = min(fsamp,1.0f);

  009ed	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  009f5	0f 2f 44 24 20	 comiss	 xmm0, DWORD PTR fsamp$[rsp]
  009fa	76 11		 jbe	 SHORT $LN125@psf_sndWri
  009fc	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00a02	f3 0f 11 84 24
	88 00 00 00	 movss	 DWORD PTR tv355[rsp], xmm0
  00a0b	eb 11		 jmp	 SHORT $LN126@psf_sndWri
$LN125@psf_sndWri:
  00a0d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00a15	f3 0f 11 84 24
	88 00 00 00	 movss	 DWORD PTR tv355[rsp], xmm0
$LN126@psf_sndWri:
  00a1e	f3 0f 10 84 24
	88 00 00 00	 movss	 xmm0, DWORD PTR tv355[rsp]
  00a27	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1633 : 					fsamp = max(fsamp,-1.0f);

  00a2d	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00a33	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@bf800000
  00a3a	76 11		 jbe	 SHORT $LN127@psf_sndWri
  00a3c	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00a42	f3 0f 11 84 24
	8c 00 00 00	 movss	 DWORD PTR tv357[rsp], xmm0
  00a4b	eb 11		 jmp	 SHORT $LN128@psf_sndWri
$LN127@psf_sndWri:
  00a4d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00a55	f3 0f 11 84 24
	8c 00 00 00	 movss	 DWORD PTR tv357[rsp], xmm0
$LN128@psf_sndWri:
  00a5e	f3 0f 10 84 24
	8c 00 00 00	 movss	 xmm0, DWORD PTR tv357[rsp]
  00a67	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1634 : 					absfsamp = (float) fabs((double)fsamp);

  00a6d	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  00a73	e8 00 00 00 00	 call	 fabs
  00a78	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00a7c	f3 0f 11 44 24
	3c		 movss	 DWORD PTR absfsamp$[rsp], xmm0

; 1635 : 					if(sfdat->pPeaks && (sfdat->pPeaks[j].val < absfsamp)){

  00a82	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00a87	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00a8f	74 5a		 je	 SHORT $LN86@psf_sndWri
  00a91	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  00a96	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00a9b	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00aa2	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  00aa8	0f 2f 04 c1	 comiss	 xmm0, DWORD PTR [rcx+rax*8]
  00aac	76 3d		 jbe	 SHORT $LN86@psf_sndWri

; 1636 : 						sfdat->pPeaks[j].pos = sfdat->nFrames + i;

  00aae	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00ab3	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00ab6	03 44 24 28	 add	 eax, DWORD PTR i$[rsp]
  00aba	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  00abf	48 8b 54 24 30	 mov	 rdx, QWORD PTR sfdat$[rsp]
  00ac4	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  00acb	89 44 ca 04	 mov	 DWORD PTR [rdx+rcx*8+4], eax

; 1637 : 						sfdat->pPeaks[j].val = absfsamp;

  00acf	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  00ad4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00ad9	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00ae0	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  00ae6	f3 0f 11 04 c1	 movss	 DWORD PTR [rcx+rax*8], xmm0
$LN86@psf_sndWri:

; 1638 : 					}
; 1639 : 					lsamp = psf_round(fsamp * MAX_32BIT);					

  00aeb	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  00af1	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@41e0000000000000
  00af9	e8 00 00 00 00	 call	 psf_round
  00afe	89 44 24 38	 mov	 DWORD PTR lsamp$[rsp], eax

; 1640 : 					lsamp = REVDWBYTES(lsamp);

  00b02	8b 44 24 38	 mov	 eax, DWORD PTR lsamp$[rsp]
  00b06	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00b0b	c1 e0 18	 shl	 eax, 24
  00b0e	8b 4c 24 38	 mov	 ecx, DWORD PTR lsamp$[rsp]
  00b12	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00b18	c1 e1 08	 shl	 ecx, 8
  00b1b	0b c1		 or	 eax, ecx
  00b1d	8b 4c 24 38	 mov	 ecx, DWORD PTR lsamp$[rsp]
  00b21	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00b27	c1 f9 08	 sar	 ecx, 8
  00b2a	0b c1		 or	 eax, ecx
  00b2c	8b 4c 24 38	 mov	 ecx, DWORD PTR lsamp$[rsp]
  00b30	c1 f9 18	 sar	 ecx, 24
  00b33	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00b39	0b c1		 or	 eax, ecx
  00b3b	89 44 24 38	 mov	 DWORD PTR lsamp$[rsp], eax

; 1641 :                     if(do_shift){

  00b3f	83 7c 24 58 00	 cmp	 DWORD PTR do_shift$[rsp], 0
  00b44	74 23		 je	 SHORT $LN87@psf_sndWri

; 1642 : 						if(sfdat->is_little_endian)

  00b46	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00b4b	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00b4f	74 0d		 je	 SHORT $LN88@psf_sndWri

; 1643 : 							lsamp >>= 8;

  00b51	8b 44 24 38	 mov	 eax, DWORD PTR lsamp$[rsp]
  00b55	c1 f8 08	 sar	 eax, 8
  00b58	89 44 24 38	 mov	 DWORD PTR lsamp$[rsp], eax
  00b5c	eb 0b		 jmp	 SHORT $LN89@psf_sndWri
$LN88@psf_sndWri:

; 1644 : 						else
; 1645 : 							lsamp <<= 8;

  00b5e	8b 44 24 38	 mov	 eax, DWORD PTR lsamp$[rsp]
  00b62	c1 e0 08	 shl	 eax, 8
  00b65	89 44 24 38	 mov	 DWORD PTR lsamp$[rsp], eax
$LN89@psf_sndWri:
$LN87@psf_sndWri:

; 1646 : 					}
; 1647 : 					if( wavDoWrite(sfdat,(char *) &lsamp,3)){

  00b69	41 b8 03 00 00
	00		 mov	 r8d, 3
  00b6f	48 8d 54 24 38	 lea	 rdx, QWORD PTR lsamp$[rsp]
  00b74	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00b79	e8 00 00 00 00	 call	 wavDoWrite
  00b7e	85 c0		 test	 eax, eax
  00b80	74 0a		 je	 SHORT $LN90@psf_sndWri

; 1648 : 						DBGFPRINTF((stderr, "wavOpenWrite: write error\n"));
; 1649 : 						return PSF_E_CANT_WRITE;

  00b82	b8 fd ff ff ff	 mov	 eax, -3
  00b87	e9 3a 06 00 00	 jmp	 $LN1@psf_sndWri
$LN90@psf_sndWri:

; 1650 : 					}
; 1651 : 				}			

  00b8c	e9 1e fe ff ff	 jmp	 $LN33@psf_sndWri
$LN34@psf_sndWri:

; 1652 : 			}

  00b91	e9 f4 fd ff ff	 jmp	 $LN30@psf_sndWri
$LN31@psf_sndWri:

; 1653 : 		}

  00b96	e9 e4 01 00 00	 jmp	 $LN85@psf_sndWri
$LN84@psf_sndWri:

; 1654 : 		else {			
; 1655 : 			for(i=0; i < nFrames; i++, buf += chans){

  00b9b	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00ba3	eb 23		 jmp	 SHORT $LN38@psf_sndWri
$LN36@psf_sndWri:
  00ba5	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00ba9	ff c0		 inc	 eax
  00bab	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
  00baf	48 63 44 24 40	 movsxd	 rax, DWORD PTR chans$[rsp]
  00bb4	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00bbc	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  00bc0	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax
$LN38@psf_sndWri:
  00bc8	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  00bcf	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00bd3	0f 83 a6 01 00
	00		 jae	 $LN37@psf_sndWri

; 1656 : 				for(j=0;j < chans; j++) {					 

  00bd9	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00be1	eb 0a		 jmp	 SHORT $LN41@psf_sndWri
$LN39@psf_sndWri:
  00be3	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  00be7	ff c0		 inc	 eax
  00be9	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN41@psf_sndWri:
  00bed	8b 44 24 40	 mov	 eax, DWORD PTR chans$[rsp]
  00bf1	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  00bf5	0f 8d 7f 01 00
	00		 jge	 $LN40@psf_sndWri

; 1657 : 					fsamp = buf[j];

  00bfb	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  00c00	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00c08	f3 0f 10 04 81	 movss	 xmm0, DWORD PTR [rcx+rax*4]
  00c0d	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1658 : 					/* clip now! we may have a flag to rescale first...one day */
; 1659 : 					fsamp = min(fsamp,1.0f);

  00c13	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00c1b	0f 2f 44 24 20	 comiss	 xmm0, DWORD PTR fsamp$[rsp]
  00c20	76 11		 jbe	 SHORT $LN129@psf_sndWri
  00c22	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00c28	f3 0f 11 84 24
	90 00 00 00	 movss	 DWORD PTR tv418[rsp], xmm0
  00c31	eb 11		 jmp	 SHORT $LN130@psf_sndWri
$LN129@psf_sndWri:
  00c33	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00c3b	f3 0f 11 84 24
	90 00 00 00	 movss	 DWORD PTR tv418[rsp], xmm0
$LN130@psf_sndWri:
  00c44	f3 0f 10 84 24
	90 00 00 00	 movss	 xmm0, DWORD PTR tv418[rsp]
  00c4d	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1660 : 					fsamp = max(fsamp,-1.0f);

  00c53	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00c59	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@bf800000
  00c60	76 11		 jbe	 SHORT $LN131@psf_sndWri
  00c62	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00c68	f3 0f 11 84 24
	94 00 00 00	 movss	 DWORD PTR tv420[rsp], xmm0
  00c71	eb 11		 jmp	 SHORT $LN132@psf_sndWri
$LN131@psf_sndWri:
  00c73	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00c7b	f3 0f 11 84 24
	94 00 00 00	 movss	 DWORD PTR tv420[rsp], xmm0
$LN132@psf_sndWri:
  00c84	f3 0f 10 84 24
	94 00 00 00	 movss	 xmm0, DWORD PTR tv420[rsp]
  00c8d	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1661 : 					absfsamp = (float) fabs((double)fsamp);

  00c93	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  00c99	e8 00 00 00 00	 call	 fabs
  00c9e	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00ca2	f3 0f 11 44 24
	3c		 movss	 DWORD PTR absfsamp$[rsp], xmm0

; 1662 : 					if(sfdat->pPeaks && (sfdat->pPeaks[j].val < absfsamp)){

  00ca8	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00cad	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00cb5	74 5a		 je	 SHORT $LN91@psf_sndWri
  00cb7	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  00cbc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00cc1	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00cc8	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  00cce	0f 2f 04 c1	 comiss	 xmm0, DWORD PTR [rcx+rax*8]
  00cd2	76 3d		 jbe	 SHORT $LN91@psf_sndWri

; 1663 : 						sfdat->pPeaks[j].pos = sfdat->nFrames + i;

  00cd4	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00cd9	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00cdc	03 44 24 28	 add	 eax, DWORD PTR i$[rsp]
  00ce0	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  00ce5	48 8b 54 24 30	 mov	 rdx, QWORD PTR sfdat$[rsp]
  00cea	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  00cf1	89 44 ca 04	 mov	 DWORD PTR [rdx+rcx*8+4], eax

; 1664 : 						sfdat->pPeaks[j].val = absfsamp;

  00cf5	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  00cfa	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00cff	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00d06	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  00d0c	f3 0f 11 04 c1	 movss	 DWORD PTR [rcx+rax*8], xmm0
$LN91@psf_sndWri:

; 1665 : 					}
; 1666 : 					lsamp = psf_round(fsamp * MAX_32BIT);

  00d11	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  00d17	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@41e0000000000000
  00d1f	e8 00 00 00 00	 call	 psf_round
  00d24	89 44 24 38	 mov	 DWORD PTR lsamp$[rsp], eax

; 1667 : 					if(do_shift){

  00d28	83 7c 24 58 00	 cmp	 DWORD PTR do_shift$[rsp], 0
  00d2d	74 23		 je	 SHORT $LN92@psf_sndWri

; 1668 : 						if(sfdat->is_little_endian)

  00d2f	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00d34	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00d38	74 0d		 je	 SHORT $LN93@psf_sndWri

; 1669 : 							lsamp >>= 8;

  00d3a	8b 44 24 38	 mov	 eax, DWORD PTR lsamp$[rsp]
  00d3e	c1 f8 08	 sar	 eax, 8
  00d41	89 44 24 38	 mov	 DWORD PTR lsamp$[rsp], eax
  00d45	eb 0b		 jmp	 SHORT $LN94@psf_sndWri
$LN93@psf_sndWri:

; 1670 : 						else
; 1671 : 							lsamp <<= 8;

  00d47	8b 44 24 38	 mov	 eax, DWORD PTR lsamp$[rsp]
  00d4b	c1 e0 08	 shl	 eax, 8
  00d4e	89 44 24 38	 mov	 DWORD PTR lsamp$[rsp], eax
$LN94@psf_sndWri:
$LN92@psf_sndWri:

; 1672 : 					}
; 1673 : 					if(wavDoWrite(sfdat,(char *) &lsamp,3)){

  00d52	41 b8 03 00 00
	00		 mov	 r8d, 3
  00d58	48 8d 54 24 38	 lea	 rdx, QWORD PTR lsamp$[rsp]
  00d5d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00d62	e8 00 00 00 00	 call	 wavDoWrite
  00d67	85 c0		 test	 eax, eax
  00d69	74 0a		 je	 SHORT $LN95@psf_sndWri

; 1674 : 						DBGFPRINTF((stderr, "wavOpenWrite: write error\n"));
; 1675 : 						return PSF_E_CANT_WRITE;

  00d6b	b8 fd ff ff ff	 mov	 eax, -3
  00d70	e9 51 04 00 00	 jmp	 $LN1@psf_sndWri
$LN95@psf_sndWri:

; 1676 : 					}
; 1677 : 				}				

  00d75	e9 69 fe ff ff	 jmp	 $LN39@psf_sndWri
$LN40@psf_sndWri:

; 1678 : 			}			

  00d7a	e9 26 fe ff ff	 jmp	 $LN36@psf_sndWri
$LN37@psf_sndWri:
$LN85@psf_sndWri:

; 1679 : 		}
; 1680 : 		break;

  00d7f	e9 c2 03 00 00	 jmp	 $LN4@psf_sndWri
$LN96@psf_sndWri:

; 1681 : 	case(PSF_SAMP_32):
; 1682 : 		if(do_reverse){				

  00d84	83 7c 24 4c 00	 cmp	 DWORD PTR do_reverse$[rsp], 0
  00d89	0f 84 f1 01 00
	00		 je	 $LN97@psf_sndWri

; 1683 : 			for(i=0; i < nFrames; i++){

  00d8f	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00d97	eb 0a		 jmp	 SHORT $LN44@psf_sndWri
$LN42@psf_sndWri:
  00d99	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00d9d	ff c0		 inc	 eax
  00d9f	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN44@psf_sndWri:
  00da3	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  00daa	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00dae	0f 83 c7 01 00
	00		 jae	 $LN43@psf_sndWri

; 1684 : 				for(j=0;j < chans; j++) {

  00db4	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00dbc	eb 0a		 jmp	 SHORT $LN47@psf_sndWri
$LN45@psf_sndWri:
  00dbe	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  00dc2	ff c0		 inc	 eax
  00dc4	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN47@psf_sndWri:
  00dc8	8b 44 24 40	 mov	 eax, DWORD PTR chans$[rsp]
  00dcc	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  00dd0	0f 8d a0 01 00
	00		 jge	 $LN46@psf_sndWri

; 1685 : 					fsamp = *buf++;

  00dd6	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00dde	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00de2	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0
  00de8	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00df0	48 83 c0 04	 add	 rax, 4
  00df4	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 1686 : 					/* clip now! we may have a flag to rescale first...one day */
; 1687 : 					fsamp = min(fsamp,1.0f);

  00dfc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00e04	0f 2f 44 24 20	 comiss	 xmm0, DWORD PTR fsamp$[rsp]
  00e09	76 11		 jbe	 SHORT $LN133@psf_sndWri
  00e0b	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00e11	f3 0f 11 84 24
	98 00 00 00	 movss	 DWORD PTR tv466[rsp], xmm0
  00e1a	eb 11		 jmp	 SHORT $LN134@psf_sndWri
$LN133@psf_sndWri:
  00e1c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00e24	f3 0f 11 84 24
	98 00 00 00	 movss	 DWORD PTR tv466[rsp], xmm0
$LN134@psf_sndWri:
  00e2d	f3 0f 10 84 24
	98 00 00 00	 movss	 xmm0, DWORD PTR tv466[rsp]
  00e36	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1688 : 					fsamp = max(fsamp,-1.0f);

  00e3c	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00e42	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@bf800000
  00e49	76 11		 jbe	 SHORT $LN135@psf_sndWri
  00e4b	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  00e51	f3 0f 11 84 24
	9c 00 00 00	 movss	 DWORD PTR tv468[rsp], xmm0
  00e5a	eb 11		 jmp	 SHORT $LN136@psf_sndWri
$LN135@psf_sndWri:
  00e5c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00e64	f3 0f 11 84 24
	9c 00 00 00	 movss	 DWORD PTR tv468[rsp], xmm0
$LN136@psf_sndWri:
  00e6d	f3 0f 10 84 24
	9c 00 00 00	 movss	 xmm0, DWORD PTR tv468[rsp]
  00e76	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1689 : 					absfsamp = (float) fabs((double)fsamp);

  00e7c	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  00e82	e8 00 00 00 00	 call	 fabs
  00e87	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00e8b	f3 0f 11 44 24
	3c		 movss	 DWORD PTR absfsamp$[rsp], xmm0

; 1690 : 					if(sfdat->pPeaks && (sfdat->pPeaks[j].val < absfsamp)){

  00e91	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00e96	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00e9e	74 5a		 je	 SHORT $LN99@psf_sndWri
  00ea0	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  00ea5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00eaa	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00eb1	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  00eb7	0f 2f 04 c1	 comiss	 xmm0, DWORD PTR [rcx+rax*8]
  00ebb	76 3d		 jbe	 SHORT $LN99@psf_sndWri

; 1691 : 						sfdat->pPeaks[j].pos = sfdat->nFrames + i;

  00ebd	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00ec2	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00ec5	03 44 24 28	 add	 eax, DWORD PTR i$[rsp]
  00ec9	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  00ece	48 8b 54 24 30	 mov	 rdx, QWORD PTR sfdat$[rsp]
  00ed3	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  00eda	89 44 ca 04	 mov	 DWORD PTR [rdx+rcx*8+4], eax

; 1692 : 						sfdat->pPeaks[j].val = absfsamp;

  00ede	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  00ee3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00ee8	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00eef	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  00ef5	f3 0f 11 04 c1	 movss	 DWORD PTR [rcx+rax*8], xmm0
$LN99@psf_sndWri:

; 1693 : 					}
; 1694 : 					lsamp = psf_round(fsamp * MAX_32BIT );					

  00efa	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  00f00	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@41e0000000000000
  00f08	e8 00 00 00 00	 call	 psf_round
  00f0d	89 44 24 38	 mov	 DWORD PTR lsamp$[rsp], eax

; 1695 : 					lsamp = REVDWBYTES(lsamp);

  00f11	8b 44 24 38	 mov	 eax, DWORD PTR lsamp$[rsp]
  00f15	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00f1a	c1 e0 18	 shl	 eax, 24
  00f1d	8b 4c 24 38	 mov	 ecx, DWORD PTR lsamp$[rsp]
  00f21	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00f27	c1 e1 08	 shl	 ecx, 8
  00f2a	0b c1		 or	 eax, ecx
  00f2c	8b 4c 24 38	 mov	 ecx, DWORD PTR lsamp$[rsp]
  00f30	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00f36	c1 f9 08	 sar	 ecx, 8
  00f39	0b c1		 or	 eax, ecx
  00f3b	8b 4c 24 38	 mov	 ecx, DWORD PTR lsamp$[rsp]
  00f3f	c1 f9 18	 sar	 ecx, 24
  00f42	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00f48	0b c1		 or	 eax, ecx
  00f4a	89 44 24 38	 mov	 DWORD PTR lsamp$[rsp], eax

; 1696 : 					if( wavDoWrite(sfdat,(char *) &lsamp,sizeof(int))){

  00f4e	41 b8 04 00 00
	00		 mov	 r8d, 4
  00f54	48 8d 54 24 38	 lea	 rdx, QWORD PTR lsamp$[rsp]
  00f59	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00f5e	e8 00 00 00 00	 call	 wavDoWrite
  00f63	85 c0		 test	 eax, eax
  00f65	74 0a		 je	 SHORT $LN100@psf_sndWri

; 1697 : 						DBGFPRINTF((stderr, "wavOpenWrite: write error\n"));
; 1698 : 						return PSF_E_CANT_WRITE;

  00f67	b8 fd ff ff ff	 mov	 eax, -3
  00f6c	e9 55 02 00 00	 jmp	 $LN1@psf_sndWri
$LN100@psf_sndWri:

; 1699 : 					}
; 1700 : 				}		

  00f71	e9 48 fe ff ff	 jmp	 $LN45@psf_sndWri
$LN46@psf_sndWri:

; 1701 : 			}

  00f76	e9 1e fe ff ff	 jmp	 $LN42@psf_sndWri
$LN43@psf_sndWri:

; 1702 : 		}

  00f7b	e9 ba 01 00 00	 jmp	 $LN98@psf_sndWri
$LN97@psf_sndWri:

; 1703 : 		else {			
; 1704 : 			for(i=0; i < nFrames; i++, buf += chans){

  00f80	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00f88	eb 23		 jmp	 SHORT $LN50@psf_sndWri
$LN48@psf_sndWri:
  00f8a	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00f8e	ff c0		 inc	 eax
  00f90	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
  00f94	48 63 44 24 40	 movsxd	 rax, DWORD PTR chans$[rsp]
  00f99	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00fa1	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  00fa5	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax
$LN50@psf_sndWri:
  00fad	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  00fb4	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00fb8	0f 83 7c 01 00
	00		 jae	 $LN49@psf_sndWri

; 1705 : 				for(j=0;j < chans; j++) {					 

  00fbe	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00fc6	eb 0a		 jmp	 SHORT $LN53@psf_sndWri
$LN51@psf_sndWri:
  00fc8	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  00fcc	ff c0		 inc	 eax
  00fce	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN53@psf_sndWri:
  00fd2	8b 44 24 40	 mov	 eax, DWORD PTR chans$[rsp]
  00fd6	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  00fda	0f 8d 55 01 00
	00		 jge	 $LN52@psf_sndWri

; 1706 : 					fsamp = buf[j];

  00fe0	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  00fe5	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00fed	f3 0f 10 04 81	 movss	 xmm0, DWORD PTR [rcx+rax*4]
  00ff2	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1707 : 					/* clip now! we may have a flag to rescale first...one day */
; 1708 : 					fsamp = min(fsamp,1.0f);

  00ff8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01000	0f 2f 44 24 20	 comiss	 xmm0, DWORD PTR fsamp$[rsp]
  01005	76 11		 jbe	 SHORT $LN137@psf_sndWri
  01007	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  0100d	f3 0f 11 84 24
	a0 00 00 00	 movss	 DWORD PTR tv524[rsp], xmm0
  01016	eb 11		 jmp	 SHORT $LN138@psf_sndWri
$LN137@psf_sndWri:
  01018	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01020	f3 0f 11 84 24
	a0 00 00 00	 movss	 DWORD PTR tv524[rsp], xmm0
$LN138@psf_sndWri:
  01029	f3 0f 10 84 24
	a0 00 00 00	 movss	 xmm0, DWORD PTR tv524[rsp]
  01032	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1709 : 					fsamp = max(fsamp,-1.0f);

  01038	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  0103e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@bf800000
  01045	76 11		 jbe	 SHORT $LN139@psf_sndWri
  01047	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR fsamp$[rsp]
  0104d	f3 0f 11 84 24
	a4 00 00 00	 movss	 DWORD PTR tv526[rsp], xmm0
  01056	eb 11		 jmp	 SHORT $LN140@psf_sndWri
$LN139@psf_sndWri:
  01058	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  01060	f3 0f 11 84 24
	a4 00 00 00	 movss	 DWORD PTR tv526[rsp], xmm0
$LN140@psf_sndWri:
  01069	f3 0f 10 84 24
	a4 00 00 00	 movss	 xmm0, DWORD PTR tv526[rsp]
  01072	f3 0f 11 44 24
	20		 movss	 DWORD PTR fsamp$[rsp], xmm0

; 1710 : 					absfsamp = (float) fabs((double)fsamp);

  01078	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  0107e	e8 00 00 00 00	 call	 fabs
  01083	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  01087	f3 0f 11 44 24
	3c		 movss	 DWORD PTR absfsamp$[rsp], xmm0

; 1711 : 					if(sfdat->pPeaks && (sfdat->pPeaks[j].val < absfsamp)){

  0108d	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  01092	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  0109a	74 5a		 je	 SHORT $LN101@psf_sndWri
  0109c	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  010a1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  010a6	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  010ad	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  010b3	0f 2f 04 c1	 comiss	 xmm0, DWORD PTR [rcx+rax*8]
  010b7	76 3d		 jbe	 SHORT $LN101@psf_sndWri

; 1712 : 						sfdat->pPeaks[j].pos = sfdat->nFrames + i;

  010b9	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  010be	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  010c1	03 44 24 28	 add	 eax, DWORD PTR i$[rsp]
  010c5	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  010ca	48 8b 54 24 30	 mov	 rdx, QWORD PTR sfdat$[rsp]
  010cf	48 8b 92 80 00
	00 00		 mov	 rdx, QWORD PTR [rdx+128]
  010d6	89 44 ca 04	 mov	 DWORD PTR [rdx+rcx*8+4], eax

; 1713 : 						sfdat->pPeaks[j].val = absfsamp;

  010da	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  010df	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  010e4	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  010eb	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR absfsamp$[rsp]
  010f1	f3 0f 11 04 c1	 movss	 DWORD PTR [rcx+rax*8], xmm0
$LN101@psf_sndWri:

; 1714 : 					}
; 1715 : 					lsamp = psf_round(fsamp * MAX_32BIT);

  010f6	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR fsamp$[rsp]
  010fc	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@41e0000000000000
  01104	e8 00 00 00 00	 call	 psf_round
  01109	89 44 24 38	 mov	 DWORD PTR lsamp$[rsp], eax

; 1716 : 					
; 1717 : 					if(wavDoWrite(sfdat,(char *) &lsamp,sizeof(int))){

  0110d	41 b8 04 00 00
	00		 mov	 r8d, 4
  01113	48 8d 54 24 38	 lea	 rdx, QWORD PTR lsamp$[rsp]
  01118	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0111d	e8 00 00 00 00	 call	 wavDoWrite
  01122	85 c0		 test	 eax, eax
  01124	74 0a		 je	 SHORT $LN102@psf_sndWri

; 1718 : 						DBGFPRINTF((stderr, "wavOpenWrite: write error\n"));
; 1719 : 						return PSF_E_CANT_WRITE;

  01126	b8 fd ff ff ff	 mov	 eax, -3
  0112b	e9 96 00 00 00	 jmp	 $LN1@psf_sndWri
$LN102@psf_sndWri:

; 1720 : 					}
; 1721 : 				}			

  01130	e9 93 fe ff ff	 jmp	 $LN51@psf_sndWri
$LN52@psf_sndWri:

; 1722 : 			}			

  01135	e9 50 fe ff ff	 jmp	 $LN48@psf_sndWri
$LN49@psf_sndWri:
$LN98@psf_sndWri:

; 1723 : 		}
; 1724 : 		break;

  0113a	eb 0a		 jmp	 SHORT $LN4@psf_sndWri
$LN103@psf_sndWri:

; 1725 : 	default:
; 1726 : 		DBGFPRINTF((stderr, "wavOpenWrite: unsupported sample format\n"));
; 1727 : 		return PSF_E_UNSUPPORTED;		

  0113c	b8 f8 ff ff ff	 mov	 eax, -8
  01141	e9 80 00 00 00	 jmp	 $LN1@psf_sndWri
$LN4@psf_sndWri:

; 1728 : 
; 1729 : 	}
; 1730 :     POS64(sfdat->lastwritepos) += nFrames;

  01146	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
  0114d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  01152	48 03 81 90 00
	00 00		 add	 rax, QWORD PTR [rcx+144]
  01159	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0115e	48 89 81 90 00
	00 00		 mov	 QWORD PTR [rcx+144], rax

; 1731 : 	sfdat->curframepos = (MYLONG) POS64(sfdat->lastwritepos);

  01165	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  0116a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0116f	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  01175	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 1732 : 	sfdat->nFrames = max(sfdat->nFrames,(DWORD) POS64(sfdat->lastwritepos));

  01178	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  0117d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  01182	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  01188	39 48 14	 cmp	 DWORD PTR [rax+20], ecx
  0118b	76 11		 jbe	 SHORT $LN141@psf_sndWri
  0118d	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  01192	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  01195	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv576[rsp], eax
  0119c	eb 12		 jmp	 SHORT $LN142@psf_sndWri
$LN141@psf_sndWri:
  0119e	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  011a3	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  011a9	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv576[rsp], eax
$LN142@psf_sndWri:
  011b0	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  011b5	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv576[rsp]
  011bc	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 1733 : /*	fflush(sfdat->file); */	/* ? may need this if reading/seeking as well as  write, etc */
; 1734 : 	return nFrames; 

  011bf	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR nFrames$[rsp]
$LN1@psf_sndWri:

; 1735 : 		
; 1736 : }

  011c6	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  011cd	c3		 ret	 0
psf_sndWriteFloatFrames ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
sfdat$ = 0
sfd$ = 32
psf_sndSize PROC

; 3125 : {

$LN6:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 3126 : 	PSFFILE *sfdat;
; 3127 : #ifdef _DEBUG
; 3128 :     fpos_t size;
; 3129 : 	DWORD framesize;
; 3130 : #endif
; 3131 : 	if(sfd < 0 || sfd > psf_maxfiles)

  00008	83 7c 24 20 00	 cmp	 DWORD PTR sfd$[rsp], 0
  0000d	7c 07		 jl	 SHORT $LN3@psf_sndSiz
  0000f	83 7c 24 20 40	 cmp	 DWORD PTR sfd$[rsp], 64	; 00000040H
  00014	7e 07		 jle	 SHORT $LN2@psf_sndSiz
$LN3@psf_sndSiz:

; 3132 : 		return PSF_E_BADARG;

  00016	b8 f6 ff ff ff	 mov	 eax, -10
  0001b	eb 29		 jmp	 SHORT $LN1@psf_sndSiz
$LN2@psf_sndSiz:

; 3133 : 	
; 3134 : 	sfdat  = psf_files[sfd];

  0001d	48 63 44 24 20	 movsxd	 rax, DWORD PTR sfd$[rsp]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:psf_files
  00029	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0002d	48 89 04 24	 mov	 QWORD PTR sfdat$[rsp], rax

; 3135 : 	if(sfdat==NULL)

  00031	48 83 3c 24 00	 cmp	 QWORD PTR sfdat$[rsp], 0
  00036	75 07		 jne	 SHORT $LN4@psf_sndSiz

; 3136 : 		return PSF_E_BADARG;

  00038	b8 f6 ff ff ff	 mov	 eax, -10
  0003d	eb 07		 jmp	 SHORT $LN1@psf_sndSiz
$LN4@psf_sndSiz:

; 3137 : #ifdef _DEBUG		
; 3138 : 	assert(sfdat->file);
; 3139 : 	assert(sfdat->filename);
; 3140 :     /* seems as good a place as any to verify chuncksize integrity of this file...*/
; 3141 : 	if((size = getsize(sfdat->file)) < 0)	{
; 3142 : 		DBGFPRINTF((stderr, "getsize() error in psf_sndSize().\n"));
; 3143 : 		return -1;
; 3144 : 	}
; 3145 :     /* this will reveal if any other chunks etc after (ugh) data chunk */
; 3146 : 	framesize = (DWORD)((POS64(size) - (MYLONG)(sfdat->dataoffset)) / sfdat->fmt.Format.nBlockAlign);
; 3147 : 	assert(framesize >= (DWORD) sfdat->nFrames);
; 3148 : 	
; 3149 : #endif
; 3150 : 	
; 3151 : 	return sfdat->nFrames;

  0003f	48 8b 04 24	 mov	 rax, QWORD PTR sfdat$[rsp]
  00043	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
$LN1@psf_sndSiz:

; 3152 : }

  00046	48 83 c4 18	 add	 rsp, 24
  0004a	c3		 ret	 0
psf_sndSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
rc$ = 32
tv75 = 36
sfdat$ = 40
sfd$ = 64
psf_sndClose PROC

; 1444 : {

$LN15:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1445 : 	int rc = PSF_E_NOERROR;

  00008	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 1446 : 	PSFFILE *sfdat;
; 1447 : 	
; 1448 : 	if(sfd < 0 || sfd > psf_maxfiles)

  00010	83 7c 24 40 00	 cmp	 DWORD PTR sfd$[rsp], 0
  00015	7c 07		 jl	 SHORT $LN5@psf_sndClo
  00017	83 7c 24 40 40	 cmp	 DWORD PTR sfd$[rsp], 64	; 00000040H
  0001c	7e 0a		 jle	 SHORT $LN4@psf_sndClo
$LN5@psf_sndClo:

; 1449 : 		return PSF_E_BADARG;	

  0001e	b8 f6 ff ff ff	 mov	 eax, -10
  00023	e9 c9 00 00 00	 jmp	 $LN1@psf_sndClo
$LN4@psf_sndClo:

; 1450 : 	sfdat  = psf_files[sfd];	

  00028	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfd$[rsp]
  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:psf_files
  00034	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00038	48 89 44 24 28	 mov	 QWORD PTR sfdat$[rsp], rax

; 1451 : #ifdef _DEBUG		
; 1452 : 	assert(sfdat->file);
; 1453 : 	assert(sfdat->filename);
; 1454 : #endif
; 1455 : 	if(sfdat==NULL || sfdat->file==NULL)

  0003d	48 83 7c 24 28
	00		 cmp	 QWORD PTR sfdat$[rsp], 0
  00043	74 0b		 je	 SHORT $LN7@psf_sndClo
  00045	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  0004a	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0004e	75 0a		 jne	 SHORT $LN6@psf_sndClo
$LN7@psf_sndClo:

; 1456 : 		return PSF_E_BADARG;

  00050	b8 f6 ff ff ff	 mov	 eax, -10
  00055	e9 97 00 00 00	 jmp	 $LN1@psf_sndClo
$LN6@psf_sndClo:

; 1457 : 	if(!sfdat->isRead){

  0005a	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  0005f	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00063	75 52		 jne	 SHORT $LN8@psf_sndClo

; 1458 : 		switch(sfdat->riff_format){

  00065	48 8b 44 24 28	 mov	 rax, QWORD PTR sfdat$[rsp]
  0006a	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0006d	89 44 24 24	 mov	 DWORD PTR tv75[rsp], eax
  00071	83 7c 24 24 00	 cmp	 DWORD PTR tv75[rsp], 0
  00076	7e 37		 jle	 SHORT $LN11@psf_sndClo
  00078	83 7c 24 24 02	 cmp	 DWORD PTR tv75[rsp], 2
  0007d	7e 10		 jle	 SHORT $LN9@psf_sndClo
  0007f	83 7c 24 24 02	 cmp	 DWORD PTR tv75[rsp], 2
  00084	7e 29		 jle	 SHORT $LN11@psf_sndClo
  00086	83 7c 24 24 04	 cmp	 DWORD PTR tv75[rsp], 4
  0008b	7e 12		 jle	 SHORT $LN10@psf_sndClo
  0008d	eb 20		 jmp	 SHORT $LN11@psf_sndClo
$LN9@psf_sndClo:

; 1459 : 		case(PSF_STDWAVE):
; 1460 : 		case(PSF_WAVE_EX):
; 1461 : 			rc = wavUpdate(sfdat);

  0008f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00094	e8 00 00 00 00	 call	 wavUpdate
  00099	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1462 : 			break;

  0009d	eb 18		 jmp	 SHORT $LN2@psf_sndClo
$LN10@psf_sndClo:

; 1463 : 		case(PSF_AIFF):
; 1464 : 		case(PSF_AIFC):
; 1465 : 			rc = aiffUpdate(sfdat);

  0009f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sfdat$[rsp]
  000a4	e8 00 00 00 00	 call	 aiffUpdate
  000a9	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1466 : 			break;

  000ad	eb 08		 jmp	 SHORT $LN2@psf_sndClo
$LN11@psf_sndClo:

; 1467 : 		default:
; 1468 : 			rc = PSF_E_CANT_CLOSE;

  000af	c7 44 24 20 fe
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -2
$LN2@psf_sndClo:
$LN8@psf_sndClo:

; 1469 : 			break;
; 1470 : 		}
; 1471 : 	}
; 1472 : 	if(psf_release_file(sfdat))

  000b7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sfdat$[rsp]
  000bc	e8 00 00 00 00	 call	 psf_release_file
  000c1	85 c0		 test	 eax, eax
  000c3	74 0a		 je	 SHORT $LN12@psf_sndClo

; 1473 : 		rc = PSF_E_CANT_CLOSE;

  000c5	c7 44 24 20 fe
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -2
  000cd	eb 1e		 jmp	 SHORT $LN13@psf_sndClo
$LN12@psf_sndClo:

; 1474 :         else {
; 1475 : 	    free(sfdat);

  000cf	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sfdat$[rsp]
  000d4	e8 00 00 00 00	 call	 free

; 1476 : 	    psf_files[sfd]= NULL;

  000d9	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfd$[rsp]
  000de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:psf_files
  000e5	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0
$LN13@psf_sndClo:

; 1477 : 	}
; 1478 : 	return rc;	

  000ed	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@psf_sndClo:

; 1479 : }

  000f1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f5	c3		 ret	 0
psf_sndClose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
rc$ = 32
fmt$ = 36
i$ = 40
tv136 = 44
sfdat$ = 48
tv84 = 56
fname$ = 64
path$ = 96
props$ = 104
rescale$ = 112
psf_sndOpen PROC

; 2718 : {

$LN20:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2719 : 	int i,rc = 0;

  00013	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 2720 : 	PSFFILE *sfdat;	
; 2721 : 	psf_format fmt;
; 2722 : 	char *fname = NULL;

  0001b	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR fname$[rsp], 0

; 2723 : 	
; 2724 : 	/* RWD interesting syntax issue: I need the curlies, or break doesn't work properly */
; 2725 : 	for(i=0;i < psf_maxfiles;i++) {

  00024	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0002c	eb 0a		 jmp	 SHORT $LN4@psf_sndOpe
$LN2@psf_sndOpe:
  0002e	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00032	ff c0		 inc	 eax
  00034	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@psf_sndOpe:
  00038	83 7c 24 28 40	 cmp	 DWORD PTR i$[rsp], 64	; 00000040H
  0003d	7d 17		 jge	 SHORT $LN3@psf_sndOpe

; 2726 : 		if(psf_files[i]==NULL)

  0003f	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:psf_files
  0004b	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00050	75 02		 jne	 SHORT $LN7@psf_sndOpe

; 2727 : 			break;

  00052	eb 02		 jmp	 SHORT $LN3@psf_sndOpe
$LN7@psf_sndOpe:

; 2728 : 	}

  00054	eb d8		 jmp	 SHORT $LN2@psf_sndOpe
$LN3@psf_sndOpe:

; 2729 : 	if(i==psf_maxfiles){

  00056	83 7c 24 28 40	 cmp	 DWORD PTR i$[rsp], 64	; 00000040H
  0005b	75 0a		 jne	 SHORT $LN8@psf_sndOpe

; 2730 : 		return PSF_E_TOOMANYFILES;

  0005d	b8 f4 ff ff ff	 mov	 eax, -12
  00062	e9 02 02 00 00	 jmp	 $LN1@psf_sndOpe
$LN8@psf_sndOpe:

; 2731 : 	}
; 2732 : 
; 2733 : 	sfdat = psf_newFile(NULL);

  00067	33 c9		 xor	 ecx, ecx
  00069	e8 00 00 00 00	 call	 psf_newFile
  0006e	48 89 44 24 30	 mov	 QWORD PTR sfdat$[rsp], rax

; 2734 : 	if(sfdat==NULL){		

  00073	48 83 7c 24 30
	00		 cmp	 QWORD PTR sfdat$[rsp], 0
  00079	75 0a		 jne	 SHORT $LN9@psf_sndOpe

; 2735 : 		return PSF_E_NOMEM;

  0007b	b8 f7 ff ff ff	 mov	 eax, -9
  00080	e9 e4 01 00 00	 jmp	 $LN1@psf_sndOpe
$LN9@psf_sndOpe:

; 2736 : 	}	
; 2737 : 	sfdat->rescale = rescale;	

  00085	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  0008a	8b 4c 24 70	 mov	 ecx, DWORD PTR rescale$[rsp]
  0008e	89 48 20	 mov	 DWORD PTR [rax+32], ecx

; 2738 : 	sfdat->is_little_endian = byte_order();

  00091	e8 00 00 00 00	 call	 byte_order
  00096	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0009b	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 2739 : 	fmt = psf_getFormatExt(path);

  0009e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR path$[rsp]
  000a3	e8 00 00 00 00	 call	 psf_getFormatExt
  000a8	89 44 24 24	 mov	 DWORD PTR fmt$[rsp], eax

; 2740 : 	if(!(fmt==PSF_STDWAVE || fmt==PSF_WAVE_EX || fmt==PSF_AIFF || fmt==PSF_AIFC))

  000ac	83 7c 24 24 01	 cmp	 DWORD PTR fmt$[rsp], 1
  000b1	74 1f		 je	 SHORT $LN10@psf_sndOpe
  000b3	83 7c 24 24 02	 cmp	 DWORD PTR fmt$[rsp], 2
  000b8	74 18		 je	 SHORT $LN10@psf_sndOpe
  000ba	83 7c 24 24 03	 cmp	 DWORD PTR fmt$[rsp], 3
  000bf	74 11		 je	 SHORT $LN10@psf_sndOpe
  000c1	83 7c 24 24 04	 cmp	 DWORD PTR fmt$[rsp], 4
  000c6	74 0a		 je	 SHORT $LN10@psf_sndOpe

; 2741 : 		return PSF_E_BADARG;	

  000c8	b8 f6 ff ff ff	 mov	 eax, -10
  000cd	e9 97 01 00 00	 jmp	 $LN1@psf_sndOpe
$LN10@psf_sndOpe:

; 2742 : 
; 2743 : 	if((sfdat->file = fopen(path,"rb"))  == NULL) {

  000d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11160
  000d9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR path$[rsp]
  000de	e8 00 00 00 00	 call	 fopen
  000e3	48 89 44 24 38	 mov	 QWORD PTR tv84[rsp], rax
  000e8	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  000ed	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv84[rsp]
  000f2	48 89 08	 mov	 QWORD PTR [rax], rcx
  000f5	48 83 7c 24 38
	00		 cmp	 QWORD PTR tv84[rsp], 0
  000fb	75 0a		 jne	 SHORT $LN11@psf_sndOpe

; 2744 : 		DBGFPRINTF((stderr, "psf_sndOpen: cannot open '%s'\n", path));
; 2745 :         return PSF_E_CANT_OPEN;

  000fd	b8 ff ff ff ff	 mov	 eax, -1
  00102	e9 62 01 00 00	 jmp	 $LN1@psf_sndOpe
$LN11@psf_sndOpe:

; 2746 : 	}
; 2747 : 	sfdat->filename = (char *) malloc(strlen(path)+1);

  00107	48 8b 4c 24 60	 mov	 rcx, QWORD PTR path$[rsp]
  0010c	e8 00 00 00 00	 call	 strlen
  00111	48 ff c0	 inc	 rax
  00114	48 8b c8	 mov	 rcx, rax
  00117	e8 00 00 00 00	 call	 malloc
  0011c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00121	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 2748 : 	if(sfdat->filename==NULL) {		

  00125	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  0012a	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0012f	75 0a		 jne	 SHORT $LN12@psf_sndOpe

; 2749 : 		return PSF_E_NOMEM;

  00131	b8 f7 ff ff ff	 mov	 eax, -9
  00136	e9 2e 01 00 00	 jmp	 $LN1@psf_sndOpe
$LN12@psf_sndOpe:

; 2750 : 	}
; 2751 :     strcpy(sfdat->filename, path);

  0013b	48 8b 54 24 60	 mov	 rdx, QWORD PTR path$[rsp]
  00140	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00145	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00149	e8 00 00 00 00	 call	 strcpy

; 2752 :     sfdat->isRead =  1;	

  0014e	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  00153	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [rax+24], 1

; 2753 : 	sfdat->nFrames = 0;

  0015a	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  0015f	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0

; 2754 : 	/* no need to calc header sizes */
; 2755 : 	switch(fmt){

  00166	8b 44 24 24	 mov	 eax, DWORD PTR fmt$[rsp]
  0016a	89 44 24 2c	 mov	 DWORD PTR tv136[rsp], eax
  0016e	83 7c 24 2c 00	 cmp	 DWORD PTR tv136[rsp], 0
  00173	7e 59		 jle	 SHORT $LN16@psf_sndOpe
  00175	83 7c 24 2c 02	 cmp	 DWORD PTR tv136[rsp], 2
  0017a	7e 10		 jle	 SHORT $LN13@psf_sndOpe
  0017c	83 7c 24 2c 02	 cmp	 DWORD PTR tv136[rsp], 2
  00181	7e 4b		 jle	 SHORT $LN16@psf_sndOpe
  00183	83 7c 24 2c 04	 cmp	 DWORD PTR tv136[rsp], 4
  00188	7e 12		 jle	 SHORT $LN14@psf_sndOpe
  0018a	eb 42		 jmp	 SHORT $LN16@psf_sndOpe
$LN13@psf_sndOpe:

; 2756 : 	case(PSF_STDWAVE):
; 2757 :     case(PSF_WAVE_EX):
; 2758 : 		rc =  wavReadHeader(sfdat);

  0018c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00191	e8 00 00 00 00	 call	 wavReadHeader
  00196	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 2759 : 		break;

  0019a	eb 3a		 jmp	 SHORT $LN5@psf_sndOpe
$LN14@psf_sndOpe:

; 2760 : 	case(PSF_AIFF):
; 2761 :     /* some .aiff files may actually be aifc - esp if floats! */
; 2762 :     case(PSF_AIFC):
; 2763 : 		rc = aiffReadHeader(sfdat);

  0019c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  001a1	e8 00 00 00 00	 call	 aiffReadHeader
  001a6	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 2764 : 		/* try AIFC if AIFF fails */
; 2765 : 		if(rc < PSF_E_NOERROR) {

  001aa	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  001af	7d 1b		 jge	 SHORT $LN15@psf_sndOpe

; 2766 : 			rewind(sfdat->file);

  001b1	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  001b6	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001b9	e8 00 00 00 00	 call	 rewind

; 2767 : 			rc =  aifcReadHeader(sfdat);

  001be	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  001c3	e8 00 00 00 00	 call	 aifcReadHeader
  001c8	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
$LN15@psf_sndOpe:

; 2768 : 		}
; 2769 : 		break;

  001cc	eb 08		 jmp	 SHORT $LN5@psf_sndOpe
$LN16@psf_sndOpe:

; 2770 : 	default:
; 2771 : 		DBGFPRINTF((stderr, "psf_sndOpen: unsupported file format\n"));
; 2772 : 		rc =  PSF_E_UNSUPPORTED;

  001ce	c7 44 24 20 f8
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -8
$LN5@psf_sndOpe:

; 2773 : 	}
; 2774 : 	if(rc < PSF_E_NOERROR)

  001d6	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  001db	7d 09		 jge	 SHORT $LN17@psf_sndOpe

; 2775 : 		return rc;

  001dd	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  001e1	e9 83 00 00 00	 jmp	 $LN1@psf_sndOpe
$LN17@psf_sndOpe:

; 2776 : 	/* fill props info*/
; 2777 : 	props->srate	= sfdat->fmt.Format.nSamplesPerSec;

  001e6	48 8b 44 24 68	 mov	 rax, QWORD PTR props$[rsp]
  001eb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  001f0	8b 49 54	 mov	 ecx, DWORD PTR [rcx+84]
  001f3	89 08		 mov	 DWORD PTR [rax], ecx

; 2778 : 	props->chans	= sfdat->fmt.Format.nChannels;

  001f5	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  001fa	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  001fe	48 8b 4c 24 68	 mov	 rcx, QWORD PTR props$[rsp]
  00203	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 2779 : 	props->samptype = sfdat->samptype;	

  00206	48 8b 44 24 68	 mov	 rax, QWORD PTR props$[rsp]
  0020b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00210	8b 49 30	 mov	 ecx, DWORD PTR [rcx+48]
  00213	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 2780 : 	props->chformat = sfdat->chformat;

  00216	48 8b 44 24 68	 mov	 rax, QWORD PTR props$[rsp]
  0021b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00220	8b 49 7c	 mov	 ecx, DWORD PTR [rcx+124]
  00223	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 2781 : 	props->format      =  fmt;

  00226	48 8b 44 24 68	 mov	 rax, QWORD PTR props$[rsp]
  0022b	8b 4c 24 24	 mov	 ecx, DWORD PTR fmt$[rsp]
  0022f	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 2782 : 	if(fmt==PSF_STDWAVE && (sfdat->riff_format == PSF_WAVE_EX))	 

  00232	83 7c 24 24 01	 cmp	 DWORD PTR fmt$[rsp], 1
  00237	75 17		 jne	 SHORT $LN18@psf_sndOpe
  00239	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  0023e	83 78 28 02	 cmp	 DWORD PTR [rax+40], 2
  00242	75 0c		 jne	 SHORT $LN18@psf_sndOpe

; 2783 : 		props->format = PSF_WAVE_EX;

  00244	48 8b 44 24 68	 mov	 rax, QWORD PTR props$[rsp]
  00249	c7 40 0c 02 00
	00 00		 mov	 DWORD PTR [rax+12], 2
$LN18@psf_sndOpe:

; 2784 : 
; 2785 : 	psf_files[i] = sfdat;

  00250	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  00255	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:psf_files
  0025c	48 8b 54 24 30	 mov	 rdx, QWORD PTR sfdat$[rsp]
  00261	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 2786 : 	return i;

  00265	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
$LN1@psf_sndOpe:

; 2787 : }

  00269	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0026d	c3		 ret	 0
psf_sndOpen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
fmt$ = 32
i$ = 36
rc$ = 40
tv155 = 44
sfdat$ = 48
fmtstr$ = 56
tv139 = 64
path$ = 96
props$ = 104
clip_floats$ = 112
minheader$ = 120
mode$ = 128
psf_sndCreate PROC

; 1352 : {		

$LN29:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1353 : 	int i,rc = PSF_E_UNSUPPORTED;

  00018	c7 44 24 28 f8
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -8

; 1354 : 	psf_format fmt;
; 1355 : 	PSFFILE *sfdat;
; 1356 : 	char *fmtstr = "wb+";	/* default is READ+WRITE */

  00020	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG10269
  00027	48 89 44 24 38	 mov	 QWORD PTR fmtstr$[rsp], rax

; 1357 : 	/*  disallow props = NULL here, until/unless I can offer mechanism to set default props via psf_init() */
; 1358 : 	if(path == NULL || props == NULL)

  0002c	48 83 7c 24 60
	00		 cmp	 QWORD PTR path$[rsp], 0
  00032	74 08		 je	 SHORT $LN8@psf_sndCre
  00034	48 83 7c 24 68
	00		 cmp	 QWORD PTR props$[rsp], 0
  0003a	75 0a		 jne	 SHORT $LN7@psf_sndCre
$LN8@psf_sndCre:

; 1359 : 		return PSF_E_BADARG;

  0003c	b8 f6 ff ff ff	 mov	 eax, -10
  00041	e9 65 02 00 00	 jmp	 $LN1@psf_sndCre
$LN7@psf_sndCre:

; 1360 : 
; 1361 : 	for(i=0; i < psf_maxfiles; i++) {

  00046	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0004e	eb 0a		 jmp	 SHORT $LN4@psf_sndCre
$LN2@psf_sndCre:
  00050	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  00054	ff c0		 inc	 eax
  00056	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@psf_sndCre:
  0005a	83 7c 24 24 40	 cmp	 DWORD PTR i$[rsp], 64	; 00000040H
  0005f	7d 17		 jge	 SHORT $LN3@psf_sndCre

; 1362 : 		if(psf_files[i] == NULL)

  00061	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:psf_files
  0006d	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00072	75 02		 jne	 SHORT $LN9@psf_sndCre

; 1363 : 			break;

  00074	eb 02		 jmp	 SHORT $LN3@psf_sndCre
$LN9@psf_sndCre:

; 1364 : 	}

  00076	eb d8		 jmp	 SHORT $LN2@psf_sndCre
$LN3@psf_sndCre:

; 1365 : 	if(i==psf_maxfiles)		

  00078	83 7c 24 24 40	 cmp	 DWORD PTR i$[rsp], 64	; 00000040H
  0007d	75 0a		 jne	 SHORT $LN10@psf_sndCre

; 1366 : 		return PSF_E_TOOMANYFILES;

  0007f	b8 f4 ff ff ff	 mov	 eax, -12
  00084	e9 22 02 00 00	 jmp	 $LN1@psf_sndCre
$LN10@psf_sndCre:

; 1367 : 
; 1368 : 	sfdat = psf_newFile(props);

  00089	48 8b 4c 24 68	 mov	 rcx, QWORD PTR props$[rsp]
  0008e	e8 00 00 00 00	 call	 psf_newFile
  00093	48 89 44 24 30	 mov	 QWORD PTR sfdat$[rsp], rax

; 1369 : 	if(sfdat == NULL)		

  00098	48 83 7c 24 30
	00		 cmp	 QWORD PTR sfdat$[rsp], 0
  0009e	75 0a		 jne	 SHORT $LN11@psf_sndCre

; 1370 : 		return PSF_E_NOMEM;

  000a0	b8 f7 ff ff ff	 mov	 eax, -9
  000a5	e9 01 02 00 00	 jmp	 $LN1@psf_sndCre
$LN11@psf_sndCre:

; 1371 : 	
; 1372 : 	sfdat->clip_floats = clip_floats;	

  000aa	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  000af	8b 4c 24 70	 mov	 ecx, DWORD PTR clip_floats$[rsp]
  000b3	89 48 1c	 mov	 DWORD PTR [rax+28], ecx

; 1373 : 	fmt = psf_getFormatExt(path);		

  000b6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR path$[rsp]
  000bb	e8 00 00 00 00	 call	 psf_getFormatExt
  000c0	89 44 24 20	 mov	 DWORD PTR fmt$[rsp], eax

; 1374 : 	if(fmt==PSF_FMT_UNKNOWN)

  000c4	83 7c 24 20 00	 cmp	 DWORD PTR fmt$[rsp], 0
  000c9	75 0a		 jne	 SHORT $LN12@psf_sndCre

; 1375 : 		return PSF_E_UNSUPPORTED;

  000cb	b8 f8 ff ff ff	 mov	 eax, -8
  000d0	e9 d6 01 00 00	 jmp	 $LN1@psf_sndCre
$LN12@psf_sndCre:

; 1376 : 	if(sfdat->samptype == PSF_SAMP_UNKNOWN)

  000d5	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  000da	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  000de	75 0a		 jne	 SHORT $LN13@psf_sndCre

; 1377 : 		return PSF_E_BADARG;

  000e0	b8 f6 ff ff ff	 mov	 eax, -10
  000e5	e9 c1 01 00 00	 jmp	 $LN1@psf_sndCre
$LN13@psf_sndCre:

; 1378 : 
; 1379 : 	sfdat->filename = (char *) malloc(strlen(path)+1);

  000ea	48 8b 4c 24 60	 mov	 rcx, QWORD PTR path$[rsp]
  000ef	e8 00 00 00 00	 call	 strlen
  000f4	48 ff c0	 inc	 rax
  000f7	48 8b c8	 mov	 rcx, rax
  000fa	e8 00 00 00 00	 call	 malloc
  000ff	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  00104	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1380 : 	if(sfdat->filename==NULL) {

  00108	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  0010d	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00112	75 0a		 jne	 SHORT $LN14@psf_sndCre

; 1381 : 		DBGFPRINTF((stderr, "wavOpenWrite: no memory for filename\n"));
; 1382 : 		return PSF_E_NOMEM;

  00114	b8 f7 ff ff ff	 mov	 eax, -9
  00119	e9 8d 01 00 00	 jmp	 $LN1@psf_sndCre
$LN14@psf_sndCre:

; 1383 : 	}
; 1384 : 	if(!minheader){

  0011e	83 7c 24 78 00	 cmp	 DWORD PTR minheader$[rsp], 0
  00123	75 3a		 jne	 SHORT $LN15@psf_sndCre

; 1385 : 		sfdat->pPeaks = (PSF_CHPEAK *) malloc(sizeof(PSF_CHPEAK) * sfdat->fmt.Format.nChannels);

  00125	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  0012a	0f b7 40 52	 movzx	 eax, WORD PTR [rax+82]
  0012e	48 c1 e0 03	 shl	 rax, 3
  00132	48 8b c8	 mov	 rcx, rax
  00135	e8 00 00 00 00	 call	 malloc
  0013a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0013f	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 1386 : 		if(sfdat->pPeaks==NULL){

  00146	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  0014b	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00153	75 0a		 jne	 SHORT $LN16@psf_sndCre

; 1387 : 			DBGFPRINTF((stderr, "wavOpenWrite: no memory for peak data\n"));
; 1388 : 			return PSF_E_NOMEM;

  00155	b8 f7 ff ff ff	 mov	 eax, -9
  0015a	e9 4c 01 00 00	 jmp	 $LN1@psf_sndCre
$LN16@psf_sndCre:
$LN15@psf_sndCre:

; 1389 : 		}
; 1390 : 	}
; 1391 : 	/*switch (mode).... */
; 1392 : 	if(mode==PSF_CREATE_WRONLY)

  0015f	83 bc 24 80 00
	00 00 02	 cmp	 DWORD PTR mode$[rsp], 2
  00167	75 0c		 jne	 SHORT $LN17@psf_sndCre

; 1393 : 		fmtstr = "wb";

  00169	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG10281
  00170	48 89 44 24 38	 mov	 QWORD PTR fmtstr$[rsp], rax
$LN17@psf_sndCre:

; 1394 : 	/* deal with CREATE_TEMPORARY later on! */
; 1395 : 	if((sfdat->file = fopen(path,fmtstr))  == NULL) {

  00175	48 8b 54 24 38	 mov	 rdx, QWORD PTR fmtstr$[rsp]
  0017a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR path$[rsp]
  0017f	e8 00 00 00 00	 call	 fopen
  00184	48 89 44 24 40	 mov	 QWORD PTR tv139[rsp], rax
  00189	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  0018e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv139[rsp]
  00193	48 89 08	 mov	 QWORD PTR [rax], rcx
  00196	48 83 7c 24 40
	00		 cmp	 QWORD PTR tv139[rsp], 0
  0019c	75 0a		 jne	 SHORT $LN18@psf_sndCre

; 1396 : 		DBGFPRINTF((stderr, "wavOpenWrite: cannot create '%s'\n", path));
; 1397 :         return PSF_E_CANT_OPEN;

  0019e	b8 ff ff ff ff	 mov	 eax, -1
  001a3	e9 03 01 00 00	 jmp	 $LN1@psf_sndCre
$LN18@psf_sndCre:

; 1398 : 	}
; 1399 : 	
; 1400 :     strcpy(sfdat->filename, path);

  001a8	48 8b 54 24 60	 mov	 rdx, QWORD PTR path$[rsp]
  001ad	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  001b2	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  001b6	e8 00 00 00 00	 call	 strcpy

; 1401 :     sfdat->isRead = 0;    	

  001bb	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  001c0	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 1402 : 	sfdat->nFrames = 0;

  001c7	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  001cc	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0

; 1403 : 	/* force aif f/p data to go to aifc format */
; 1404 : 	if(sfdat->samptype==PSF_SAMP_IEEE_FLOAT && fmt==PSF_AIFF){

  001d3	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  001d8	83 78 30 05	 cmp	 DWORD PTR [rax+48], 5
  001dc	75 0f		 jne	 SHORT $LN19@psf_sndCre
  001de	83 7c 24 20 03	 cmp	 DWORD PTR fmt$[rsp], 3
  001e3	75 08		 jne	 SHORT $LN19@psf_sndCre

; 1405 : 		DBGFPRINTF((stderr, "Warning: writing floating point data in AIFC format\n"));
; 1406 : 		fmt= PSF_AIFC;

  001e5	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR fmt$[rsp], 4
$LN19@psf_sndCre:

; 1407 : 	}
; 1408 : 	/* .wav extension can be either std WAVE or WAVE-EX */
; 1409 : 	if(fmt==PSF_STDWAVE){

  001ed	83 7c 24 20 01	 cmp	 DWORD PTR fmt$[rsp], 1
  001f2	75 13		 jne	 SHORT $LN20@psf_sndCre

; 1410 : 		if(props->format==PSF_WAVE_EX)

  001f4	48 8b 44 24 68	 mov	 rax, QWORD PTR props$[rsp]
  001f9	83 78 0c 02	 cmp	 DWORD PTR [rax+12], 2
  001fd	75 08		 jne	 SHORT $LN21@psf_sndCre

; 1411 : 			fmt = PSF_WAVE_EX;

  001ff	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR fmt$[rsp], 2
$LN21@psf_sndCre:
$LN20@psf_sndCre:

; 1412 : 	}
; 1413 : 	sfdat->riff_format = fmt;

  00207	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  0020c	8b 4c 24 20	 mov	 ecx, DWORD PTR fmt$[rsp]
  00210	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 1414 : 
; 1415 : 	switch(fmt){

  00213	8b 44 24 20	 mov	 eax, DWORD PTR fmt$[rsp]
  00217	89 44 24 2c	 mov	 DWORD PTR tv155[rsp], eax
  0021b	83 7c 24 2c 01	 cmp	 DWORD PTR tv155[rsp], 1
  00220	74 17		 je	 SHORT $LN22@psf_sndCre
  00222	83 7c 24 2c 02	 cmp	 DWORD PTR tv155[rsp], 2
  00227	74 40		 je	 SHORT $LN25@psf_sndCre
  00229	83 7c 24 2c 03	 cmp	 DWORD PTR tv155[rsp], 3
  0022e	74 19		 je	 SHORT $LN23@psf_sndCre
  00230	83 7c 24 2c 04	 cmp	 DWORD PTR tv155[rsp], 4
  00235	74 22		 je	 SHORT $LN24@psf_sndCre
  00237	eb 40		 jmp	 SHORT $LN26@psf_sndCre
$LN22@psf_sndCre:

; 1416 : 	case(PSF_STDWAVE):		
; 1417 : 		rc = wavWriteHeader(sfdat);

  00239	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0023e	e8 00 00 00 00	 call	 wavWriteHeader
  00243	89 44 24 28	 mov	 DWORD PTR rc$[rsp], eax

; 1418 : 		break;

  00247	eb 3c		 jmp	 SHORT $LN5@psf_sndCre
$LN23@psf_sndCre:

; 1419 : 	case(PSF_AIFF):
; 1420 : 		
; 1421 : 		rc = aiffWriteHeader(sfdat);

  00249	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0024e	e8 00 00 00 00	 call	 aiffWriteHeader
  00253	89 44 24 28	 mov	 DWORD PTR rc$[rsp], eax

; 1422 : 		break;

  00257	eb 2c		 jmp	 SHORT $LN5@psf_sndCre
$LN24@psf_sndCre:

; 1423 : 	case(PSF_AIFC):
; 1424 : 		
; 1425 : 		rc = aifcWriteHeader(sfdat);

  00259	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0025e	e8 00 00 00 00	 call	 aifcWriteHeader
  00263	89 44 24 28	 mov	 DWORD PTR rc$[rsp], eax

; 1426 : 		break;

  00267	eb 1c		 jmp	 SHORT $LN5@psf_sndCre
$LN25@psf_sndCre:

; 1427 : 	case (PSF_WAVE_EX):		
; 1428 : 		rc = waveExWriteHeader(sfdat);

  00269	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sfdat$[rsp]
  0026e	e8 00 00 00 00	 call	 waveExWriteHeader
  00273	89 44 24 28	 mov	 DWORD PTR rc$[rsp], eax

; 1429 : 		break;

  00277	eb 0c		 jmp	 SHORT $LN5@psf_sndCre
$LN26@psf_sndCre:

; 1430 : 	default:
; 1431 : 		sfdat->riff_format = PSF_FMT_UNKNOWN;

  00279	48 8b 44 24 30	 mov	 rax, QWORD PTR sfdat$[rsp]
  0027e	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [rax+40], 0
$LN5@psf_sndCre:

; 1432 : 		/* RAW? */
; 1433 : 		break;
; 1434 : 	}
; 1435 : 	if(rc < PSF_E_NOERROR)

  00285	83 7c 24 28 00	 cmp	 DWORD PTR rc$[rsp], 0
  0028a	7d 06		 jge	 SHORT $LN27@psf_sndCre

; 1436 : 		return rc;

  0028c	8b 44 24 28	 mov	 eax, DWORD PTR rc$[rsp]
  00290	eb 19		 jmp	 SHORT $LN1@psf_sndCre
$LN27@psf_sndCre:

; 1437 : 	psf_files[i] = sfdat;

  00292	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00297	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:psf_files
  0029e	48 8b 54 24 30	 mov	 rdx, QWORD PTR sfdat$[rsp]
  002a3	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 1438 : 	return i;

  002a7	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
$LN1@psf_sndCre:

; 1439 : }

  002ab	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002af	c3		 ret	 0
psf_sndCreate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
i$ = 32
rc$ = 36
psf_finish PROC

; 277  : {

$LN8:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 278  : 	int i,rc = 0;

  00004	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 279  : 	for(i=0;i < psf_maxfiles;i++) {

  0000c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00014	eb 0a		 jmp	 SHORT $LN4@psf_finish
$LN2@psf_finish:
  00016	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0001a	ff c0		 inc	 eax
  0001c	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@psf_finish:
  00020	83 7c 24 20 40	 cmp	 DWORD PTR i$[rsp], 64	; 00000040H
  00025	7d 64		 jge	 SHORT $LN3@psf_finish

; 280  : 		if(psf_files[i]!= NULL){			

  00027	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:psf_files
  00033	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00038	74 26		 je	 SHORT $LN5@psf_finish

; 281  : #ifdef _DEBUG
; 282  : 			printf("sfile %s not closed: closing.\n",psf_files[i]->filename);
; 283  : #endif
; 284  :             rc = psf_release_file(psf_files[i]);

  0003a	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:psf_files
  00046	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0004a	e8 00 00 00 00	 call	 psf_release_file
  0004f	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 285  :             /* an alternative is to continue, and write error info to a logfile */
; 286  :             if(rc)

  00053	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  00058	74 06		 je	 SHORT $LN6@psf_finish

; 287  :                 return rc;

  0005a	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
  0005e	eb 2f		 jmp	 SHORT $LN1@psf_finish
$LN6@psf_finish:
$LN5@psf_finish:

; 288  : 				
; 289  : 		}
; 290  : 		free(psf_files[i]);

  00060	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00065	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:psf_files
  0006c	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00070	e8 00 00 00 00	 call	 free

; 291  : 		psf_files[i] = NULL;

  00075	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:psf_files
  00081	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0

; 292  : 	}

  00089	eb 8b		 jmp	 SHORT $LN2@psf_finish
$LN3@psf_finish:

; 293  : 	return rc;

  0008b	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@psf_finish:

; 294  : }

  0008f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00093	c3		 ret	 0
psf_finish ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
i$ = 0
psf_init PROC

; 241  : {

$LN6:
  00000	48 83 ec 18	 sub	 rsp, 24

; 242  : 	int i;
; 243  : 
; 244  : 	for(i=0;i < psf_maxfiles;i++)		

  00004	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  0000b	eb 08		 jmp	 SHORT $LN4@psf_init
$LN2@psf_init:
  0000d	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00010	ff c0		 inc	 eax
  00012	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@psf_init:
  00015	83 3c 24 40	 cmp	 DWORD PTR i$[rsp], 64	; 00000040H
  00019	7d 15		 jge	 SHORT $LN3@psf_init

; 245  : 		psf_files[i] = NULL;

  0001b	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:psf_files
  00026	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0
  0002e	eb dd		 jmp	 SHORT $LN2@psf_init
$LN3@psf_init:

; 246  : 	/* do any other inits we need.... */
; 247  : 	return 0;

  00030	33 c0		 xor	 eax, eax

; 248  : }

  00032	48 83 c4 18	 add	 rsp, 24
  00036	c3		 ret	 0
psf_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
time	PROC

; 534  :         {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 535  :             return _time64(_Time);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Time$[rsp]
  0000e	e8 00 00 00 00	 call	 _time64

; 536  :         }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
len$ = 32
tv76 = 36
tv85 = 40
cb$1 = 44
ca$2 = 48
tv88 = 52
a$ = 80
b$ = 88
length$ = 96
strnicmp PROC

; 499  : {

$LN14:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 500  : 	int len = length;

  00013	8b 44 24 60	 mov	 eax, DWORD PTR length$[rsp]
  00017	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax
$LN2@strnicmp:

; 501  : 
; 502  : 	while(*a != '\0' && *b != '\0') {

  0001b	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00020	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00023	85 c0		 test	 eax, eax
  00025	0f 84 e6 00 00
	00		 je	 $LN3@strnicmp
  0002b	48 8b 44 24 58	 mov	 rax, QWORD PTR b$[rsp]
  00030	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00033	85 c0		 test	 eax, eax
  00035	0f 84 d6 00 00
	00		 je	 $LN3@strnicmp

; 503  : 		int ca = islower(*a) ? toupper(*a) : *a;

  0003b	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00040	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00043	8b c8		 mov	 ecx, eax
  00045	e8 00 00 00 00	 call	 islower
  0004a	85 c0		 test	 eax, eax
  0004c	74 15		 je	 SHORT $LN10@strnicmp
  0004e	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00053	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00056	8b c8		 mov	 ecx, eax
  00058	e8 00 00 00 00	 call	 toupper
  0005d	89 44 24 24	 mov	 DWORD PTR tv76[rsp], eax
  00061	eb 0c		 jmp	 SHORT $LN11@strnicmp
$LN10@strnicmp:
  00063	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00068	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0006b	89 44 24 24	 mov	 DWORD PTR tv76[rsp], eax
$LN11@strnicmp:
  0006f	8b 44 24 24	 mov	 eax, DWORD PTR tv76[rsp]
  00073	89 44 24 30	 mov	 DWORD PTR ca$2[rsp], eax

; 504  : 		int cb = islower(*b) ? toupper(*b) : *b;

  00077	48 8b 44 24 58	 mov	 rax, QWORD PTR b$[rsp]
  0007c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0007f	8b c8		 mov	 ecx, eax
  00081	e8 00 00 00 00	 call	 islower
  00086	85 c0		 test	 eax, eax
  00088	74 15		 je	 SHORT $LN12@strnicmp
  0008a	48 8b 44 24 58	 mov	 rax, QWORD PTR b$[rsp]
  0008f	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00092	8b c8		 mov	 ecx, eax
  00094	e8 00 00 00 00	 call	 toupper
  00099	89 44 24 28	 mov	 DWORD PTR tv85[rsp], eax
  0009d	eb 0c		 jmp	 SHORT $LN13@strnicmp
$LN12@strnicmp:
  0009f	48 8b 44 24 58	 mov	 rax, QWORD PTR b$[rsp]
  000a4	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000a7	89 44 24 28	 mov	 DWORD PTR tv85[rsp], eax
$LN13@strnicmp:
  000ab	8b 44 24 28	 mov	 eax, DWORD PTR tv85[rsp]
  000af	89 44 24 2c	 mov	 DWORD PTR cb$1[rsp], eax

; 505  : 
; 506  : 		if(len-- < 1)

  000b3	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  000b7	89 44 24 34	 mov	 DWORD PTR tv88[rsp], eax
  000bb	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  000bf	ff c8		 dec	 eax
  000c1	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax
  000c5	83 7c 24 34 01	 cmp	 DWORD PTR tv88[rsp], 1
  000ca	7d 04		 jge	 SHORT $LN4@strnicmp

; 507  : 			return 0;

  000cc	33 c0		 xor	 eax, eax
  000ce	eb 75		 jmp	 SHORT $LN1@strnicmp
$LN4@strnicmp:

; 508  : 
; 509  : 		if(ca < cb)

  000d0	8b 44 24 2c	 mov	 eax, DWORD PTR cb$1[rsp]
  000d4	39 44 24 30	 cmp	 DWORD PTR ca$2[rsp], eax
  000d8	7d 07		 jge	 SHORT $LN5@strnicmp

; 510  : 			return -1;

  000da	b8 ff ff ff ff	 mov	 eax, -1
  000df	eb 64		 jmp	 SHORT $LN1@strnicmp
$LN5@strnicmp:

; 511  : 		if(ca > cb)

  000e1	8b 44 24 2c	 mov	 eax, DWORD PTR cb$1[rsp]
  000e5	39 44 24 30	 cmp	 DWORD PTR ca$2[rsp], eax
  000e9	7e 07		 jle	 SHORT $LN6@strnicmp

; 512  : 			return 1;

  000eb	b8 01 00 00 00	 mov	 eax, 1
  000f0	eb 53		 jmp	 SHORT $LN1@strnicmp
$LN6@strnicmp:

; 513  : 
; 514  : 		a++;

  000f2	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  000f7	48 ff c0	 inc	 rax
  000fa	48 89 44 24 50	 mov	 QWORD PTR a$[rsp], rax

; 515  : 		b++;

  000ff	48 8b 44 24 58	 mov	 rax, QWORD PTR b$[rsp]
  00104	48 ff c0	 inc	 rax
  00107	48 89 44 24 58	 mov	 QWORD PTR b$[rsp], rax

; 516  : 	}

  0010c	e9 0a ff ff ff	 jmp	 $LN2@strnicmp
$LN3@strnicmp:

; 517  : 	if(*a == '\0' && *b == '\0')

  00111	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00116	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00119	85 c0		 test	 eax, eax
  0011b	75 10		 jne	 SHORT $LN7@strnicmp
  0011d	48 8b 44 24 58	 mov	 rax, QWORD PTR b$[rsp]
  00122	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00125	85 c0		 test	 eax, eax
  00127	75 04		 jne	 SHORT $LN7@strnicmp

; 518  : 		return 0;

  00129	33 c0		 xor	 eax, eax
  0012b	eb 18		 jmp	 SHORT $LN1@strnicmp
$LN7@strnicmp:

; 519  : 	if(*a != '\0')

  0012d	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00132	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00135	85 c0		 test	 eax, eax
  00137	74 07		 je	 SHORT $LN8@strnicmp

; 520  : 		return 1;

  00139	b8 01 00 00 00	 mov	 eax, 1
  0013e	eb 05		 jmp	 SHORT $LN1@strnicmp
$LN8@strnicmp:

; 521  : 	return -1;

  00140	b8 ff ff ff ff	 mov	 eax, -1
$LN1@strnicmp:

; 522  : }

  00145	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00149	c3		 ret	 0
strnicmp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\misc\psfmaster\portsf\portsf.c
_TEXT	SEGMENT
tv76 = 32
tv85 = 36
cb$1 = 40
ca$2 = 44
a$ = 64
b$ = 72
stricmp	PROC

; 478  : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN2@stricmp:

; 479  : 	while(*a != '\0' && *b != '\0') {

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  00013	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00016	85 c0		 test	 eax, eax
  00018	0f 84 c9 00 00
	00		 je	 $LN3@stricmp
  0001e	48 8b 44 24 48	 mov	 rax, QWORD PTR b$[rsp]
  00023	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00026	85 c0		 test	 eax, eax
  00028	0f 84 b9 00 00
	00		 je	 $LN3@stricmp

; 480  : 		int ca = islower(*a) ? toupper(*a) : *a;

  0002e	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  00033	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00036	8b c8		 mov	 ecx, eax
  00038	e8 00 00 00 00	 call	 islower
  0003d	85 c0		 test	 eax, eax
  0003f	74 15		 je	 SHORT $LN9@stricmp
  00041	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  00046	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00049	8b c8		 mov	 ecx, eax
  0004b	e8 00 00 00 00	 call	 toupper
  00050	89 44 24 20	 mov	 DWORD PTR tv76[rsp], eax
  00054	eb 0c		 jmp	 SHORT $LN10@stricmp
$LN9@stricmp:
  00056	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  0005b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0005e	89 44 24 20	 mov	 DWORD PTR tv76[rsp], eax
$LN10@stricmp:
  00062	8b 44 24 20	 mov	 eax, DWORD PTR tv76[rsp]
  00066	89 44 24 2c	 mov	 DWORD PTR ca$2[rsp], eax

; 481  : 		int cb = islower(*b) ? toupper(*b) : *b;

  0006a	48 8b 44 24 48	 mov	 rax, QWORD PTR b$[rsp]
  0006f	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00072	8b c8		 mov	 ecx, eax
  00074	e8 00 00 00 00	 call	 islower
  00079	85 c0		 test	 eax, eax
  0007b	74 15		 je	 SHORT $LN11@stricmp
  0007d	48 8b 44 24 48	 mov	 rax, QWORD PTR b$[rsp]
  00082	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00085	8b c8		 mov	 ecx, eax
  00087	e8 00 00 00 00	 call	 toupper
  0008c	89 44 24 24	 mov	 DWORD PTR tv85[rsp], eax
  00090	eb 0c		 jmp	 SHORT $LN12@stricmp
$LN11@stricmp:
  00092	48 8b 44 24 48	 mov	 rax, QWORD PTR b$[rsp]
  00097	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0009a	89 44 24 24	 mov	 DWORD PTR tv85[rsp], eax
$LN12@stricmp:
  0009e	8b 44 24 24	 mov	 eax, DWORD PTR tv85[rsp]
  000a2	89 44 24 28	 mov	 DWORD PTR cb$1[rsp], eax

; 482  : 
; 483  : 		if(ca < cb)

  000a6	8b 44 24 28	 mov	 eax, DWORD PTR cb$1[rsp]
  000aa	39 44 24 2c	 cmp	 DWORD PTR ca$2[rsp], eax
  000ae	7d 07		 jge	 SHORT $LN4@stricmp

; 484  : 			return -1;

  000b0	b8 ff ff ff ff	 mov	 eax, -1
  000b5	eb 64		 jmp	 SHORT $LN1@stricmp
$LN4@stricmp:

; 485  : 		if(ca > cb)

  000b7	8b 44 24 28	 mov	 eax, DWORD PTR cb$1[rsp]
  000bb	39 44 24 2c	 cmp	 DWORD PTR ca$2[rsp], eax
  000bf	7e 07		 jle	 SHORT $LN5@stricmp

; 486  : 			return 1;

  000c1	b8 01 00 00 00	 mov	 eax, 1
  000c6	eb 53		 jmp	 SHORT $LN1@stricmp
$LN5@stricmp:

; 487  : 
; 488  : 		a++;

  000c8	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  000cd	48 ff c0	 inc	 rax
  000d0	48 89 44 24 40	 mov	 QWORD PTR a$[rsp], rax

; 489  : 		b++;

  000d5	48 8b 44 24 48	 mov	 rax, QWORD PTR b$[rsp]
  000da	48 ff c0	 inc	 rax
  000dd	48 89 44 24 48	 mov	 QWORD PTR b$[rsp], rax

; 490  : 	}

  000e2	e9 27 ff ff ff	 jmp	 $LN2@stricmp
$LN3@stricmp:

; 491  : 	if(*a == '\0' && *b == '\0')

  000e7	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  000ec	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ef	85 c0		 test	 eax, eax
  000f1	75 10		 jne	 SHORT $LN6@stricmp
  000f3	48 8b 44 24 48	 mov	 rax, QWORD PTR b$[rsp]
  000f8	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000fb	85 c0		 test	 eax, eax
  000fd	75 04		 jne	 SHORT $LN6@stricmp

; 492  : 		return 0;

  000ff	33 c0		 xor	 eax, eax
  00101	eb 18		 jmp	 SHORT $LN1@stricmp
$LN6@stricmp:

; 493  : 	if(*a != '\0')

  00103	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  00108	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0010b	85 c0		 test	 eax, eax
  0010d	74 07		 je	 SHORT $LN7@stricmp

; 494  : 		return 1;

  0010f	b8 01 00 00 00	 mov	 eax, 1
  00114	eb 05		 jmp	 SHORT $LN1@stricmp
$LN7@stricmp:

; 495  : 	return -1;

  00116	b8 ff ff ff ff	 mov	 eax, -1
$LN1@stricmp:

; 496  : }

  0011b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0011f	c3		 ret	 0
stricmp	ENDP
_TEXT	ENDS
END
