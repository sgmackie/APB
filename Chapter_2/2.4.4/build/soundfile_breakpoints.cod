; Listing generated by Microsoft (R) Optimizing Compiler Version 19.11.25547.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG6095	DB	'%lf%lf', 00H
	ORG $+1
$SG6098	DB	'Error: Line &d has non-nummeric value', 0aH, 00H
	ORG $+1
$SG6100	DB	'Error: Incomplete breakpoint found at point %d', 0aH, 00H
$SG6102	DB	'Error: Time not increasing at point %d', 0aH, 00H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vfprintf_l
PUBLIC	fprintf
PUBLIC	??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	?breakpoint_max_point_value@@YA?AUBreakpointFormat@@PEBU1@J@Z ; breakpoint_max_point_value
PUBLIC	?breakpoint_get_breakpoints@@YAPEAUBreakpointFormat@@PEAU_iobuf@@PEAK@Z ; breakpoint_get_breakpoints
PUBLIC	?breakpoint_inputfile_range_check@@YAHPEBUBreakpointFormat@@NNK@Z ; breakpoint_inputfile_range_check
PUBLIC	?breakpoint_value_at_breakpoint_time@@YANPEBUBreakpointFormat@@KN@Z ; breakpoint_value_at_breakpoint_time
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
PUBLIC	__real@0000000000000000
EXTRN	__acrt_iob_func:PROC
EXTRN	fgets:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	__stdio_common_vsscanf:PROC
EXTRN	free:PROC
EXTRN	malloc:PROC
EXTRN	realloc:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$fprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$?breakpoint_max_point_value@@YA?AUBreakpointFormat@@PEBU1@J@Z DD imagerel $LN7
	DD	imagerel $LN7+236
	DD	imagerel $unwind$?breakpoint_max_point_value@@YA?AUBreakpointFormat@@PEBU1@J@Z
$pdata$?breakpoint_get_breakpoints@@YAPEAUBreakpointFormat@@PEAU_iobuf@@PEAK@Z DD imagerel $LN15
	DD	imagerel $LN15+598
	DD	imagerel $unwind$?breakpoint_get_breakpoints@@YAPEAUBreakpointFormat@@PEAU_iobuf@@PEAK@Z
$pdata$?breakpoint_inputfile_range_check@@YAHPEBUBreakpointFormat@@NNK@Z DD imagerel $LN8
	DD	imagerel $LN8+133
	DD	imagerel $unwind$?breakpoint_inputfile_range_check@@YAHPEBUBreakpointFormat@@NNK@Z
$pdata$?breakpoint_value_at_breakpoint_time@@YANPEBUBreakpointFormat@@KN@Z DD imagerel $LN9
	DD	imagerel $LN9+330
	DD	imagerel $unwind$?breakpoint_value_at_breakpoint_time@@YANPEBUBreakpointFormat@@KN@Z
pdata	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
xdata	SEGMENT
$unwind$?breakpoint_max_point_value@@YA?AUBreakpointFormat@@PEBU1@J@Z DD 032419H
	DD	070114215H
	DD	06010H
	DD	imagerel __GSHandlerCheck
	DD	018H
$unwind$?breakpoint_get_breakpoints@@YAPEAUBreakpointFormat@@PEAU_iobuf@@PEAK@Z DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$?breakpoint_inputfile_range_check@@YAHPEBUBreakpointFormat@@NNK@Z DD 011a01H
	DD	0221aH
$unwind$?breakpoint_value_at_breakpoint_time@@YANPEBUBreakpointFormat@@KN@Z DD 032419H
	DD	07011a215H
	DD	06010H
	DD	imagerel __GSHandlerCheck
	DD	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\chapter_2\2.4.4\code\soundfile_breakpoints.cpp
_TEXT	SEGMENT
i$ = 0
Width$ = 8
Fraction$ = 16
Value$ = 24
TimeLeft$ = 32
TimeRight$ = 48
__$ArrayPad$ = 64
ReadPoints$ = 112
BreakpointFile_Size$ = 120
TimeSpan$ = 128
?breakpoint_value_at_breakpoint_time@@YANPEBUBreakpointFormat@@KN@Z PROC ; breakpoint_value_at_breakpoint_time

; 128  : {

$LN9:
  00000	f2 0f 11 54 24
	18		 movsd	 QWORD PTR [rsp+24], xmm2
  00006	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 129  :     unsigned long i;
; 130  :     BREAKPOINT_FORMAT TimeLeft, TimeRight;
; 131  :     double Fraction, Value, Width;
; 132  : 
; 133  :     //Scan until span of specified time is found
; 134  :     for(i = 1; i < BreakpointFile_Size; i++)

  00024	c7 04 24 01 00
	00 00		 mov	 DWORD PTR i$[rsp], 1
  0002b	eb 08		 jmp	 SHORT $LN4@breakpoint
$LN2@breakpoint:
  0002d	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00030	ff c0		 inc	 eax
  00032	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@breakpoint:
  00035	8b 44 24 78	 mov	 eax, DWORD PTR BreakpointFile_Size$[rsp]
  00039	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  0003c	73 20		 jae	 SHORT $LN3@breakpoint

; 135  :     {
; 136  :         if(TimeSpan <= ReadPoints[i].BreakpointTime)

  0003e	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00041	48 6b c0 10	 imul	 rax, rax, 16
  00045	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ReadPoints$[rsp]
  0004a	f2 0f 10 04 01	 movsd	 xmm0, QWORD PTR [rcx+rax]
  0004f	66 0f 2f 84 24
	80 00 00 00	 comisd	 xmm0, QWORD PTR TimeSpan$[rsp]
  00058	72 02		 jb	 SHORT $LN5@breakpoint

; 137  :         break;

  0005a	eb 02		 jmp	 SHORT $LN3@breakpoint
$LN5@breakpoint:

; 138  :     }

  0005c	eb cf		 jmp	 SHORT $LN2@breakpoint
$LN3@breakpoint:

; 139  : 
; 140  :     if(i == BreakpointFile_Size)

  0005e	8b 44 24 78	 mov	 eax, DWORD PTR BreakpointFile_Size$[rsp]
  00062	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  00065	75 1b		 jne	 SHORT $LN6@breakpoint

; 141  :     {
; 142  :         return ReadPoints[i-1].BreakpointValue;

  00067	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0006a	ff c8		 dec	 eax
  0006c	8b c0		 mov	 eax, eax
  0006e	48 6b c0 10	 imul	 rax, rax, 16
  00072	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ReadPoints$[rsp]
  00077	f2 0f 10 44 01
	08		 movsd	 xmm0, QWORD PTR [rcx+rax+8]
  0007d	e9 b4 00 00 00	 jmp	 $LN1@breakpoint
$LN6@breakpoint:

; 143  :     }
; 144  : 
; 145  :     TimeLeft = ReadPoints[i-1];

  00082	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00085	ff c8		 dec	 eax
  00087	8b c0		 mov	 eax, eax
  00089	48 6b c0 10	 imul	 rax, rax, 16
  0008d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR TimeLeft$[rsp]
  00092	48 8b 54 24 70	 mov	 rdx, QWORD PTR ReadPoints$[rsp]
  00097	48 8b f9	 mov	 rdi, rcx
  0009a	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  0009e	b9 10 00 00 00	 mov	 ecx, 16
  000a3	f3 a4		 rep movsb

; 146  :     TimeRight = ReadPoints[i];

  000a5	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  000a8	48 6b c0 10	 imul	 rax, rax, 16
  000ac	48 8d 4c 24 30	 lea	 rcx, QWORD PTR TimeRight$[rsp]
  000b1	48 8b 54 24 70	 mov	 rdx, QWORD PTR ReadPoints$[rsp]
  000b6	48 8b f9	 mov	 rdi, rcx
  000b9	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  000bd	b9 10 00 00 00	 mov	 ecx, 16
  000c2	f3 a4		 rep movsb

; 147  : 
; 148  :     //Check for instant jump, where two points have the same time
; 149  :     Width = TimeRight.BreakpointTime - TimeLeft.BreakpointTime;

  000c4	f2 0f 10 44 24
	30		 movsd	 xmm0, QWORD PTR TimeRight$[rsp]
  000ca	f2 0f 5c 44 24
	20		 subsd	 xmm0, QWORD PTR TimeLeft$[rsp]
  000d0	f2 0f 11 44 24
	08		 movsd	 QWORD PTR Width$[rsp], xmm0

; 150  : 
; 151  :     if(Width == 0.0)

  000d6	f2 0f 10 44 24
	08		 movsd	 xmm0, QWORD PTR Width$[rsp]
  000dc	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  000e4	7a 0a		 jp	 SHORT $LN7@breakpoint
  000e6	75 08		 jne	 SHORT $LN7@breakpoint

; 152  :     {
; 153  :         return TimeRight.BreakpointValue;

  000e8	f2 0f 10 44 24
	38		 movsd	 xmm0, QWORD PTR TimeRight$[rsp+8]
  000ee	eb 46		 jmp	 SHORT $LN1@breakpoint
$LN7@breakpoint:

; 154  :     }
; 155  : 
; 156  :     //Get value from this span of times using linear interpolation
; 157  :     Fraction = (TimeSpan - TimeLeft.BreakpointTime) / Width;

  000f0	f2 0f 10 84 24
	80 00 00 00	 movsd	 xmm0, QWORD PTR TimeSpan$[rsp]
  000f9	f2 0f 5c 44 24
	20		 subsd	 xmm0, QWORD PTR TimeLeft$[rsp]
  000ff	f2 0f 5e 44 24
	08		 divsd	 xmm0, QWORD PTR Width$[rsp]
  00105	f2 0f 11 44 24
	10		 movsd	 QWORD PTR Fraction$[rsp], xmm0

; 158  :     Value = TimeLeft.BreakpointValue + ((TimeRight.BreakpointValue - TimeLeft.BreakpointValue) * Fraction);

  0010b	f2 0f 10 44 24
	38		 movsd	 xmm0, QWORD PTR TimeRight$[rsp+8]
  00111	f2 0f 5c 44 24
	28		 subsd	 xmm0, QWORD PTR TimeLeft$[rsp+8]
  00117	f2 0f 59 44 24
	10		 mulsd	 xmm0, QWORD PTR Fraction$[rsp]
  0011d	f2 0f 10 4c 24
	28		 movsd	 xmm1, QWORD PTR TimeLeft$[rsp+8]
  00123	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00127	0f 28 c1	 movaps	 xmm0, xmm1
  0012a	f2 0f 11 44 24
	18		 movsd	 QWORD PTR Value$[rsp], xmm0

; 159  : 
; 160  :     return Value;

  00130	f2 0f 10 44 24
	18		 movsd	 xmm0, QWORD PTR Value$[rsp]
$LN1@breakpoint:

; 161  : }

  00136	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0013b	48 33 cc	 xor	 rcx, rsp
  0013e	e8 00 00 00 00	 call	 __security_check_cookie
  00143	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00147	5f		 pop	 rdi
  00148	5e		 pop	 rsi
  00149	c3		 ret	 0
?breakpoint_value_at_breakpoint_time@@YANPEBUBreakpointFormat@@KN@Z ENDP ; breakpoint_value_at_breakpoint_time
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\chapter_2\2.4.4\code\soundfile_breakpoints.cpp
_TEXT	SEGMENT
i$1 = 0
RangeCheck$ = 4
ReadPoints$ = 32
ValueMin$ = 40
ValueMax$ = 48
BreakpointFile_Size$ = 56
?breakpoint_inputfile_range_check@@YAHPEBUBreakpointFormat@@NNK@Z PROC ; breakpoint_inputfile_range_check

; 111  : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	f2 0f 11 54 24
	18		 movsd	 QWORD PTR [rsp+24], xmm2
  0000b	f2 0f 11 4c 24
	10		 movsd	 QWORD PTR [rsp+16], xmm1
  00011	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00016	48 83 ec 18	 sub	 rsp, 24

; 112  :     int RangeCheck = 1;

  0001a	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR RangeCheck$[rsp], 1

; 113  : 
; 114  :     for(unsigned long i = 0; i < BreakpointFile_Size; i++)

  00022	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$1[rsp], 0
  00029	eb 08		 jmp	 SHORT $LN4@breakpoint
$LN2@breakpoint:
  0002b	8b 04 24	 mov	 eax, DWORD PTR i$1[rsp]
  0002e	ff c0		 inc	 eax
  00030	89 04 24	 mov	 DWORD PTR i$1[rsp], eax
$LN4@breakpoint:
  00033	8b 44 24 38	 mov	 eax, DWORD PTR BreakpointFile_Size$[rsp]
  00037	39 04 24	 cmp	 DWORD PTR i$1[rsp], eax
  0003a	73 40		 jae	 SHORT $LN3@breakpoint

; 115  :     {
; 116  :         if(ReadPoints[i].BreakpointValue < ValueMin || ReadPoints[i].BreakpointValue > ValueMax)

  0003c	8b 04 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003f	48 6b c0 10	 imul	 rax, rax, 16
  00043	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ReadPoints$[rsp]
  00048	f2 0f 10 44 24
	28		 movsd	 xmm0, QWORD PTR ValueMin$[rsp]
  0004e	66 0f 2f 44 01
	08		 comisd	 xmm0, QWORD PTR [rcx+rax+8]
  00054	77 1a		 ja	 SHORT $LN6@breakpoint
  00056	8b 04 24	 mov	 eax, DWORD PTR i$1[rsp]
  00059	48 6b c0 10	 imul	 rax, rax, 16
  0005d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ReadPoints$[rsp]
  00062	f2 0f 10 44 01
	08		 movsd	 xmm0, QWORD PTR [rcx+rax+8]
  00068	66 0f 2f 44 24
	30		 comisd	 xmm0, QWORD PTR ValueMax$[rsp]
  0006e	76 0a		 jbe	 SHORT $LN5@breakpoint
$LN6@breakpoint:

; 117  :         {
; 118  :             RangeCheck = 0;

  00070	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR RangeCheck$[rsp], 0

; 119  :             break;

  00078	eb 02		 jmp	 SHORT $LN3@breakpoint
$LN5@breakpoint:

; 120  :         }
; 121  :     }

  0007a	eb af		 jmp	 SHORT $LN2@breakpoint
$LN3@breakpoint:

; 122  :     
; 123  :     return RangeCheck;

  0007c	8b 44 24 04	 mov	 eax, DWORD PTR RangeCheck$[rsp]

; 124  : }

  00080	48 83 c4 18	 add	 rsp, 24
  00084	c3		 ret	 0
?breakpoint_inputfile_range_check@@YAHPEBUBreakpointFormat@@NNK@Z ENDP ; breakpoint_inputfile_range_check
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\chapter_2\2.4.4\code\soundfile_breakpoints.cpp
_TEXT	SEGMENT
ReadPoints_Total$ = 32
ArraySize$ = 36
ReadPoints$ = 40
TextFile_Output$ = 48
tv94 = 52
tv133 = 56
tv144 = 60
ReadPoints_LastTime$ = 64
tmp$1 = 72
Breakpoint_LineLength$ = 80
__$ArrayPad$ = 160
FilePointer$ = 192
PointerSize$ = 200
?breakpoint_get_breakpoints@@YAPEAUBreakpointFormat@@PEAU_iobuf@@PEAK@Z PROC ; breakpoint_get_breakpoints

; 31   : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 32   :     int TextFile_Output;
; 33   :     long ReadPoints_Total = 0, ArraySize = 64;

  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ReadPoints_Total$[rsp], 0
  0002b	c7 44 24 24 40
	00 00 00	 mov	 DWORD PTR ArraySize$[rsp], 64 ; 00000040H

; 34   :     double ReadPoints_LastTime = 0.0;

  00033	0f 57 c0	 xorps	 xmm0, xmm0
  00036	f2 0f 11 44 24
	40		 movsd	 QWORD PTR ReadPoints_LastTime$[rsp], xmm0

; 35   :     BREAKPOINT_FORMAT* ReadPoints = NULL;

  0003c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR ReadPoints$[rsp], 0

; 36   :     char Breakpoint_LineLength[80];
; 37   : 
; 38   :     //If file fails to open
; 39   :     if(FilePointer == NULL)

  00045	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR FilePointer$[rsp], 0
  0004e	75 07		 jne	 SHORT $LN4@breakpoint

; 40   :     {
; 41   :         return NULL;

  00050	33 c0		 xor	 eax, eax
  00052	e9 e7 01 00 00	 jmp	 $LN1@breakpoint
$LN4@breakpoint:

; 42   :     }
; 43   : 
; 44   :     ReadPoints = (BREAKPOINT_FORMAT*) malloc(sizeof(BREAKPOINT_FORMAT) * ArraySize);

  00057	48 63 44 24 24	 movsxd	 rax, DWORD PTR ArraySize$[rsp]
  0005c	48 6b c0 10	 imul	 rax, rax, 16
  00060	48 8b c8	 mov	 rcx, rax
  00063	e8 00 00 00 00	 call	 malloc
  00068	48 89 44 24 28	 mov	 QWORD PTR ReadPoints$[rsp], rax

; 45   : 
; 46   :     if(ReadPoints == NULL)

  0006d	48 83 7c 24 28
	00		 cmp	 QWORD PTR ReadPoints$[rsp], 0
  00073	75 07		 jne	 SHORT $LN5@breakpoint

; 47   :     {
; 48   :         return NULL;

  00075	33 c0		 xor	 eax, eax
  00077	e9 c2 01 00 00	 jmp	 $LN1@breakpoint
$LN5@breakpoint:
$LN14@breakpoint:
$LN2@breakpoint:

; 49   :     }
; 50   : 
; 51   :     while(fgets(Breakpoint_LineLength, 80, FilePointer))

  0007c	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR FilePointer$[rsp]
  00084	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  00089	48 8d 4c 24 50	 lea	 rcx, QWORD PTR Breakpoint_LineLength$[rsp]
  0008e	e8 00 00 00 00	 call	 fgets
  00093	48 85 c0	 test	 rax, rax
  00096	0f 84 88 01 00
	00		 je	 $LN3@breakpoint

; 52   :     {
; 53   :         TextFile_Output = sscanf(Breakpoint_LineLength, "%lf%lf", &ReadPoints[ReadPoints_Total].BreakpointTime, &ReadPoints[ReadPoints_Total].BreakpointValue);

  0009c	48 63 44 24 20	 movsxd	 rax, DWORD PTR ReadPoints_Total$[rsp]
  000a1	48 6b c0 10	 imul	 rax, rax, 16
  000a5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ReadPoints$[rsp]
  000aa	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  000af	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR ReadPoints_Total$[rsp]
  000b4	48 6b c9 10	 imul	 rcx, rcx, 16
  000b8	48 8b 54 24 28	 mov	 rdx, QWORD PTR ReadPoints$[rsp]
  000bd	48 03 d1	 add	 rdx, rcx
  000c0	48 8b ca	 mov	 rcx, rdx
  000c3	4c 8b c8	 mov	 r9, rax
  000c6	4c 8b c1	 mov	 r8, rcx
  000c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG6095
  000d0	48 8d 4c 24 50	 lea	 rcx, QWORD PTR Breakpoint_LineLength$[rsp]
  000d5	e8 00 00 00 00	 call	 sscanf
  000da	89 44 24 30	 mov	 DWORD PTR TextFile_Output$[rsp], eax

; 54   : 
; 55   :         //Check if empty Breakpoint_LineLength in text file, contine loop if there is
; 56   :         if(TextFile_Output < 0)

  000de	83 7c 24 30 00	 cmp	 DWORD PTR TextFile_Output$[rsp], 0
  000e3	7d 02		 jge	 SHORT $LN6@breakpoint

; 57   :         {
; 58   :             continue;

  000e5	eb 95		 jmp	 SHORT $LN2@breakpoint
$LN6@breakpoint:

; 59   :         }
; 60   :         
; 61   :         if(TextFile_Output == 0)

  000e7	83 7c 24 30 00	 cmp	 DWORD PTR TextFile_Output$[rsp], 0
  000ec	75 2f		 jne	 SHORT $LN7@breakpoint

; 62   :         {
; 63   :             fprintf(stderr, "Error: Line &d has non-nummeric value\n", ReadPoints_Total+1);

  000ee	8b 44 24 20	 mov	 eax, DWORD PTR ReadPoints_Total$[rsp]
  000f2	ff c0		 inc	 eax
  000f4	89 44 24 34	 mov	 DWORD PTR tv94[rsp], eax
  000f8	b9 02 00 00 00	 mov	 ecx, 2
  000fd	e8 00 00 00 00	 call	 __acrt_iob_func
  00102	8b 4c 24 34	 mov	 ecx, DWORD PTR tv94[rsp]
  00106	44 8b c1	 mov	 r8d, ecx
  00109	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG6098
  00110	48 8b c8	 mov	 rcx, rax
  00113	e8 00 00 00 00	 call	 fprintf

; 64   :             break;

  00118	e9 07 01 00 00	 jmp	 $LN3@breakpoint
$LN7@breakpoint:

; 65   :         }
; 66   :    
; 67   :         if(TextFile_Output == 1)

  0011d	83 7c 24 30 01	 cmp	 DWORD PTR TextFile_Output$[rsp], 1
  00122	75 2f		 jne	 SHORT $LN8@breakpoint

; 68   :         {
; 69   :             fprintf(stderr, "Error: Incomplete breakpoint found at point %d\n", ReadPoints_Total+1);

  00124	8b 44 24 20	 mov	 eax, DWORD PTR ReadPoints_Total$[rsp]
  00128	ff c0		 inc	 eax
  0012a	89 44 24 38	 mov	 DWORD PTR tv133[rsp], eax
  0012e	b9 02 00 00 00	 mov	 ecx, 2
  00133	e8 00 00 00 00	 call	 __acrt_iob_func
  00138	8b 4c 24 38	 mov	 ecx, DWORD PTR tv133[rsp]
  0013c	44 8b c1	 mov	 r8d, ecx
  0013f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG6100
  00146	48 8b c8	 mov	 rcx, rax
  00149	e8 00 00 00 00	 call	 fprintf

; 70   :             break;

  0014e	e9 d1 00 00 00	 jmp	 $LN3@breakpoint
$LN8@breakpoint:

; 71   :         }
; 72   : 
; 73   :         if(ReadPoints[ReadPoints_Total].BreakpointTime < ReadPoints_LastTime)

  00153	48 63 44 24 20	 movsxd	 rax, DWORD PTR ReadPoints_Total$[rsp]
  00158	48 6b c0 10	 imul	 rax, rax, 16
  0015c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ReadPoints$[rsp]
  00161	f2 0f 10 44 24
	40		 movsd	 xmm0, QWORD PTR ReadPoints_LastTime$[rsp]
  00167	66 0f 2f 04 01	 comisd	 xmm0, QWORD PTR [rcx+rax]
  0016c	76 2f		 jbe	 SHORT $LN9@breakpoint

; 74   :         {
; 75   :             fprintf(stderr, "Error: Time not increasing at point %d\n", ReadPoints_Total+1);

  0016e	8b 44 24 20	 mov	 eax, DWORD PTR ReadPoints_Total$[rsp]
  00172	ff c0		 inc	 eax
  00174	89 44 24 3c	 mov	 DWORD PTR tv144[rsp], eax
  00178	b9 02 00 00 00	 mov	 ecx, 2
  0017d	e8 00 00 00 00	 call	 __acrt_iob_func
  00182	8b 4c 24 3c	 mov	 ecx, DWORD PTR tv144[rsp]
  00186	44 8b c1	 mov	 r8d, ecx
  00189	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG6102
  00190	48 8b c8	 mov	 rcx, rax
  00193	e8 00 00 00 00	 call	 fprintf

; 76   :             break;

  00198	e9 87 00 00 00	 jmp	 $LN3@breakpoint
$LN9@breakpoint:

; 77   :         }
; 78   : 
; 79   :         ReadPoints_LastTime = ReadPoints[ReadPoints_Total].BreakpointTime;

  0019d	48 63 44 24 20	 movsxd	 rax, DWORD PTR ReadPoints_Total$[rsp]
  001a2	48 6b c0 10	 imul	 rax, rax, 16
  001a6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ReadPoints$[rsp]
  001ab	f2 0f 10 04 01	 movsd	 xmm0, QWORD PTR [rcx+rax]
  001b0	f2 0f 11 44 24
	40		 movsd	 QWORD PTR ReadPoints_LastTime$[rsp], xmm0

; 80   : 
; 81   :         if(++ReadPoints_Total == ArraySize)

  001b6	8b 44 24 20	 mov	 eax, DWORD PTR ReadPoints_Total$[rsp]
  001ba	ff c0		 inc	 eax
  001bc	89 44 24 20	 mov	 DWORD PTR ReadPoints_Total$[rsp], eax
  001c0	8b 44 24 24	 mov	 eax, DWORD PTR ArraySize$[rsp]
  001c4	39 44 24 20	 cmp	 DWORD PTR ReadPoints_Total$[rsp], eax
  001c8	75 55		 jne	 SHORT $LN10@breakpoint

; 82   :         {
; 83   :             BREAKPOINT_FORMAT* tmp;
; 84   :             ArraySize += NPOINTS;

  001ca	8b 44 24 24	 mov	 eax, DWORD PTR ArraySize$[rsp]
  001ce	83 c0 40	 add	 eax, 64			; 00000040H
  001d1	89 44 24 24	 mov	 DWORD PTR ArraySize$[rsp], eax

; 85   :         
; 86   :             tmp = (BREAKPOINT_FORMAT*) realloc(ReadPoints, sizeof(BREAKPOINT_FORMAT) *ArraySize);

  001d5	48 63 44 24 24	 movsxd	 rax, DWORD PTR ArraySize$[rsp]
  001da	48 6b c0 10	 imul	 rax, rax, 16
  001de	48 8b d0	 mov	 rdx, rax
  001e1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ReadPoints$[rsp]
  001e6	e8 00 00 00 00	 call	 realloc
  001eb	48 89 44 24 48	 mov	 QWORD PTR tmp$1[rsp], rax

; 87   : 
; 88   :             //Release all memory
; 89   :             if(tmp == NULL)

  001f0	48 83 7c 24 48
	00		 cmp	 QWORD PTR tmp$1[rsp], 0
  001f6	75 1d		 jne	 SHORT $LN11@breakpoint

; 90   :             {
; 91   :                 ReadPoints_Total = 0;

  001f8	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ReadPoints_Total$[rsp], 0

; 92   :                 free(ReadPoints);

  00200	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ReadPoints$[rsp]
  00205	e8 00 00 00 00	 call	 free

; 93   :                 ReadPoints = NULL;

  0020a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR ReadPoints$[rsp], 0

; 94   :                 break;

  00213	eb 0f		 jmp	 SHORT $LN3@breakpoint
$LN11@breakpoint:

; 95   :             }
; 96   : 
; 97   :             ReadPoints = tmp;

  00215	48 8b 44 24 48	 mov	 rax, QWORD PTR tmp$1[rsp]
  0021a	48 89 44 24 28	 mov	 QWORD PTR ReadPoints$[rsp], rax
$LN10@breakpoint:

; 98   :         }
; 99   :     }

  0021f	e9 58 fe ff ff	 jmp	 $LN14@breakpoint
$LN3@breakpoint:

; 100  : 
; 101  :     if(ReadPoints_Total)

  00224	83 7c 24 20 00	 cmp	 DWORD PTR ReadPoints_Total$[rsp], 0
  00229	74 0e		 je	 SHORT $LN12@breakpoint

; 102  :     {
; 103  :         *PointerSize = ReadPoints_Total;

  0022b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR PointerSize$[rsp]
  00233	8b 4c 24 20	 mov	 ecx, DWORD PTR ReadPoints_Total$[rsp]
  00237	89 08		 mov	 DWORD PTR [rax], ecx
$LN12@breakpoint:

; 104  :     }    
; 105  : 
; 106  :     return ReadPoints;

  00239	48 8b 44 24 28	 mov	 rax, QWORD PTR ReadPoints$[rsp]
$LN1@breakpoint:

; 107  : }

  0023e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00246	48 33 cc	 xor	 rcx, rsp
  00249	e8 00 00 00 00	 call	 __security_check_cookie
  0024e	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00255	c3		 ret	 0
?breakpoint_get_breakpoints@@YAPEAUBreakpointFormat@@PEAU_iobuf@@PEAK@Z ENDP ; breakpoint_get_breakpoints
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\chapter_2\2.4.4\code\soundfile_breakpoints.cpp
_TEXT	SEGMENT
i$ = 0
MaxPoint$ = 8
__$ArrayPad$ = 24
$T1 = 64
ReadPoints$ = 72
ReadPoints_Total$ = 80
?breakpoint_max_point_value@@YA?AUBreakpointFormat@@PEBU1@J@Z PROC ; breakpoint_max_point_value

; 9    : {

$LN7:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 44 24 18	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 10   :     int i;
; 11   :     BREAKPOINT_FORMAT MaxPoint;
; 12   : 
; 13   :     //Start from first point
; 14   :     MaxPoint.BreakpointTime = ReadPoints[0].BreakpointTime;

  00024	b8 10 00 00 00	 mov	 eax, 16
  00029	48 6b c0 00	 imul	 rax, rax, 0
  0002d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ReadPoints$[rsp]
  00032	f2 0f 10 04 01	 movsd	 xmm0, QWORD PTR [rcx+rax]
  00037	f2 0f 11 44 24
	08		 movsd	 QWORD PTR MaxPoint$[rsp], xmm0

; 15   :     MaxPoint.BreakpointValue = ReadPoints[0].BreakpointValue;

  0003d	b8 10 00 00 00	 mov	 eax, 16
  00042	48 6b c0 00	 imul	 rax, rax, 0
  00046	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ReadPoints$[rsp]
  0004b	f2 0f 10 44 01
	08		 movsd	 xmm0, QWORD PTR [rcx+rax+8]
  00051	f2 0f 11 44 24
	10		 movsd	 QWORD PTR MaxPoint$[rsp+8], xmm0

; 16   : 
; 17   :     for(i = 0; i < ReadPoints_Total; i++)

  00057	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  0005e	eb 08		 jmp	 SHORT $LN4@breakpoint
$LN2@breakpoint:
  00060	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00063	ff c0		 inc	 eax
  00065	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@breakpoint:
  00068	8b 44 24 50	 mov	 eax, DWORD PTR ReadPoints_Total$[rsp]
  0006c	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  0006f	7d 4e		 jge	 SHORT $LN3@breakpoint

; 18   :     {
; 19   :         if(MaxPoint.BreakpointValue < ReadPoints[i].BreakpointValue)

  00071	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00075	48 6b c0 10	 imul	 rax, rax, 16
  00079	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ReadPoints$[rsp]
  0007e	f2 0f 10 44 01
	08		 movsd	 xmm0, QWORD PTR [rcx+rax+8]
  00084	66 0f 2f 44 24
	10		 comisd	 xmm0, QWORD PTR MaxPoint$[rsp+8]
  0008a	76 31		 jbe	 SHORT $LN5@breakpoint

; 20   :         {
; 21   :             MaxPoint.BreakpointValue = ReadPoints[i].BreakpointValue;

  0008c	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00090	48 6b c0 10	 imul	 rax, rax, 16
  00094	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ReadPoints$[rsp]
  00099	f2 0f 10 44 01
	08		 movsd	 xmm0, QWORD PTR [rcx+rax+8]
  0009f	f2 0f 11 44 24
	10		 movsd	 QWORD PTR MaxPoint$[rsp+8], xmm0

; 22   :             MaxPoint.BreakpointTime = ReadPoints[i].BreakpointTime; 

  000a5	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000a9	48 6b c0 10	 imul	 rax, rax, 16
  000ad	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ReadPoints$[rsp]
  000b2	f2 0f 10 04 01	 movsd	 xmm0, QWORD PTR [rcx+rax]
  000b7	f2 0f 11 44 24
	08		 movsd	 QWORD PTR MaxPoint$[rsp], xmm0
$LN5@breakpoint:

; 23   :         }
; 24   :     }

  000bd	eb a1		 jmp	 SHORT $LN2@breakpoint
$LN3@breakpoint:

; 25   : 
; 26   :     return MaxPoint;

  000bf	48 8d 44 24 08	 lea	 rax, QWORD PTR MaxPoint$[rsp]
  000c4	48 8b 7c 24 40	 mov	 rdi, QWORD PTR $T1[rsp]
  000c9	48 8b f0	 mov	 rsi, rax
  000cc	b9 10 00 00 00	 mov	 ecx, 16
  000d1	f3 a4		 rep movsb
  000d3	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]

; 27   : }

  000d8	48 8b 4c 24 18	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000dd	48 33 cc	 xor	 rcx, rsp
  000e0	e8 00 00 00 00	 call	 __security_check_cookie
  000e5	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000e9	5f		 pop	 rdi
  000ea	5e		 pop	 rsi
  000eb	c3		 ret	 0
?breakpoint_max_point_value@@YA?AUBreakpointFormat@@PEBU1@J@Z ENDP ; breakpoint_max_point_value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2268 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2269 :         int _Result;
; 2270 :         va_list _ArgList;
; 2271 :         __crt_va_start(_ArgList, _Format);

  00018	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
  0001d	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00022	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2272 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00027	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0002c	45 33 c0	 xor	 r8d, r8d
  0002f	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00039	e8 00 00 00 00	 call	 _vsscanf_l
  0003e	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2273 :         __crt_va_end(_ArgList);

  00042	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2274 :         return _Result;

  0004b	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2275 :     }

  0004f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00053	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2173 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2174 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	e8 00 00 00 00	 call	 __stdio_common_vsscanf

; 2175 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2176 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2177 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.11.25503\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>, COMDAT

; 151  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 152  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Stream$ = 64
_Format$ = 72
fprintf	PROC						; COMDAT

; 833  :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 834  :         int _Result;
; 835  :         va_list _ArgList;
; 836  :         __crt_va_start(_ArgList, _Format);

  00018	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
  0001d	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00022	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 837  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00027	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0002c	45 33 c0	 xor	 r8d, r8d
  0002f	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Stream$[rsp]
  00039	e8 00 00 00 00	 call	 _vfprintf_l
  0003e	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 838  :         __crt_va_end(_ArgList);

  00042	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 839  :         return _Result;

  0004b	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 840  :     }

  0004f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00053	c3		 ret	 0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 640  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 641  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	e8 00 00 00 00	 call	 __stdio_common_vfprintf

; 642  :     }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 95   :         static unsigned __int64 _OptionsStorage;
; 96   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 97   :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 86   :         static unsigned __int64 _OptionsStorage;
; 87   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 88   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
