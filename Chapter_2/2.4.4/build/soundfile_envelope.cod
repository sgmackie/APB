; Listing generated by Microsoft (R) Optimizing Compiler Version 19.11.25547.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG7214	DB	'soundfile_pan.exe: Pan mono file in stereo from given po'
	DB	'sition values', 0aH, 00H
	ORG $+9
$SG7216	DB	'Error: Insufficient number of arguments', 0aH, 'Usage: s'
	DB	'oundfile_pan.exe, input file, output file, pan position', 0aH
	DB	00H
	ORG $+3
$SG7231	DB	'r', 00H
	ORG $+2
$SG7218	DB	'Error: Unable to start portsf', 0aH, 00H
	ORG $+1
$SG7220	DB	'Error: Unable to open input file %s', 0aH, 00H
	ORG $+3
$SG7223	DB	'Error: Input file must be mono', 0aH, 00H
$SG7226	DB	'Error: No memory', 0aH, 00H
	ORG $+6
$SG7229	DB	'Error: output file name %s has unknown format', 0aH, 00H
	ORG $+1
$SG7233	DB	'Error: Unable to open breakpoint file %s', 0aH, 00H
	ORG $+6
$SG7236	DB	'Error: No breakpoints read', 0aH, 00H
	ORG $+4
$SG7239	DB	'Error: At least two breakpoints required', 0aH, 00H
	ORG $+6
$SG7242	DB	'Error: First breakpoint time (%lf) must start from 0', 0aH
	DB	00H
	ORG $+2
$SG7245	DB	'Error: Breakpoint values out of range', 0aH, 00H
	ORG $+1
$SG7248	DB	'Error: No memory', 0aH, 00H
	ORG $+6
$SG7251	DB	'Error: Unable to create output file %s', 0aH, 00H
$SG7253	DB	'Info: Processing...', 0aH, 00H
	ORG $+3
$SG7261	DB	'Info: Copying %ld samples...', 0dH, 00H
	ORG $+2
$SG7263	DB	'Error: Cannot write to ouput file %s', 0aH, 00H
	ORG $+2
$SG7266	DB	'Error: Cannot read input file %s, output file %s is inco'
	DB	'mplete', 0aH, 00H
$SG7267	DB	0aH, 'Info: Done.', 0aH, 'Info: %d errors', 0aH, 00H
	ORG $+2
$SG7269	DB	'Info: Peaks:', 0aH, 00H
	ORG $+2
$SG7270	DB	'Channel %d:', 09H, '%.4f (%.4f dB) at %.4f seconds', 0aH
	DB	00H
	ORG $+4
$SG7273	DB	'Warning: Problem closing input file %s', 0aH, 00H
$SG7276	DB	'Warning: Problem closing output file %s', 0aH, 00H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	fprintf
PUBLIC	??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
PUBLIC	printf
PUBLIC	main
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	__real@0000000000000000
PUBLIC	__real@3ff0000000000000
EXTRN	__acrt_iob_func:PROC
EXTRN	fclose:PROC
EXTRN	fopen:PROC
EXTRN	puts:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	free:PROC
EXTRN	malloc:PROC
EXTRN	log10:PROC
EXTRN	psf_init:PROC
EXTRN	psf_finish:PROC
EXTRN	psf_sndCreate:PROC
EXTRN	psf_sndOpen:PROC
EXTRN	psf_sndClose:PROC
EXTRN	psf_sndWriteFloatFrames:PROC
EXTRN	psf_sndReadFloatFrames:PROC
EXTRN	psf_sndReadPeaks:PROC
EXTRN	psf_getFormatExt:PROC
EXTRN	?breakpoint_get_breakpoints@@YAPEAUBreakpointFormat@@PEAU_iobuf@@PEAK@Z:PROC ; breakpoint_get_breakpoints
EXTRN	?breakpoint_inputfile_range_check@@YAHPEBUBreakpointFormat@@NNK@Z:PROC ; breakpoint_inputfile_range_check
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$fprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+92
	DD	imagerel $unwind$printf
pdata	ENDS
pdata	SEGMENT
$pdata$main DD	imagerel $LN56
	DD	imagerel $LN56+2730
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
xdata	SEGMENT
$unwind$main DD	042419H
	DD	02f0112H
	DD	0600a700bH
	DD	imagerel __GSHandlerCheck
	DD	0168H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\chapter_2\2.4.4\code\soundfile_envelope.cpp
_TEXT	SEGMENT
ErrorCode$ = 48
i$1 = 52
OutputFile$ = 56
CounterRight$ = 60
Input_i$2 = 64
FramesRead$ = 68
InputFile$ = 72
ReadPoints$ = 80
BreakpointFile_Size$ = 88
CounterLeft$ = 92
FramesRead_Total$ = 96
FramesInput$ = 104
PeakData$ = 112
OutputFile_Format$ = 120
BufferSize$ = 124
MorePoints$ = 128
BreakpointFile$ = 136
CurrentPosition$ = 144
Width$ = 152
Height$ = 160
Amplitude$3 = 168
FramesOutput$ = 176
tv84 = 184
tv146 = 192
tv160 = 200
tv187 = 208
tv226 = 216
Fraction$4 = 224
TimeIncrement$ = 232
tv327 = 240
tv336 = 248
tv339 = 256
PeakTime$5 = 264
PeakDB$6 = 272
InputFile_Properties$ = 280
OutputFile_Properties$ = 304
RightPoint$ = 328
LeftPoint$ = 344
__$ArrayPad$ = 360
argc$ = 400
argv$ = 408
main	PROC

; 13   : {

$LN56:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 14   :     //Stage 1: Declare
; 15   :     PSF_PROPS InputFile_Properties, OutputFile_Properties; //File properties struct from portsf
; 16   :     long FramesRead, FramesRead_Total;
; 17   : 
; 18   :     //Breakpoint variables
; 19   :     unsigned long BreakpointFile_Size, CounterLeft, CounterRight;
; 20   :     BREAKPOINT_FORMAT LeftPoint, RightPoint;
; 21   :     double TimeIncrement, CurrentPosition, Width, Height;
; 22   :     int MorePoints;
; 23   : 
; 24   :     //Initialise dyanmic variables to defaults
; 25   :     int InputFile = -1;

  00024	c7 44 24 48 ff
	ff ff ff	 mov	 DWORD PTR InputFile$[rsp], -1

; 26   :     int OutputFile = -1;

  0002c	c7 44 24 38 ff
	ff ff ff	 mov	 DWORD PTR OutputFile$[rsp], -1

; 27   :     int ErrorCode = 0;

  00034	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR ErrorCode$[rsp], 0

; 28   :     float *FramesInput = NULL;

  0003c	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR FramesInput$[rsp], 0

; 29   :     float *FramesOutput = NULL;

  00045	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR FramesOutput$[rsp], 0

; 30   :     psf_format OutputFile_Format = PSF_FMT_UNKNOWN;

  00051	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR OutputFile_Format$[rsp], 0

; 31   :     PSF_CHPEAK *PeakData = NULL; //Peak data struct from portsf

  00059	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR PeakData$[rsp], 0

; 32   :     unsigned long BufferSize = BUFFER_SIZE; //Unsigned, buffer size cannot be a negative number

  00062	c7 44 24 7c 00
	04 00 00	 mov	 DWORD PTR BufferSize$[rsp], 1024 ; 00000400H

; 33   :     FILE *BreakpointFile = NULL;

  0006a	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR BreakpointFile$[rsp], 0

; 34   :     BREAKPOINT_FORMAT *ReadPoints = NULL;

  00076	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR ReadPoints$[rsp], 0

; 35   : 
; 36   :     printf("soundfile_pan.exe: Pan mono file in stereo from given position values\n");

  0007f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7214
  00086	e8 00 00 00 00	 call	 printf

; 37   : 
; 38   :     //Stage 2: Argument check
; 39   : 
; 40   :     //Check command line arguments
; 41   :     if(argc < ARG_NUM_ARGS)

  0008b	83 bc 24 90 01
	00 00 04	 cmp	 DWORD PTR argc$[rsp], 4
  00093	7d 23		 jge	 SHORT $LN10@main

; 42   :     {
; 43   :         fprintf(stderr, "Error: Insufficient number of arguments\n"

  00095	b9 02 00 00 00	 mov	 ecx, 2
  0009a	e8 00 00 00 00	 call	 __acrt_iob_func
  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7216
  000a6	48 8b c8	 mov	 rcx, rax
  000a9	e8 00 00 00 00	 call	 fprintf

; 44   :                         "Usage: soundfile_pan.exe, input file, output file, pan position\n");
; 45   :         return 1;

  000ae	b8 01 00 00 00	 mov	 eax, 1
  000b3	e9 d8 09 00 00	 jmp	 $LN1@main
$LN10@main:

; 46   :     }
; 47   :     
; 48   :     //Start portsf library
; 49   :     if(psf_init())

  000b8	e8 00 00 00 00	 call	 psf_init
  000bd	85 c0		 test	 eax, eax
  000bf	74 23		 je	 SHORT $LN11@main

; 50   :     {
; 51   :         fprintf(stderr, "Error: Unable to start portsf\n");

  000c1	b9 02 00 00 00	 mov	 ecx, 2
  000c6	e8 00 00 00 00	 call	 __acrt_iob_func
  000cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7218
  000d2	48 8b c8	 mov	 rcx, rax
  000d5	e8 00 00 00 00	 call	 fprintf

; 52   :         return 1;

  000da	b8 01 00 00 00	 mov	 eax, 1
  000df	e9 ac 09 00 00	 jmp	 $LN1@main
$LN11@main:

; 53   :     }
; 54   :     
; 55   :     //Stage 3: Process input file
; 56   :     //Open user input file
; 57   :     InputFile = psf_sndOpen(argv[ARG_INFILE], &InputFile_Properties, 0);

  000e4	b8 08 00 00 00	 mov	 eax, 8
  000e9	48 6b c0 01	 imul	 rax, rax, 1
  000ed	45 33 c0	 xor	 r8d, r8d
  000f0	48 8d 94 24 18
	01 00 00	 lea	 rdx, QWORD PTR InputFile_Properties$[rsp]
  000f8	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00100	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00104	e8 00 00 00 00	 call	 psf_sndOpen
  00109	89 44 24 48	 mov	 DWORD PTR InputFile$[rsp], eax

; 58   : 
; 59   :     if(InputFile < 0)

  0010d	83 7c 24 48 00	 cmp	 DWORD PTR InputFile$[rsp], 0
  00112	7d 52		 jge	 SHORT $LN12@main

; 60   :     {
; 61   :         fprintf(stderr, "Error: Unable to open input file %s\n", argv[ARG_INFILE]);

  00114	b8 08 00 00 00	 mov	 eax, 8
  00119	48 6b c0 01	 imul	 rax, rax, 1
  0011d	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv84[rsp], rax
  00125	b9 02 00 00 00	 mov	 ecx, 2
  0012a	e8 00 00 00 00	 call	 __acrt_iob_func
  0012f	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00137	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR tv84[rsp]
  0013f	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  00143	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7220
  0014a	48 8b c8	 mov	 rcx, rax
  0014d	e8 00 00 00 00	 call	 fprintf

; 62   :         ErrorCode++;

  00152	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  00156	ff c0		 inc	 eax
  00158	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 63   :         goto memory_cleanup;

  0015c	e9 5e 08 00 00	 jmp	 $LN13@main
  00161	e9 59 08 00 00	 jmp	 $memory_cleanup$57
$LN12@main:

; 64   :     }
; 65   : 
; 66   :     //Check if input file is mono
; 67   :     if(InputFile_Properties.chans != 1)

  00166	83 bc 24 1c 01
	00 00 01	 cmp	 DWORD PTR InputFile_Properties$[rsp+4], 1
  0016e	74 2d		 je	 SHORT $LN14@main

; 68   :     {
; 69   :         fprintf(stderr, "Error: Input file must be mono\n");

  00170	b9 02 00 00 00	 mov	 ecx, 2
  00175	e8 00 00 00 00	 call	 __acrt_iob_func
  0017a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7223
  00181	48 8b c8	 mov	 rcx, rax
  00184	e8 00 00 00 00	 call	 fprintf

; 70   :         ErrorCode++;

  00189	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  0018d	ff c0		 inc	 eax
  0018f	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 71   :         goto memory_cleanup;

  00193	e9 27 08 00 00	 jmp	 $LN15@main
  00198	e9 22 08 00 00	 jmp	 $memory_cleanup$57
$LN14@main:

; 72   :     }
; 73   : 
; 74   :     //Allocate memory for input file samples
; 75   :     FramesInput = (float*) malloc(BufferSize * InputFile_Properties.chans * sizeof(float));

  0019d	8b 44 24 7c	 mov	 eax, DWORD PTR BufferSize$[rsp]
  001a1	0f af 84 24 1c
	01 00 00	 imul	 eax, DWORD PTR InputFile_Properties$[rsp+4]
  001a9	8b c0		 mov	 eax, eax
  001ab	48 c1 e0 02	 shl	 rax, 2
  001af	48 8b c8	 mov	 rcx, rax
  001b2	e8 00 00 00 00	 call	 malloc
  001b7	48 89 44 24 68	 mov	 QWORD PTR FramesInput$[rsp], rax

; 76   : 
; 77   :     if(FramesInput == NULL)

  001bc	48 83 7c 24 68
	00		 cmp	 QWORD PTR FramesInput$[rsp], 0
  001c2	75 20		 jne	 SHORT $LN16@main

; 78   :     {
; 79   :         puts("Error: No memory\n"); //Puts uses less system memory than printf, applicable for severe memory errors

  001c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7226
  001cb	e8 00 00 00 00	 call	 puts

; 80   :         ErrorCode++;

  001d0	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  001d4	ff c0		 inc	 eax
  001d6	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 81   :         goto memory_cleanup;

  001da	e9 e0 07 00 00	 jmp	 $LN17@main
  001df	e9 db 07 00 00	 jmp	 $memory_cleanup$57
$LN16@main:

; 82   :     }
; 83   : 
; 84   :     //Check extension of output file name
; 85   : 
; 86   :     OutputFile_Format = psf_getFormatExt(argv[ARG_OUTFILE]);

  001e4	b8 08 00 00 00	 mov	 eax, 8
  001e9	48 6b c0 02	 imul	 rax, rax, 2
  001ed	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001f5	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  001f9	e8 00 00 00 00	 call	 psf_getFormatExt
  001fe	89 44 24 78	 mov	 DWORD PTR OutputFile_Format$[rsp], eax

; 87   : 
; 88   :     if(OutputFile_Format == PSF_FMT_UNKNOWN)

  00202	83 7c 24 78 00	 cmp	 DWORD PTR OutputFile_Format$[rsp], 0
  00207	75 52		 jne	 SHORT $LN18@main

; 89   :     {
; 90   :         fprintf(stderr, "Error: output file name %s has unknown format\n", argv[ARG_OUTFILE]);

  00209	b8 08 00 00 00	 mov	 eax, 8
  0020e	48 6b c0 02	 imul	 rax, rax, 2
  00212	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv146[rsp], rax
  0021a	b9 02 00 00 00	 mov	 ecx, 2
  0021f	e8 00 00 00 00	 call	 __acrt_iob_func
  00224	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0022c	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR tv146[rsp]
  00234	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  00238	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7229
  0023f	48 8b c8	 mov	 rcx, rax
  00242	e8 00 00 00 00	 call	 fprintf

; 91   :         ErrorCode++;

  00247	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  0024b	ff c0		 inc	 eax
  0024d	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 92   :         goto memory_cleanup;

  00251	e9 69 07 00 00	 jmp	 $LN19@main
  00256	e9 64 07 00 00	 jmp	 $memory_cleanup$57
$LN18@main:

; 93   :     }
; 94   : 
; 95   :     //Copy struct from input file to output file
; 96   :     InputFile_Properties.format = OutputFile_Format;

  0025b	8b 44 24 78	 mov	 eax, DWORD PTR OutputFile_Format$[rsp]
  0025f	89 84 24 24 01
	00 00		 mov	 DWORD PTR InputFile_Properties$[rsp+12], eax

; 97   :     OutputFile_Properties = InputFile_Properties;

  00266	48 8d 84 24 30
	01 00 00	 lea	 rax, QWORD PTR OutputFile_Properties$[rsp]
  0026e	48 8d 8c 24 18
	01 00 00	 lea	 rcx, QWORD PTR InputFile_Properties$[rsp]
  00276	48 8b f8	 mov	 rdi, rax
  00279	48 8b f1	 mov	 rsi, rcx
  0027c	b9 14 00 00 00	 mov	 ecx, 20
  00281	f3 a4		 rep movsb

; 98   : 
; 99   :     //Breakpoint file processing
; 100  :     //Open text file
; 101  :     BreakpointFile = fopen(argv[ARG_BREAKPOINT_FILE], "r");

  00283	b8 08 00 00 00	 mov	 eax, 8
  00288	48 6b c0 03	 imul	 rax, rax, 3
  0028c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7231
  00293	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0029b	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0029f	e8 00 00 00 00	 call	 fopen
  002a4	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR BreakpointFile$[rsp], rax

; 102  :     
; 103  :     if(BreakpointFile == NULL)

  002ac	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR BreakpointFile$[rsp], 0
  002b5	75 52		 jne	 SHORT $LN20@main

; 104  :     {
; 105  :         fprintf(stderr, "Error: Unable to open breakpoint file %s\n", argv[ARG_BREAKPOINT_FILE]);

  002b7	b8 08 00 00 00	 mov	 eax, 8
  002bc	48 6b c0 03	 imul	 rax, rax, 3
  002c0	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv160[rsp], rax
  002c8	b9 02 00 00 00	 mov	 ecx, 2
  002cd	e8 00 00 00 00	 call	 __acrt_iob_func
  002d2	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002da	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR tv160[rsp]
  002e2	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  002e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7233
  002ed	48 8b c8	 mov	 rcx, rax
  002f0	e8 00 00 00 00	 call	 fprintf

; 106  :         ErrorCode++;

  002f5	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  002f9	ff c0		 inc	 eax
  002fb	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 107  :         goto memory_cleanup;

  002ff	e9 bb 06 00 00	 jmp	 $LN21@main
  00304	e9 b6 06 00 00	 jmp	 $memory_cleanup$57
$LN20@main:

; 108  :     }    
; 109  : 
; 110  :     //Call function to gather breakpoints
; 111  :     BreakpointFile_Size = 0;

  00309	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR BreakpointFile_Size$[rsp], 0

; 112  :     ReadPoints = breakpoint_get_breakpoints(BreakpointFile, &BreakpointFile_Size);

  00311	48 8d 54 24 58	 lea	 rdx, QWORD PTR BreakpointFile_Size$[rsp]
  00316	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR BreakpointFile$[rsp]
  0031e	e8 00 00 00 00	 call	 ?breakpoint_get_breakpoints@@YAPEAUBreakpointFormat@@PEAU_iobuf@@PEAK@Z ; breakpoint_get_breakpoints
  00323	48 89 44 24 50	 mov	 QWORD PTR ReadPoints$[rsp], rax

; 113  : 
; 114  :     if(ReadPoints == NULL)

  00328	48 83 7c 24 50
	00		 cmp	 QWORD PTR ReadPoints$[rsp], 0
  0032e	75 2d		 jne	 SHORT $LN22@main

; 115  :     {
; 116  :         fprintf(stderr, "Error: No breakpoints read\n");

  00330	b9 02 00 00 00	 mov	 ecx, 2
  00335	e8 00 00 00 00	 call	 __acrt_iob_func
  0033a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7236
  00341	48 8b c8	 mov	 rcx, rax
  00344	e8 00 00 00 00	 call	 fprintf

; 117  :         ErrorCode++;

  00349	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  0034d	ff c0		 inc	 eax
  0034f	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 118  :         goto memory_cleanup;

  00353	e9 67 06 00 00	 jmp	 $LN23@main
  00358	e9 62 06 00 00	 jmp	 $memory_cleanup$57
$LN22@main:

; 119  :     }
; 120  : 
; 121  :     //Check number of breakpoints in file
; 122  :     if(BreakpointFile_Size < 2)

  0035d	83 7c 24 58 02	 cmp	 DWORD PTR BreakpointFile_Size$[rsp], 2
  00362	73 2d		 jae	 SHORT $LN24@main

; 123  :     {
; 124  :         fprintf(stderr, "Error: At least two breakpoints required\n");

  00364	b9 02 00 00 00	 mov	 ecx, 2
  00369	e8 00 00 00 00	 call	 __acrt_iob_func
  0036e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7239
  00375	48 8b c8	 mov	 rcx, rax
  00378	e8 00 00 00 00	 call	 fprintf

; 125  :         ErrorCode++;

  0037d	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  00381	ff c0		 inc	 eax
  00383	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 126  :         goto memory_cleanup;

  00387	e9 33 06 00 00	 jmp	 $LN25@main
  0038c	e9 2e 06 00 00	 jmp	 $memory_cleanup$57
$LN24@main:

; 127  :     }
; 128  : 
; 129  :     //Check if first time value isn't 0
; 130  :     if(ReadPoints[0].BreakpointTime != 0.0)

  00391	b8 10 00 00 00	 mov	 eax, 16
  00396	48 6b c0 00	 imul	 rax, rax, 0
  0039a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ReadPoints$[rsp]
  0039f	f2 0f 10 04 01	 movsd	 xmm0, QWORD PTR [rcx+rax]
  003a4	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  003ac	7a 02		 jp	 SHORT $LN55@main
  003ae	74 55		 je	 SHORT $LN26@main
$LN55@main:

; 131  :     {
; 132  :         fprintf(stderr, "Error: First breakpoint time (%lf) must start from 0\n", ReadPoints[0].BreakpointTime);

  003b0	b8 10 00 00 00	 mov	 eax, 16
  003b5	48 6b c0 00	 imul	 rax, rax, 0
  003b9	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv187[rsp], rax
  003c1	b9 02 00 00 00	 mov	 ecx, 2
  003c6	e8 00 00 00 00	 call	 __acrt_iob_func
  003cb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ReadPoints$[rsp]
  003d0	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR tv187[rsp]
  003d8	f2 0f 10 14 11	 movsd	 xmm2, QWORD PTR [rcx+rdx]
  003dd	66 49 0f 7e d0	 movq	 r8, xmm2
  003e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7242
  003e9	48 8b c8	 mov	 rcx, rax
  003ec	e8 00 00 00 00	 call	 fprintf

; 133  :         ErrorCode++;

  003f1	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  003f5	ff c0		 inc	 eax
  003f7	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 134  :         goto memory_cleanup;

  003fb	e9 bf 05 00 00	 jmp	 $LN27@main
  00400	e9 ba 05 00 00	 jmp	 $memory_cleanup$57
$LN26@main:

; 135  :     }
; 136  : 
; 137  :     //Check if breakpoint values are out of range
; 138  :     if(!breakpoint_inputfile_range_check(ReadPoints, 0.0, 1.0, BreakpointFile_Size))

  00405	44 8b 4c 24 58	 mov	 r9d, DWORD PTR BreakpointFile_Size$[rsp]
  0040a	f2 0f 10 15 00
	00 00 00	 movsd	 xmm2, QWORD PTR __real@3ff0000000000000
  00412	0f 57 c9	 xorps	 xmm1, xmm1
  00415	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ReadPoints$[rsp]
  0041a	e8 00 00 00 00	 call	 ?breakpoint_inputfile_range_check@@YAHPEBUBreakpointFormat@@NNK@Z ; breakpoint_inputfile_range_check
  0041f	85 c0		 test	 eax, eax
  00421	75 2d		 jne	 SHORT $LN28@main

; 139  :     {
; 140  :         fprintf(stderr, "Error: Breakpoint values out of range\n");

  00423	b9 02 00 00 00	 mov	 ecx, 2
  00428	e8 00 00 00 00	 call	 __acrt_iob_func
  0042d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7245
  00434	48 8b c8	 mov	 rcx, rax
  00437	e8 00 00 00 00	 call	 fprintf

; 141  :         ErrorCode++;

  0043c	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  00440	ff c0		 inc	 eax
  00442	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 142  :         goto memory_cleanup;

  00446	e9 74 05 00 00	 jmp	 $LN29@main
  0044b	e9 6f 05 00 00	 jmp	 $memory_cleanup$57
$LN28@main:

; 143  :     } 
; 144  :        
; 145  :     //Stage 4: Process output file
; 146  :     //Allocate memory for the peak data of the output file
; 147  :     PeakData = (PSF_CHPEAK*) malloc(OutputFile_Properties.chans * sizeof(PSF_CHPEAK));

  00450	48 63 84 24 34
	01 00 00	 movsxd	 rax, DWORD PTR OutputFile_Properties$[rsp+4]
  00458	48 c1 e0 03	 shl	 rax, 3
  0045c	48 8b c8	 mov	 rcx, rax
  0045f	e8 00 00 00 00	 call	 malloc
  00464	48 89 44 24 70	 mov	 QWORD PTR PeakData$[rsp], rax

; 148  :     
; 149  :     if(PeakData == NULL)

  00469	48 83 7c 24 70
	00		 cmp	 QWORD PTR PeakData$[rsp], 0
  0046f	75 20		 jne	 SHORT $LN30@main

; 150  :     {
; 151  :         puts("Error: No memory\n");

  00471	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7248
  00478	e8 00 00 00 00	 call	 puts

; 152  :         ErrorCode++;

  0047d	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  00481	ff c0		 inc	 eax
  00483	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 153  :         goto memory_cleanup;

  00487	e9 33 05 00 00	 jmp	 $LN31@main
  0048c	e9 2e 05 00 00	 jmp	 $memory_cleanup$57
$LN30@main:

; 154  :     }
; 155  : 
; 156  :     //Create output file for for reading/writing
; 157  :     OutputFile = psf_sndCreate(argv[ARG_OUTFILE], &OutputFile_Properties, 0, 0, PSF_CREATE_RDWR);

  00491	b8 08 00 00 00	 mov	 eax, 8
  00496	48 6b c0 02	 imul	 rax, rax, 2
  0049a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  004a2	45 33 c9	 xor	 r9d, r9d
  004a5	45 33 c0	 xor	 r8d, r8d
  004a8	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR OutputFile_Properties$[rsp]
  004b0	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  004b8	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  004bc	e8 00 00 00 00	 call	 psf_sndCreate
  004c1	89 44 24 38	 mov	 DWORD PTR OutputFile$[rsp], eax

; 158  :     
; 159  :     if(OutputFile < 0)

  004c5	83 7c 24 38 00	 cmp	 DWORD PTR OutputFile$[rsp], 0
  004ca	7d 52		 jge	 SHORT $LN32@main

; 160  :     {
; 161  :         fprintf(stderr, "Error: Unable to create output file %s\n", argv[ARG_OUTFILE]);

  004cc	b8 08 00 00 00	 mov	 eax, 8
  004d1	48 6b c0 02	 imul	 rax, rax, 2
  004d5	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv226[rsp], rax
  004dd	b9 02 00 00 00	 mov	 ecx, 2
  004e2	e8 00 00 00 00	 call	 __acrt_iob_func
  004e7	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  004ef	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR tv226[rsp]
  004f7	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  004fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7251
  00502	48 8b c8	 mov	 rcx, rax
  00505	e8 00 00 00 00	 call	 fprintf

; 162  :         ErrorCode++;

  0050a	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  0050e	ff c0		 inc	 eax
  00510	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 163  :         goto memory_cleanup;

  00514	e9 a6 04 00 00	 jmp	 $LN33@main
  00519	e9 a1 04 00 00	 jmp	 $memory_cleanup$57
$LN32@main:

; 164  :     }    
; 165  :     
; 166  :     //Stage 5: Processing loop
; 167  :     printf("Info: Processing...\n");

  0051e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7253
  00525	e8 00 00 00 00	 call	 printf

; 168  : 
; 169  :     //Processed frames counter
; 170  :     FramesRead_Total = 0;

  0052a	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR FramesRead_Total$[rsp], 0

; 171  : 
; 172  :     //Initial time position for reading envelope
; 173  :     TimeIncrement = 1.0 / InputFile_Properties.srate;

  00532	f2 0f 2a 84 24
	18 01 00 00	 cvtsi2sd xmm0, DWORD PTR InputFile_Properties$[rsp]
  0053b	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  00543	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00547	0f 28 c1	 movaps	 xmm0, xmm1
  0054a	f2 0f 11 84 24
	e8 00 00 00	 movsd	 QWORD PTR TimeIncrement$[rsp], xmm0

; 174  :     
; 175  :     //Counters to track through breakpoint file
; 176  :     CurrentPosition = 0.0;

  00553	0f 57 c0	 xorps	 xmm0, xmm0
  00556	f2 0f 11 84 24
	90 00 00 00	 movsd	 QWORD PTR CurrentPosition$[rsp], xmm0

; 177  :     CounterLeft = 0;

  0055f	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR CounterLeft$[rsp], 0

; 178  :     CounterRight = 1;

  00567	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR CounterRight$[rsp], 1

; 179  : 
; 180  :     //Create first time span
; 181  :     LeftPoint = ReadPoints[CounterLeft];

  0056f	8b 44 24 5c	 mov	 eax, DWORD PTR CounterLeft$[rsp]
  00573	48 6b c0 10	 imul	 rax, rax, 16
  00577	48 8d 8c 24 58
	01 00 00	 lea	 rcx, QWORD PTR LeftPoint$[rsp]
  0057f	48 8b 54 24 50	 mov	 rdx, QWORD PTR ReadPoints$[rsp]
  00584	48 8b f9	 mov	 rdi, rcx
  00587	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  0058b	b9 10 00 00 00	 mov	 ecx, 16
  00590	f3 a4		 rep movsb

; 182  :     RightPoint = ReadPoints[CounterRight];

  00592	8b 44 24 3c	 mov	 eax, DWORD PTR CounterRight$[rsp]
  00596	48 6b c0 10	 imul	 rax, rax, 16
  0059a	48 8d 8c 24 48
	01 00 00	 lea	 rcx, QWORD PTR RightPoint$[rsp]
  005a2	48 8b 54 24 50	 mov	 rdx, QWORD PTR ReadPoints$[rsp]
  005a7	48 8b f9	 mov	 rdi, rcx
  005aa	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  005ae	b9 10 00 00 00	 mov	 ecx, 16
  005b3	f3 a4		 rep movsb

; 183  :     Width = RightPoint.BreakpointTime - LeftPoint.BreakpointTime;

  005b5	f2 0f 10 84 24
	48 01 00 00	 movsd	 xmm0, QWORD PTR RightPoint$[rsp]
  005be	f2 0f 5c 84 24
	58 01 00 00	 subsd	 xmm0, QWORD PTR LeftPoint$[rsp]
  005c7	f2 0f 11 84 24
	98 00 00 00	 movsd	 QWORD PTR Width$[rsp], xmm0

; 184  :     Height = RightPoint.BreakpointValue - LeftPoint.BreakpointValue; 

  005d0	f2 0f 10 84 24
	50 01 00 00	 movsd	 xmm0, QWORD PTR RightPoint$[rsp+8]
  005d9	f2 0f 5c 84 24
	60 01 00 00	 subsd	 xmm0, QWORD PTR LeftPoint$[rsp+8]
  005e2	f2 0f 11 84 24
	a0 00 00 00	 movsd	 QWORD PTR Height$[rsp], xmm0

; 185  :     MorePoints = 1;

  005eb	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR MorePoints$[rsp], 1
$LN2@main:

; 186  : 
; 187  :     //Main loop
; 188  :     while((FramesRead = psf_sndReadFloatFrames(InputFile, FramesInput, BufferSize)) > 0 )

  005f6	44 8b 44 24 7c	 mov	 r8d, DWORD PTR BufferSize$[rsp]
  005fb	48 8b 54 24 68	 mov	 rdx, QWORD PTR FramesInput$[rsp]
  00600	8b 4c 24 48	 mov	 ecx, DWORD PTR InputFile$[rsp]
  00604	e8 00 00 00 00	 call	 psf_sndReadFloatFrames
  00609	89 44 24 44	 mov	 DWORD PTR FramesRead$[rsp], eax
  0060d	83 7c 24 44 00	 cmp	 DWORD PTR FramesRead$[rsp], 0
  00612	0f 8e 44 02 00
	00		 jle	 $LN3@main

; 189  :     {
; 190  :         //Buffer processing
; 191  :         int Input_i;
; 192  :         double Amplitude, Fraction;
; 193  : 
; 194  :         for(Input_i = 0; Input_i < FramesRead; Input_i++)

  00618	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR Input_i$2[rsp], 0
  00620	eb 0a		 jmp	 SHORT $LN6@main
$LN4@main:
  00622	8b 44 24 40	 mov	 eax, DWORD PTR Input_i$2[rsp]
  00626	ff c0		 inc	 eax
  00628	89 44 24 40	 mov	 DWORD PTR Input_i$2[rsp], eax
$LN6@main:
  0062c	8b 44 24 44	 mov	 eax, DWORD PTR FramesRead$[rsp]
  00630	39 44 24 40	 cmp	 DWORD PTR Input_i$2[rsp], eax
  00634	0f 8d 90 01 00
	00		 jge	 $LN5@main

; 195  :         {
; 196  :             if(MorePoints)

  0063a	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR MorePoints$[rsp], 0
  00642	0f 84 52 01 00
	00		 je	 $LN34@main

; 197  :             {
; 198  :                 if(Width == 0.0)

  00648	f2 0f 10 84 24
	98 00 00 00	 movsd	 xmm0, QWORD PTR Width$[rsp]
  00651	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  00659	7a 16		 jp	 SHORT $LN35@main
  0065b	75 14		 jne	 SHORT $LN35@main

; 199  :                 {
; 200  :                     Amplitude = RightPoint.BreakpointValue;

  0065d	f2 0f 10 84 24
	50 01 00 00	 movsd	 xmm0, QWORD PTR RightPoint$[rsp+8]
  00666	f2 0f 11 84 24
	a8 00 00 00	 movsd	 QWORD PTR Amplitude$3[rsp], xmm0

; 201  :                 }
; 202  :     
; 203  :                 else

  0066f	eb 4f		 jmp	 SHORT $LN36@main
$LN35@main:

; 204  :                 {
; 205  :                     Fraction = (CurrentPosition - LeftPoint.BreakpointTime) / Width;

  00671	f2 0f 10 84 24
	90 00 00 00	 movsd	 xmm0, QWORD PTR CurrentPosition$[rsp]
  0067a	f2 0f 5c 84 24
	58 01 00 00	 subsd	 xmm0, QWORD PTR LeftPoint$[rsp]
  00683	f2 0f 5e 84 24
	98 00 00 00	 divsd	 xmm0, QWORD PTR Width$[rsp]
  0068c	f2 0f 11 84 24
	e0 00 00 00	 movsd	 QWORD PTR Fraction$4[rsp], xmm0

; 206  :                     Amplitude = LeftPoint.BreakpointValue + (Height * Fraction);

  00695	f2 0f 10 84 24
	a0 00 00 00	 movsd	 xmm0, QWORD PTR Height$[rsp]
  0069e	f2 0f 59 84 24
	e0 00 00 00	 mulsd	 xmm0, QWORD PTR Fraction$4[rsp]
  006a7	f2 0f 10 8c 24
	60 01 00 00	 movsd	 xmm1, QWORD PTR LeftPoint$[rsp+8]
  006b0	f2 0f 58 c8	 addsd	 xmm1, xmm0
  006b4	0f 28 c1	 movaps	 xmm0, xmm1
  006b7	f2 0f 11 84 24
	a8 00 00 00	 movsd	 QWORD PTR Amplitude$3[rsp], xmm0
$LN36@main:

; 207  :                 }
; 208  :     
; 209  :                 CurrentPosition += TimeIncrement;

  006c0	f2 0f 10 84 24
	90 00 00 00	 movsd	 xmm0, QWORD PTR CurrentPosition$[rsp]
  006c9	f2 0f 58 84 24
	e8 00 00 00	 addsd	 xmm0, QWORD PTR TimeIncrement$[rsp]
  006d2	f2 0f 11 84 24
	90 00 00 00	 movsd	 QWORD PTR CurrentPosition$[rsp], xmm0

; 210  :     
; 211  :                 //Check if end of span is reached, move to next
; 212  :                 if(CurrentPosition > RightPoint.BreakpointTime)

  006db	f2 0f 10 84 24
	90 00 00 00	 movsd	 xmm0, QWORD PTR CurrentPosition$[rsp]
  006e4	66 0f 2f 84 24
	48 01 00 00	 comisd	 xmm0, QWORD PTR RightPoint$[rsp]
  006ed	0f 86 a7 00 00
	00		 jbe	 $LN37@main

; 213  :                 {
; 214  :                     CounterLeft++;

  006f3	8b 44 24 5c	 mov	 eax, DWORD PTR CounterLeft$[rsp]
  006f7	ff c0		 inc	 eax
  006f9	89 44 24 5c	 mov	 DWORD PTR CounterLeft$[rsp], eax

; 215  :                     CounterRight++;

  006fd	8b 44 24 3c	 mov	 eax, DWORD PTR CounterRight$[rsp]
  00701	ff c0		 inc	 eax
  00703	89 44 24 3c	 mov	 DWORD PTR CounterRight$[rsp], eax

; 216  :     
; 217  :                     //Move to next span
; 218  :                     if(CounterRight < BreakpointFile_Size)

  00707	8b 44 24 58	 mov	 eax, DWORD PTR BreakpointFile_Size$[rsp]
  0070b	39 44 24 3c	 cmp	 DWORD PTR CounterRight$[rsp], eax
  0070f	73 7e		 jae	 SHORT $LN38@main

; 219  :                     {
; 220  :                         LeftPoint = ReadPoints[CounterLeft];

  00711	8b 44 24 5c	 mov	 eax, DWORD PTR CounterLeft$[rsp]
  00715	48 6b c0 10	 imul	 rax, rax, 16
  00719	48 8d 8c 24 58
	01 00 00	 lea	 rcx, QWORD PTR LeftPoint$[rsp]
  00721	48 8b 54 24 50	 mov	 rdx, QWORD PTR ReadPoints$[rsp]
  00726	48 8b f9	 mov	 rdi, rcx
  00729	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  0072d	b9 10 00 00 00	 mov	 ecx, 16
  00732	f3 a4		 rep movsb

; 221  :                         RightPoint = ReadPoints[CounterRight];

  00734	8b 44 24 3c	 mov	 eax, DWORD PTR CounterRight$[rsp]
  00738	48 6b c0 10	 imul	 rax, rax, 16
  0073c	48 8d 8c 24 48
	01 00 00	 lea	 rcx, QWORD PTR RightPoint$[rsp]
  00744	48 8b 54 24 50	 mov	 rdx, QWORD PTR ReadPoints$[rsp]
  00749	48 8b f9	 mov	 rdi, rcx
  0074c	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  00750	b9 10 00 00 00	 mov	 ecx, 16
  00755	f3 a4		 rep movsb

; 222  :                         Width = RightPoint.BreakpointTime - LeftPoint.BreakpointTime;

  00757	f2 0f 10 84 24
	48 01 00 00	 movsd	 xmm0, QWORD PTR RightPoint$[rsp]
  00760	f2 0f 5c 84 24
	58 01 00 00	 subsd	 xmm0, QWORD PTR LeftPoint$[rsp]
  00769	f2 0f 11 84 24
	98 00 00 00	 movsd	 QWORD PTR Width$[rsp], xmm0

; 223  :                         Height = RightPoint.BreakpointValue - LeftPoint.BreakpointValue; 

  00772	f2 0f 10 84 24
	50 01 00 00	 movsd	 xmm0, QWORD PTR RightPoint$[rsp+8]
  0077b	f2 0f 5c 84 24
	60 01 00 00	 subsd	 xmm0, QWORD PTR LeftPoint$[rsp+8]
  00784	f2 0f 11 84 24
	a0 00 00 00	 movsd	 QWORD PTR Height$[rsp], xmm0

; 224  :                     }
; 225  : 
; 226  :                     else

  0078d	eb 0b		 jmp	 SHORT $LN39@main
$LN38@main:

; 227  :                     {
; 228  :                         MorePoints = 0;

  0078f	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR MorePoints$[rsp], 0
$LN39@main:
$LN37@main:
$LN34@main:

; 229  :                     }
; 230  :                 }
; 231  :             }
; 232  : 
; 233  :             FramesInput[Input_i] = (float) (FramesInput[Input_i] * Amplitude);

  0079a	48 63 44 24 40	 movsxd	 rax, DWORD PTR Input_i$2[rsp]
  0079f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR FramesInput$[rsp]
  007a4	f3 0f 5a 04 81	 cvtss2sd xmm0, DWORD PTR [rcx+rax*4]
  007a9	f2 0f 59 84 24
	a8 00 00 00	 mulsd	 xmm0, QWORD PTR Amplitude$3[rsp]
  007b2	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  007b6	48 63 44 24 40	 movsxd	 rax, DWORD PTR Input_i$2[rsp]
  007bb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR FramesInput$[rsp]
  007c0	f3 0f 11 04 81	 movss	 DWORD PTR [rcx+rax*4], xmm0

; 234  :         }

  007c5	e9 58 fe ff ff	 jmp	 $LN4@main
$LN5@main:

; 235  : 
; 236  :         //Calculate total amount of frames read from the input file
; 237  :         FramesRead_Total++;

  007ca	8b 44 24 60	 mov	 eax, DWORD PTR FramesRead_Total$[rsp]
  007ce	ff c0		 inc	 eax
  007d0	89 44 24 60	 mov	 DWORD PTR FramesRead_Total$[rsp], eax

; 238  :         
; 239  :         //Update progress for every X number of samples
; 240  :         if(FramesRead_Total % BufferSize == 0)

  007d4	33 d2		 xor	 edx, edx
  007d6	8b 44 24 60	 mov	 eax, DWORD PTR FramesRead_Total$[rsp]
  007da	f7 74 24 7c	 div	 DWORD PTR BufferSize$[rsp]
  007de	8b c2		 mov	 eax, edx
  007e0	85 c0		 test	 eax, eax
  007e2	75 10		 jne	 SHORT $LN40@main

; 241  :         {
; 242  :             printf("Info: Copying %ld samples...\r", FramesRead_Total);

  007e4	8b 54 24 60	 mov	 edx, DWORD PTR FramesRead_Total$[rsp]
  007e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7261
  007ef	e8 00 00 00 00	 call	 printf
$LN40@main:

; 243  :         }
; 244  : 
; 245  :         //Check for errors writing to the output file
; 246  :         if(psf_sndWriteFloatFrames(OutputFile, FramesInput, FramesRead) != FramesRead)

  007f4	44 8b 44 24 44	 mov	 r8d, DWORD PTR FramesRead$[rsp]
  007f9	48 8b 54 24 68	 mov	 rdx, QWORD PTR FramesInput$[rsp]
  007fe	8b 4c 24 38	 mov	 ecx, DWORD PTR OutputFile$[rsp]
  00802	e8 00 00 00 00	 call	 psf_sndWriteFloatFrames
  00807	3b 44 24 44	 cmp	 eax, DWORD PTR FramesRead$[rsp]
  0080b	74 4a		 je	 SHORT $LN41@main

; 247  :         {
; 248  :             fprintf(stderr, "Error: Cannot write to ouput file %s\n", argv[ARG_OUTFILE]);

  0080d	b8 08 00 00 00	 mov	 eax, 8
  00812	48 6b c0 02	 imul	 rax, rax, 2
  00816	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv327[rsp], rax
  0081e	b9 02 00 00 00	 mov	 ecx, 2
  00823	e8 00 00 00 00	 call	 __acrt_iob_func
  00828	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00830	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR tv327[rsp]
  00838	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  0083c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7263
  00843	48 8b c8	 mov	 rcx, rax
  00846	e8 00 00 00 00	 call	 fprintf

; 249  :             ErrorCode++;

  0084b	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  0084f	ff c0		 inc	 eax
  00851	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 250  :             break;

  00855	eb 05		 jmp	 SHORT $LN3@main
$LN41@main:

; 251  :         }
; 252  :     }

  00857	e9 9a fd ff ff	 jmp	 $LN2@main
$LN3@main:

; 253  : 
; 254  :     if(FramesRead < 0)

  0085c	83 7c 24 44 00	 cmp	 DWORD PTR FramesRead$[rsp], 0
  00861	7d 6f		 jge	 SHORT $LN42@main

; 255  :     {
; 256  :         fprintf(stderr, "Error: Cannot read input file %s, output file %s is incomplete\n", argv[ARG_INFILE], argv[ARG_OUTFILE]);

  00863	b8 08 00 00 00	 mov	 eax, 8
  00868	48 6b c0 02	 imul	 rax, rax, 2
  0086c	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv336[rsp], rax
  00874	b9 08 00 00 00	 mov	 ecx, 8
  00879	48 6b c9 01	 imul	 rcx, rcx, 1
  0087d	48 89 8c 24 00
	01 00 00	 mov	 QWORD PTR tv339[rsp], rcx
  00885	b9 02 00 00 00	 mov	 ecx, 2
  0088a	e8 00 00 00 00	 call	 __acrt_iob_func
  0088f	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00897	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR tv336[rsp]
  0089f	4c 8b 0c 11	 mov	 r9, QWORD PTR [rcx+rdx]
  008a3	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  008ab	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR tv339[rsp]
  008b3	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  008b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG7266
  008be	48 8b c8	 mov	 rcx, rax
  008c1	e8 00 00 00 00	 call	 fprintf

; 257  :         ErrorCode++;

  008c6	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
  008ca	ff c0		 inc	 eax
  008cc	89 44 24 30	 mov	 DWORD PTR ErrorCode$[rsp], eax

; 258  :     }
; 259  : 
; 260  :     else

  008d0	eb 10		 jmp	 SHORT $LN43@main
$LN42@main:

; 261  :     {
; 262  :         printf("\nInfo: Done.\n"

  008d2	8b 54 24 30	 mov	 edx, DWORD PTR ErrorCode$[rsp]
  008d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7267
  008dd	e8 00 00 00 00	 call	 printf
$LN43@main:

; 263  :                "Info: %d errors\n", ErrorCode);
; 264  :     }
; 265  : 
; 266  :     //Stage 6: User reporting
; 267  :     //Check if any peak data was captured
; 268  :     if(psf_sndReadPeaks(OutputFile, PeakData, NULL) > 0)

  008e2	45 33 c0	 xor	 r8d, r8d
  008e5	48 8b 54 24 70	 mov	 rdx, QWORD PTR PeakData$[rsp]
  008ea	8b 4c 24 38	 mov	 ecx, DWORD PTR OutputFile$[rsp]
  008ee	e8 00 00 00 00	 call	 psf_sndReadPeaks
  008f3	85 c0		 test	 eax, eax
  008f5	0f 8e c4 00 00
	00		 jle	 $LN44@main

; 269  :     {
; 270  :         double PeakTime;
; 271  :         double PeakDB;
; 272  :         printf("Info: Peaks:\n");

  008fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7269
  00902	e8 00 00 00 00	 call	 printf

; 273  : 
; 274  :         //Loop for every channel in the input file
; 275  :         for (long i = 0; i < OutputFile_Properties.chans; i++)

  00907	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  0090f	eb 0a		 jmp	 SHORT $LN9@main
$LN7@main:
  00911	8b 44 24 34	 mov	 eax, DWORD PTR i$1[rsp]
  00915	ff c0		 inc	 eax
  00917	89 44 24 34	 mov	 DWORD PTR i$1[rsp], eax
$LN9@main:
  0091b	8b 84 24 34 01
	00 00		 mov	 eax, DWORD PTR OutputFile_Properties$[rsp+4]
  00922	39 44 24 34	 cmp	 DWORD PTR i$1[rsp], eax
  00926	0f 8d 93 00 00
	00		 jge	 $LN8@main

; 276  :         {
; 277  :             PeakTime = (double) PeakData[i].pos / (double) OutputFile_Properties.srate; //Calculate the time in seconds according the input file sample rate

  0092c	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$1[rsp]
  00931	48 8b 4c 24 70	 mov	 rcx, QWORD PTR PeakData$[rsp]
  00936	8b 44 c1 04	 mov	 eax, DWORD PTR [rcx+rax*8+4]
  0093a	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  0093f	f2 0f 2a 8c 24
	30 01 00 00	 cvtsi2sd xmm1, DWORD PTR OutputFile_Properties$[rsp]
  00948	f2 0f 5e c1	 divsd	 xmm0, xmm1
  0094c	f2 0f 11 84 24
	08 01 00 00	 movsd	 QWORD PTR PeakTime$5[rsp], xmm0

; 278  :             PeakDB = log10(PeakData[i].val); //Calculate dB values from linear values

  00955	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$1[rsp]
  0095a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR PeakData$[rsp]
  0095f	f3 0f 5a 04 c1	 cvtss2sd xmm0, DWORD PTR [rcx+rax*8]
  00964	e8 00 00 00 00	 call	 log10
  00969	f2 0f 11 84 24
	10 01 00 00	 movsd	 QWORD PTR PeakDB$6[rsp], xmm0

; 279  :             printf("Channel %d:\t%.4f (%.4f dB) at %.4f seconds\n", i + 1, PeakData[i].val, PeakDB, PeakTime);

  00972	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$1[rsp]
  00977	48 8b 4c 24 70	 mov	 rcx, QWORD PTR PeakData$[rsp]
  0097c	f3 0f 5a 04 c1	 cvtss2sd xmm0, DWORD PTR [rcx+rax*8]
  00981	8b 44 24 34	 mov	 eax, DWORD PTR i$1[rsp]
  00985	ff c0		 inc	 eax
  00987	f2 0f 10 8c 24
	08 01 00 00	 movsd	 xmm1, QWORD PTR PeakTime$5[rsp]
  00990	f2 0f 11 4c 24
	20		 movsd	 QWORD PTR [rsp+32], xmm1
  00996	f2 0f 10 9c 24
	10 01 00 00	 movsd	 xmm3, QWORD PTR PeakDB$6[rsp]
  0099f	66 49 0f 7e d9	 movq	 r9, xmm3
  009a4	0f 28 d0	 movaps	 xmm2, xmm0
  009a7	66 49 0f 7e d0	 movq	 r8, xmm2
  009ac	8b d0		 mov	 edx, eax
  009ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7270
  009b5	e8 00 00 00 00	 call	 printf

; 280  :         }

  009ba	e9 52 ff ff ff	 jmp	 $LN7@main
$LN8@main:
$LN44@main:
$LN13@main:
$LN15@main:
$LN17@main:
$LN19@main:
$LN21@main:
$LN23@main:
$LN25@main:
$LN27@main:
$LN29@main:
$LN31@main:
$LN33@main:
$memory_cleanup$57:

; 281  :     }
; 282  : 
; 283  :     //Stage 7: Cleanup
; 284  :     //Close all files and free all allocated memory
; 285  :     memory_cleanup:
; 286  : 
; 287  :     if(InputFile >= 0)

  009bf	83 7c 24 48 00	 cmp	 DWORD PTR InputFile$[rsp], 0
  009c4	7c 2a		 jl	 SHORT $LN45@main

; 288  :     {
; 289  :         if(psf_sndClose(InputFile));

  009c6	8b 4c 24 48	 mov	 ecx, DWORD PTR InputFile$[rsp]
  009ca	e8 00 00 00 00	 call	 psf_sndClose

; 290  :         {
; 291  :             printf("Warning: Problem closing input file %s\n", argv[ARG_INFILE]);

  009cf	b8 08 00 00 00	 mov	 eax, 8
  009d4	48 6b c0 01	 imul	 rax, rax, 1
  009d8	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  009e0	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  009e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7273
  009eb	e8 00 00 00 00	 call	 printf
$LN45@main:

; 292  :         }
; 293  :     }
; 294  : 
; 295  :     if(OutputFile >= 0)

  009f0	83 7c 24 38 00	 cmp	 DWORD PTR OutputFile$[rsp], 0
  009f5	7c 2a		 jl	 SHORT $LN47@main

; 296  :     {
; 297  :         if(psf_sndClose(OutputFile));

  009f7	8b 4c 24 38	 mov	 ecx, DWORD PTR OutputFile$[rsp]
  009fb	e8 00 00 00 00	 call	 psf_sndClose

; 298  :         {
; 299  :             printf("Warning: Problem closing output file %s\n", argv[ARG_OUTFILE]);

  00a00	b8 08 00 00 00	 mov	 eax, 8
  00a05	48 6b c0 02	 imul	 rax, rax, 2
  00a09	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00a11	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  00a15	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7276
  00a1c	e8 00 00 00 00	 call	 printf
$LN47@main:

; 300  :         }
; 301  :     }
; 302  :     
; 303  :     if(BreakpointFile)

  00a21	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR BreakpointFile$[rsp], 0
  00a2a	74 0d		 je	 SHORT $LN49@main

; 304  :     {
; 305  :         fclose(BreakpointFile);

  00a2c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR BreakpointFile$[rsp]
  00a34	e8 00 00 00 00	 call	 fclose
$LN49@main:

; 306  :     }
; 307  : 
; 308  :     if(FramesInput)

  00a39	48 83 7c 24 68
	00		 cmp	 QWORD PTR FramesInput$[rsp], 0
  00a3f	74 0a		 je	 SHORT $LN50@main

; 309  :     {
; 310  :         free(FramesInput);

  00a41	48 8b 4c 24 68	 mov	 rcx, QWORD PTR FramesInput$[rsp]
  00a46	e8 00 00 00 00	 call	 free
$LN50@main:

; 311  :     }
; 312  : 
; 313  :     if(FramesOutput)

  00a4b	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR FramesOutput$[rsp], 0
  00a54	74 0d		 je	 SHORT $LN51@main

; 314  :     {
; 315  :         free(FramesOutput);

  00a56	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR FramesOutput$[rsp]
  00a5e	e8 00 00 00 00	 call	 free
$LN51@main:

; 316  :     }
; 317  : 
; 318  :     if(PeakData)

  00a63	48 83 7c 24 70
	00		 cmp	 QWORD PTR PeakData$[rsp], 0
  00a69	74 0a		 je	 SHORT $LN52@main

; 319  :     {
; 320  :         free(PeakData);

  00a6b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR PeakData$[rsp]
  00a70	e8 00 00 00 00	 call	 free
$LN52@main:

; 321  :     }
; 322  : 
; 323  :     if(ReadPoints)

  00a75	48 83 7c 24 50
	00		 cmp	 QWORD PTR ReadPoints$[rsp], 0
  00a7b	74 0a		 je	 SHORT $LN53@main

; 324  :     {
; 325  :         free(ReadPoints);

  00a7d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ReadPoints$[rsp]
  00a82	e8 00 00 00 00	 call	 free
$LN53@main:

; 326  :     }
; 327  : 
; 328  :     //Close portsf library
; 329  :     psf_finish();

  00a87	e8 00 00 00 00	 call	 psf_finish

; 330  : 
; 331  :     return ErrorCode;

  00a8c	8b 44 24 30	 mov	 eax, DWORD PTR ErrorCode$[rsp]
$LN1@main:

; 332  : }

  00a90	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00a98	48 33 cc	 xor	 rcx, rsp
  00a9b	e8 00 00 00 00	 call	 __security_check_cookie
  00aa0	48 81 c4 78 01
	00 00		 add	 rsp, 376		; 00000178H
  00aa7	5f		 pop	 rdi
  00aa8	5e		 pop	 rsi
  00aa9	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 952  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 953  :         int _Result;
; 954  :         va_list _ArgList;
; 955  :         __crt_va_start(_ArgList, _Format);

  00018	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
  0001d	48 8d 44 24 48	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00022	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 956  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00027	b9 01 00 00 00	 mov	 ecx, 1
  0002c	e8 00 00 00 00	 call	 __acrt_iob_func
  00031	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00036	45 33 c0	 xor	 r8d, r8d
  00039	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Format$[rsp]
  0003e	48 8b c8	 mov	 rcx, rax
  00041	e8 00 00 00 00	 call	 _vfprintf_l
  00046	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 957  :         __crt_va_end(_ArgList);

  0004a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 958  :         return _Result;

  00053	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 959  :     }

  00057	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005b	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.11.25503\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>, COMDAT

; 151  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 152  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Stream$ = 64
_Format$ = 72
fprintf	PROC						; COMDAT

; 833  :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 834  :         int _Result;
; 835  :         va_list _ArgList;
; 836  :         __crt_va_start(_ArgList, _Format);

  00018	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
  0001d	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00022	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 837  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00027	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0002c	45 33 c0	 xor	 r8d, r8d
  0002f	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Stream$[rsp]
  00039	e8 00 00 00 00	 call	 _vfprintf_l
  0003e	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 838  :         __crt_va_end(_ArgList);

  00042	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 839  :         return _Result;

  0004b	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 840  :     }

  0004f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00053	c3		 ret	 0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 640  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 641  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	e8 00 00 00 00	 call	 __stdio_common_vfprintf

; 642  :     }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 86   :         static unsigned __int64 _OptionsStorage;
; 87   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 88   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
