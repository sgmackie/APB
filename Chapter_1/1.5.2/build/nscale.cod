; Listing generated by Microsoft (R) Optimizing Compiler Version 19.11.25507.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG7761	DB	'Usage: nscale notes midinote', 0aH, 00H
	ORG $+2
$SG7763	DB	'Error: notes must be positive', 0aH, 00H
	ORG $+1
$SG7765	DB	'Error: notes cannot be bigger than 24', 0aH, 00H
	ORG $+1
$SG7767	DB	'Error: cannot have negative MIDI notes', 0aH, 00H
$SG7769	DB	'Error: maximum MIDI note is 127', 0aH, 00H
	ORG $+3
$SG7770	DB	'%d:%f', 0aH, 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	main
PUBLIC	__real@3fb5555555555555
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@4008000000000000
PUBLIC	__real@4014000000000000
PUBLIC	__real@406b800000000000
EXTRN	__acrt_iob_func:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	atoi:PROC
EXTRN	pow:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$printf
pdata	ENDS
pdata	SEGMENT
$pdata$main DD	imagerel $LN14
	DD	imagerel $LN14+606
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT __real@406b800000000000
CONST	SEGMENT
__real@406b800000000000 DQ 0406b800000000000r	; 220
CONST	ENDS
;	COMDAT __real@4014000000000000
CONST	SEGMENT
__real@4014000000000000 DQ 04014000000000000r	; 5
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fb5555555555555
CONST	SEGMENT
__real@3fb5555555555555 DQ 03fb5555555555555r	; 0.0833333
CONST	ENDS
xdata	SEGMENT
$unwind$main DD	022219H
	DD	0250110H
	DD	imagerel __GSHandlerCheck
	DD	0110H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\chapter_1\1.5.2\code\nscale.c
_TEXT	SEGMENT
i$ = 32
notes$ = 36
counter$ = 40
midinote$ = 44
ratio$ = 48
frequency$ = 56
c5$ = 64
c0$ = 72
intervals$ = 80
__$ArrayPad$ = 272
argc$ = 304
argv$ = 312
main	PROC

; 8    : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 9    : 	//Declare  variables
; 10   : 	
; 11   : 	int notes, midinote, i, counter;
; 12   : 	double frequency, ratio, c0, c5;
; 13   : 	double intervals[24];
; 14   : 	int test;
; 15   : 	
; 16   : 	//Argument number check
; 17   : 	
; 18   : 	if(argc != 3)

  00022	83 bc 24 30 01
	00 00 03	 cmp	 DWORD PTR argc$[rsp], 3
  0002a	74 16		 je	 SHORT $LN8@main

; 19   : 	{
; 20   : 		printf("Usage: nscale notes midinote\n");

  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7761
  00033	e8 00 00 00 00	 call	 printf

; 21   : 		return 1;

  00038	b8 01 00 00 00	 mov	 eax, 1
  0003d	e9 04 02 00 00	 jmp	 $LN1@main
$LN8@main:

; 22   : 	}
; 23   : 	
; 24   : 	notes = atoi(argv[1]);

  00042	b8 08 00 00 00	 mov	 eax, 8
  00047	48 6b c0 01	 imul	 rax, rax, 1
  0004b	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00053	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00057	e8 00 00 00 00	 call	 atoi
  0005c	89 44 24 24	 mov	 DWORD PTR notes$[rsp], eax

; 25   : 	
; 26   : 	//Check 1st argument
; 27   : 	
; 28   : 	if(notes < 1)

  00060	83 7c 24 24 01	 cmp	 DWORD PTR notes$[rsp], 1
  00065	7d 16		 jge	 SHORT $LN9@main

; 29   : 	{
; 30   : 		printf("Error: notes must be positive\n");

  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7763
  0006e	e8 00 00 00 00	 call	 printf

; 31   : 		return 1;

  00073	b8 01 00 00 00	 mov	 eax, 1
  00078	e9 c9 01 00 00	 jmp	 $LN1@main
$LN9@main:

; 32   : 	}
; 33   : 		
; 34   : 	if(notes > 24)

  0007d	83 7c 24 24 18	 cmp	 DWORD PTR notes$[rsp], 24
  00082	7e 16		 jle	 SHORT $LN10@main

; 35   : 	{
; 36   : 		printf("Error: notes cannot be bigger than 24\n");

  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7765
  0008b	e8 00 00 00 00	 call	 printf

; 37   : 		return 1;

  00090	b8 01 00 00 00	 mov	 eax, 1
  00095	e9 ac 01 00 00	 jmp	 $LN1@main
$LN10@main:

; 38   : 	}
; 39   : 	
; 40   : 	midinote = atoi(argv[2]);

  0009a	b8 08 00 00 00	 mov	 eax, 8
  0009f	48 6b c0 02	 imul	 rax, rax, 2
  000a3	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000ab	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  000af	e8 00 00 00 00	 call	 atoi
  000b4	89 44 24 2c	 mov	 DWORD PTR midinote$[rsp], eax

; 41   : 	
; 42   : 	//Check 2nd argument
; 43   : 	
; 44   : 	if(midinote < 0)

  000b8	83 7c 24 2c 00	 cmp	 DWORD PTR midinote$[rsp], 0
  000bd	7d 16		 jge	 SHORT $LN11@main

; 45   : 	{
; 46   : 		printf("Error: cannot have negative MIDI notes\n");

  000bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7767
  000c6	e8 00 00 00 00	 call	 printf

; 47   : 		return 1;

  000cb	b8 01 00 00 00	 mov	 eax, 1
  000d0	e9 71 01 00 00	 jmp	 $LN1@main
$LN11@main:

; 48   : 	}
; 49   : 	
; 50   : 	if(midinote > 127)

  000d5	83 7c 24 2c 7f	 cmp	 DWORD PTR midinote$[rsp], 127 ; 0000007fH
  000da	7e 16		 jle	 SHORT $LN12@main

; 51   : 	{
; 52   : 		printf("Error: maximum MIDI note is 127\n");

  000dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7769
  000e3	e8 00 00 00 00	 call	 printf

; 53   : 		return 1;

  000e8	b8 01 00 00 00	 mov	 eax, 1
  000ed	e9 54 01 00 00	 jmp	 $LN1@main
$LN12@main:

; 54   : 	}
; 55   : 	
; 56   : 	//Calculation
; 57   : 	
; 58   : 	ratio = pow(2.0, 1.0/12.0);

  000f2	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3fb5555555555555
  000fa	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4000000000000000
  00102	e8 00 00 00 00	 call	 pow
  00107	f2 0f 11 44 24
	30		 movsd	 QWORD PTR ratio$[rsp], xmm0

; 59   : 	c5 = 220.0 * pow(ratio, 3);

  0010d	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4008000000000000
  00115	f2 0f 10 44 24
	30		 movsd	 xmm0, QWORD PTR ratio$[rsp]
  0011b	e8 00 00 00 00	 call	 pow
  00120	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@406b800000000000
  00128	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  0012c	0f 28 c1	 movaps	 xmm0, xmm1
  0012f	f2 0f 11 44 24
	40		 movsd	 QWORD PTR c5$[rsp], xmm0

; 60   : 	c0 = c5 * pow(0.5, 5);

  00135	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4014000000000000
  0013d	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00145	e8 00 00 00 00	 call	 pow
  0014a	f2 0f 10 4c 24
	40		 movsd	 xmm1, QWORD PTR c5$[rsp]
  00150	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00154	0f 28 c1	 movaps	 xmm0, xmm1
  00157	f2 0f 11 44 24
	48		 movsd	 QWORD PTR c0$[rsp], xmm0

; 61   : 	frequency = c0 * pow(ratio, midinote);

  0015d	f2 0f 2a 44 24
	2c		 cvtsi2sd xmm0, DWORD PTR midinote$[rsp]
  00163	0f 28 c8	 movaps	 xmm1, xmm0
  00166	f2 0f 10 44 24
	30		 movsd	 xmm0, QWORD PTR ratio$[rsp]
  0016c	e8 00 00 00 00	 call	 pow
  00171	f2 0f 10 4c 24
	48		 movsd	 xmm1, QWORD PTR c0$[rsp]
  00177	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  0017b	0f 28 c1	 movaps	 xmm0, xmm1
  0017e	f2 0f 11 44 24
	38		 movsd	 QWORD PTR frequency$[rsp], xmm0

; 62   : 	
; 63   : 	ratio = pow(2.0,1.0/ notes);

  00184	f2 0f 2a 44 24
	24		 cvtsi2sd xmm0, DWORD PTR notes$[rsp]
  0018a	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  00192	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00196	0f 28 c1	 movaps	 xmm0, xmm1
  00199	0f 28 c8	 movaps	 xmm1, xmm0
  0019c	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4000000000000000
  001a4	e8 00 00 00 00	 call	 pow
  001a9	f2 0f 11 44 24
	30		 movsd	 QWORD PTR ratio$[rsp], xmm0

; 64   : 	
; 65   : 	for(i = 0; i < notes; i++)

  001af	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001b7	eb 0a		 jmp	 SHORT $LN4@main
$LN2@main:
  001b9	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001bd	ff c0		 inc	 eax
  001bf	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@main:
  001c3	8b 44 24 24	 mov	 eax, DWORD PTR notes$[rsp]
  001c7	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  001cb	7d 25		 jge	 SHORT $LN3@main

; 66   : 	{
; 67   : 		intervals[i] = frequency;

  001cd	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  001d2	f2 0f 10 44 24
	38		 movsd	 xmm0, QWORD PTR frequency$[rsp]
  001d8	f2 0f 11 44 c4
	50		 movsd	 QWORD PTR intervals$[rsp+rax*8], xmm0

; 68   : 		frequency *= ratio;

  001de	f2 0f 10 44 24
	38		 movsd	 xmm0, QWORD PTR frequency$[rsp]
  001e4	f2 0f 59 44 24
	30		 mulsd	 xmm0, QWORD PTR ratio$[rsp]
  001ea	f2 0f 11 44 24
	38		 movsd	 QWORD PTR frequency$[rsp], xmm0

; 69   : 	}

  001f0	eb c7		 jmp	 SHORT $LN2@main
$LN3@main:

; 70   : 	
; 71   : 	//Read array and printf
; 72   : 	
; 73   : 	for(i = 0, counter = 0; i < notes, counter < notes; i++, counter++)

  001f2	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001fa	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR counter$[rsp], 0
  00202	eb 14		 jmp	 SHORT $LN7@main
$LN5@main:
  00204	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00208	ff c0		 inc	 eax
  0020a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0020e	8b 44 24 28	 mov	 eax, DWORD PTR counter$[rsp]
  00212	ff c0		 inc	 eax
  00214	89 44 24 28	 mov	 DWORD PTR counter$[rsp], eax
$LN7@main:
  00218	8b 44 24 24	 mov	 eax, DWORD PTR notes$[rsp]
  0021c	39 44 24 28	 cmp	 DWORD PTR counter$[rsp], eax
  00220	7d 22		 jge	 SHORT $LN6@main

; 74   : 	{
; 75   : 		printf("%d:%f\n", counter, intervals[i]);

  00222	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00227	f2 0f 10 54 c4
	50		 movsd	 xmm2, QWORD PTR intervals$[rsp+rax*8]
  0022d	66 49 0f 7e d0	 movq	 r8, xmm2
  00232	8b 54 24 28	 mov	 edx, DWORD PTR counter$[rsp]
  00236	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7770
  0023d	e8 00 00 00 00	 call	 printf

; 76   : 	}

  00242	eb c0		 jmp	 SHORT $LN5@main
$LN6@main:

; 77   : 	
; 78   : 	return 0;

  00244	33 c0		 xor	 eax, eax
$LN1@main:

; 79   : }

  00246	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0024e	48 33 cc	 xor	 rcx, rsp
  00251	e8 00 00 00 00	 call	 __security_check_cookie
  00256	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  0025d	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 952  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 953  :         int _Result;
; 954  :         va_list _ArgList;
; 955  :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 48	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 956  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00022	b9 01 00 00 00	 mov	 ecx, 1
  00027	e8 00 00 00 00	 call	 __acrt_iob_func
  0002c	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00031	45 33 c0	 xor	 r8d, r8d
  00034	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Format$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 _vfprintf_l
  00041	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 957  :         __crt_va_end(_ArgList);

  00045	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 958  :         return _Result;

  0004e	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 959  :     }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 640  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 641  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	e8 00 00 00 00	 call	 __stdio_common_vfprintf

; 642  :     }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 86   :         static unsigned __int64 _OptionsStorage;
; 87   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 88   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
