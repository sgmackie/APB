; Listing generated by Microsoft (R) Optimizing Compiler Version 19.11.25507.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG6733	DB	'%lf%lf', 00H
	ORG $+1
$SG6736	DB	'Line &d has non-nummeric data', 0aH, 00H
	ORG $+1
$SG6738	DB	'Incomplete breakpoint found at point %d', 0aH, 00H
	ORG $+3
$SG6760	DB	'r', 00H
	ORG $+2
$SG6740	DB	'Data error at point %d: Time no inscreasing', 0aH, 00H
	ORG $+3
$SG6757	DB	'breakdur: Find duration of breakpoint file', 0aH, 00H
	ORG $+4
$SG6759	DB	'Usage: breakdur inputfile.txt ', 0aH, 00H
$SG6762	DB	'Unable to open file', 0aH, 00H
	ORG $+3
$SG6764	DB	'No breakpoints read', 0aH, 00H
	ORG $+3
$SG6766	DB	'Error, at least two breakpoints required', 0aH, 00H
	ORG $+6
$SG6768	DB	'First breakpoint breakpoint_time must be 0.0', 0aH, 00H
	ORG $+2
$SG6769	DB	'Read %d breakpoints', 0aH, 00H
	ORG $+3
$SG6770	DB	'Duration: %f seconds', 0aH, 00H
	ORG $+2
$SG6771	DB	'Maximum breakpoint_value: %f at %f secs', 0aH, 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	breakpoint_max_point_value
PUBLIC	get_breakpoints
PUBLIC	main
PUBLIC	__real@0000000000000000
EXTRN	__acrt_iob_func:PROC
EXTRN	fclose:PROC
EXTRN	fgets:PROC
EXTRN	fopen:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	__stdio_common_vsscanf:PROC
EXTRN	free:PROC
EXTRN	malloc:PROC
EXTRN	realloc:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$breakpoint_max_point_value DD imagerel $LN7
	DD	imagerel $LN7+236
	DD	imagerel $unwind$breakpoint_max_point_value
$pdata$get_breakpoints DD imagerel $LN15
	DD	imagerel $LN15+532
	DD	imagerel $unwind$get_breakpoints
$pdata$main DD	imagerel $LN9
	DD	imagerel $LN9+513
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
xdata	SEGMENT
$unwind$breakpoint_max_point_value DD 032419H
	DD	070114215H
	DD	06010H
	DD	imagerel __GSHandlerCheck
	DD	018H
$unwind$get_breakpoints DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$main DD	031e19H
	DD	0700be20fH
	DD	0600aH
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\chapter_1\1.7.3\code\breakdur.c
_TEXT	SEGMENT
array_size$ = 32
points$ = 40
fp$ = 48
dur$ = 56
$T1 = 64
point$ = 80
__$ArrayPad$ = 96
argc$ = 144
argv$ = 152
main	PROC

; 117  : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00016	48 33 c4	 xor	 rax, rsp
  00019	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 118  :     long array_size;
; 119  :     double dur;
; 120  :     BREAKPOINT_FORMAT point, *points;
; 121  :     FILE* fp;
; 122  : 
; 123  :     printf("breakdur: Find duration of breakpoint file\n");

  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG6757
  00025	e8 00 00 00 00	 call	 printf

; 124  : 
; 125  :     if(argc < 0)

  0002a	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR argc$[rsp], 0
  00032	7d 16		 jge	 SHORT $LN2@main

; 126  :     {
; 127  :         printf("Usage: breakdur inputfile.txt \n");

  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG6759
  0003b	e8 00 00 00 00	 call	 printf

; 128  :         return 1;

  00040	b8 01 00 00 00	 mov	 eax, 1
  00045	e9 a3 01 00 00	 jmp	 $LN1@main
$LN2@main:

; 129  :     }
; 130  : 
; 131  :     fp = fopen(argv[1], "r");

  0004a	b8 08 00 00 00	 mov	 eax, 8
  0004f	48 6b c0 01	 imul	 rax, rax, 1
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG6760
  0005a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00062	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00066	e8 00 00 00 00	 call	 fopen
  0006b	48 89 44 24 30	 mov	 QWORD PTR fp$[rsp], rax

; 132  :     if(fp == NULL)

  00070	48 83 7c 24 30
	00		 cmp	 QWORD PTR fp$[rsp], 0
  00076	75 16		 jne	 SHORT $LN3@main

; 133  :     {   
; 134  :         printf("Unable to open file\n");

  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG6762
  0007f	e8 00 00 00 00	 call	 printf

; 135  :         return 1;

  00084	b8 01 00 00 00	 mov	 eax, 1
  00089	e9 5f 01 00 00	 jmp	 $LN1@main
$LN3@main:

; 136  :     }
; 137  : 
; 138  :     array_size = 0;

  0008e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR array_size$[rsp], 0

; 139  :     points = get_breakpoints(fp, &array_size);

  00096	48 8d 54 24 20	 lea	 rdx, QWORD PTR array_size$[rsp]
  0009b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fp$[rsp]
  000a0	e8 00 00 00 00	 call	 get_breakpoints
  000a5	48 89 44 24 28	 mov	 QWORD PTR points$[rsp], rax

; 140  : 
; 141  :     if(points == NULL)

  000aa	48 83 7c 24 28
	00		 cmp	 QWORD PTR points$[rsp], 0
  000b0	75 20		 jne	 SHORT $LN4@main

; 142  :     {
; 143  :         printf("No breakpoints read\n");

  000b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG6764
  000b9	e8 00 00 00 00	 call	 printf

; 144  :         fclose(fp);

  000be	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fp$[rsp]
  000c3	e8 00 00 00 00	 call	 fclose

; 145  :         return 1;

  000c8	b8 01 00 00 00	 mov	 eax, 1
  000cd	e9 1b 01 00 00	 jmp	 $LN1@main
$LN4@main:

; 146  :     }
; 147  : 
; 148  :     if(array_size < 2)

  000d2	83 7c 24 20 02	 cmp	 DWORD PTR array_size$[rsp], 2
  000d7	7d 2a		 jge	 SHORT $LN5@main

; 149  :     {
; 150  :         printf("Error, at least two breakpoints required\n");

  000d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG6766
  000e0	e8 00 00 00 00	 call	 printf

; 151  :         free(points);

  000e5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR points$[rsp]
  000ea	e8 00 00 00 00	 call	 free

; 152  :         fclose(fp);

  000ef	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fp$[rsp]
  000f4	e8 00 00 00 00	 call	 fclose

; 153  :         return 1;

  000f9	b8 01 00 00 00	 mov	 eax, 1
  000fe	e9 ea 00 00 00	 jmp	 $LN1@main
$LN5@main:

; 154  :     }
; 155  : 
; 156  :     if(points[0].breakpoint_time != 0.0)

  00103	b8 10 00 00 00	 mov	 eax, 16
  00108	48 6b c0 00	 imul	 rax, rax, 0
  0010c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR points$[rsp]
  00111	f2 0f 10 04 01	 movsd	 xmm0, QWORD PTR [rcx+rax]
  00116	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  0011e	7a 02		 jp	 SHORT $LN8@main
  00120	74 2a		 je	 SHORT $LN6@main
$LN8@main:

; 157  :     {
; 158  :         printf("First breakpoint breakpoint_time must be 0.0\n");

  00122	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG6768
  00129	e8 00 00 00 00	 call	 printf

; 159  :         free(points);

  0012e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR points$[rsp]
  00133	e8 00 00 00 00	 call	 free

; 160  :         fclose(fp);

  00138	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fp$[rsp]
  0013d	e8 00 00 00 00	 call	 fclose

; 161  :         return 1;

  00142	b8 01 00 00 00	 mov	 eax, 1
  00147	e9 a1 00 00 00	 jmp	 $LN1@main
$LN6@main:

; 162  :     }
; 163  : 
; 164  :     printf("Read %d breakpoints\n", array_size);

  0014c	8b 54 24 20	 mov	 edx, DWORD PTR array_size$[rsp]
  00150	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG6769
  00157	e8 00 00 00 00	 call	 printf

; 165  :     dur = points[array_size-1].breakpoint_time;

  0015c	8b 44 24 20	 mov	 eax, DWORD PTR array_size$[rsp]
  00160	ff c8		 dec	 eax
  00162	48 98		 cdqe
  00164	48 6b c0 10	 imul	 rax, rax, 16
  00168	48 8b 4c 24 28	 mov	 rcx, QWORD PTR points$[rsp]
  0016d	f2 0f 10 04 01	 movsd	 xmm0, QWORD PTR [rcx+rax]
  00172	f2 0f 11 44 24
	38		 movsd	 QWORD PTR dur$[rsp], xmm0

; 166  :     printf("Duration: %f seconds\n", dur);

  00178	f2 0f 10 4c 24
	38		 movsd	 xmm1, QWORD PTR dur$[rsp]
  0017e	66 48 0f 7e ca	 movq	 rdx, xmm1
  00183	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG6770
  0018a	e8 00 00 00 00	 call	 printf

; 167  :     point = breakpoint_max_point_value(points, array_size);

  0018f	44 8b 44 24 20	 mov	 r8d, DWORD PTR array_size$[rsp]
  00194	48 8b 54 24 28	 mov	 rdx, QWORD PTR points$[rsp]
  00199	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T1[rsp]
  0019e	e8 00 00 00 00	 call	 breakpoint_max_point_value
  001a3	48 8d 4c 24 50	 lea	 rcx, QWORD PTR point$[rsp]
  001a8	48 8b f9	 mov	 rdi, rcx
  001ab	48 8b f0	 mov	 rsi, rax
  001ae	b9 10 00 00 00	 mov	 ecx, 16
  001b3	f3 a4		 rep movsb

; 168  :     printf("Maximum breakpoint_value: %f at %f secs\n", point.breakpoint_value, point.breakpoint_time);

  001b5	f2 0f 10 54 24
	50		 movsd	 xmm2, QWORD PTR point$[rsp]
  001bb	66 49 0f 7e d0	 movq	 r8, xmm2
  001c0	f2 0f 10 4c 24
	58		 movsd	 xmm1, QWORD PTR point$[rsp+8]
  001c6	66 48 0f 7e ca	 movq	 rdx, xmm1
  001cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG6771
  001d2	e8 00 00 00 00	 call	 printf

; 169  :     
; 170  :     free(points);

  001d7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR points$[rsp]
  001dc	e8 00 00 00 00	 call	 free

; 171  :     fclose(fp);

  001e1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fp$[rsp]
  001e6	e8 00 00 00 00	 call	 fclose

; 172  : 
; 173  :     return 0;

  001eb	33 c0		 xor	 eax, eax
$LN1@main:

; 174  : }

  001ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001f2	48 33 cc	 xor	 rcx, rsp
  001f5	e8 00 00 00 00	 call	 __security_check_cookie
  001fa	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001fe	5f		 pop	 rdi
  001ff	5e		 pop	 rsi
  00200	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\chapter_1\1.7.3\code\breakdur.c
_TEXT	SEGMENT
total_points$ = 32
array_size$ = 36
points$ = 40
text_file_output$ = 48
lasttime$ = 56
tmp$1 = 64
breakpoint_line$ = 80
__$ArrayPad$ = 160
fp$ = 192
psize$ = 200
get_breakpoints PROC

; 38   : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 39   :     int text_file_output;
; 40   :     long total_points = 0, array_size = 64;

  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR total_points$[rsp], 0
  0002b	c7 44 24 24 40
	00 00 00	 mov	 DWORD PTR array_size$[rsp], 64 ; 00000040H

; 41   :     double lasttime = 0.0;

  00033	0f 57 c0	 xorps	 xmm0, xmm0
  00036	f2 0f 11 44 24
	38		 movsd	 QWORD PTR lasttime$[rsp], xmm0

; 42   :     BREAKPOINT_FORMAT* points = NULL;

  0003c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR points$[rsp], 0

; 43   :     char breakpoint_line[80];
; 44   : 
; 45   :     //If file fails to open
; 46   :     if(fp == NULL)

  00045	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR fp$[rsp], 0
  0004e	75 07		 jne	 SHORT $LN4@get_breakp

; 47   :     {
; 48   :         return NULL;

  00050	33 c0		 xor	 eax, eax
  00052	e9 a5 01 00 00	 jmp	 $LN1@get_breakp
$LN4@get_breakp:

; 49   :     }
; 50   : 
; 51   :     points = (BREAKPOINT_FORMAT*) malloc(sizeof(BREAKPOINT_FORMAT) * array_size);

  00057	48 63 44 24 24	 movsxd	 rax, DWORD PTR array_size$[rsp]
  0005c	48 6b c0 10	 imul	 rax, rax, 16
  00060	48 8b c8	 mov	 rcx, rax
  00063	e8 00 00 00 00	 call	 malloc
  00068	48 89 44 24 28	 mov	 QWORD PTR points$[rsp], rax

; 52   : 
; 53   :     if(points == NULL)

  0006d	48 83 7c 24 28
	00		 cmp	 QWORD PTR points$[rsp], 0
  00073	75 07		 jne	 SHORT $LN5@get_breakp

; 54   :     {
; 55   :         return NULL;

  00075	33 c0		 xor	 eax, eax
  00077	e9 80 01 00 00	 jmp	 $LN1@get_breakp
$LN5@get_breakp:
$LN14@get_breakp:
$LN2@get_breakp:

; 56   :     }
; 57   : 
; 58   :     while(fgets(breakpoint_line, 80, fp))

  0007c	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR fp$[rsp]
  00084	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  00089	48 8d 4c 24 50	 lea	 rcx, QWORD PTR breakpoint_line$[rsp]
  0008e	e8 00 00 00 00	 call	 fgets
  00093	48 85 c0	 test	 rax, rax
  00096	0f 84 46 01 00
	00		 je	 $LN3@get_breakp

; 59   :     {
; 60   :         text_file_output = sscanf(breakpoint_line, "%lf%lf", &points[total_points].breakpoint_time, &points[total_points].breakpoint_value);

  0009c	48 63 44 24 20	 movsxd	 rax, DWORD PTR total_points$[rsp]
  000a1	48 6b c0 10	 imul	 rax, rax, 16
  000a5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR points$[rsp]
  000aa	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  000af	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR total_points$[rsp]
  000b4	48 6b c9 10	 imul	 rcx, rcx, 16
  000b8	48 8b 54 24 28	 mov	 rdx, QWORD PTR points$[rsp]
  000bd	48 03 d1	 add	 rdx, rcx
  000c0	48 8b ca	 mov	 rcx, rdx
  000c3	4c 8b c8	 mov	 r9, rax
  000c6	4c 8b c1	 mov	 r8, rcx
  000c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG6733
  000d0	48 8d 4c 24 50	 lea	 rcx, QWORD PTR breakpoint_line$[rsp]
  000d5	e8 00 00 00 00	 call	 sscanf
  000da	89 44 24 30	 mov	 DWORD PTR text_file_output$[rsp], eax

; 61   : 
; 62   :         //Check if empty breakpoint_line in text file, contine loop if there is
; 63   :         if(text_file_output < 0)

  000de	83 7c 24 30 00	 cmp	 DWORD PTR text_file_output$[rsp], 0
  000e3	7d 02		 jge	 SHORT $LN6@get_breakp

; 64   :         {
; 65   :             continue;

  000e5	eb 95		 jmp	 SHORT $LN2@get_breakp
$LN6@get_breakp:

; 66   :         }
; 67   :         
; 68   :         if(text_file_output == 0)

  000e7	83 7c 24 30 00	 cmp	 DWORD PTR text_file_output$[rsp], 0
  000ec	75 19		 jne	 SHORT $LN7@get_breakp

; 69   :         {
; 70   :             printf("Line &d has non-nummeric data\n", total_points+1);

  000ee	8b 44 24 20	 mov	 eax, DWORD PTR total_points$[rsp]
  000f2	ff c0		 inc	 eax
  000f4	8b d0		 mov	 edx, eax
  000f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG6736
  000fd	e8 00 00 00 00	 call	 printf

; 71   :             break;

  00102	e9 db 00 00 00	 jmp	 $LN3@get_breakp
$LN7@get_breakp:

; 72   :         }
; 73   :    
; 74   :         if(text_file_output == 1)

  00107	83 7c 24 30 01	 cmp	 DWORD PTR text_file_output$[rsp], 1
  0010c	75 19		 jne	 SHORT $LN8@get_breakp

; 75   :         {
; 76   :             printf("Incomplete breakpoint found at point %d\n", total_points+1);

  0010e	8b 44 24 20	 mov	 eax, DWORD PTR total_points$[rsp]
  00112	ff c0		 inc	 eax
  00114	8b d0		 mov	 edx, eax
  00116	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG6738
  0011d	e8 00 00 00 00	 call	 printf

; 77   :             break;

  00122	e9 bb 00 00 00	 jmp	 $LN3@get_breakp
$LN8@get_breakp:

; 78   :         }
; 79   : 
; 80   :         if(points[total_points].breakpoint_time < lasttime)

  00127	48 63 44 24 20	 movsxd	 rax, DWORD PTR total_points$[rsp]
  0012c	48 6b c0 10	 imul	 rax, rax, 16
  00130	48 8b 4c 24 28	 mov	 rcx, QWORD PTR points$[rsp]
  00135	f2 0f 10 44 24
	38		 movsd	 xmm0, QWORD PTR lasttime$[rsp]
  0013b	66 0f 2f 04 01	 comisd	 xmm0, QWORD PTR [rcx+rax]
  00140	76 19		 jbe	 SHORT $LN9@get_breakp

; 81   :         {
; 82   :             printf("Data error at point %d: Time no inscreasing\n", total_points+1);

  00142	8b 44 24 20	 mov	 eax, DWORD PTR total_points$[rsp]
  00146	ff c0		 inc	 eax
  00148	8b d0		 mov	 edx, eax
  0014a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG6740
  00151	e8 00 00 00 00	 call	 printf

; 83   :             break;

  00156	e9 87 00 00 00	 jmp	 $LN3@get_breakp
$LN9@get_breakp:

; 84   :         }
; 85   : 
; 86   :         lasttime = points[total_points].breakpoint_time;

  0015b	48 63 44 24 20	 movsxd	 rax, DWORD PTR total_points$[rsp]
  00160	48 6b c0 10	 imul	 rax, rax, 16
  00164	48 8b 4c 24 28	 mov	 rcx, QWORD PTR points$[rsp]
  00169	f2 0f 10 04 01	 movsd	 xmm0, QWORD PTR [rcx+rax]
  0016e	f2 0f 11 44 24
	38		 movsd	 QWORD PTR lasttime$[rsp], xmm0

; 87   : 
; 88   :         if(++total_points == array_size)

  00174	8b 44 24 20	 mov	 eax, DWORD PTR total_points$[rsp]
  00178	ff c0		 inc	 eax
  0017a	89 44 24 20	 mov	 DWORD PTR total_points$[rsp], eax
  0017e	8b 44 24 24	 mov	 eax, DWORD PTR array_size$[rsp]
  00182	39 44 24 20	 cmp	 DWORD PTR total_points$[rsp], eax
  00186	75 55		 jne	 SHORT $LN10@get_breakp

; 89   :         {
; 90   :             BREAKPOINT_FORMAT* tmp;
; 91   :             array_size += NPOINTS;

  00188	8b 44 24 24	 mov	 eax, DWORD PTR array_size$[rsp]
  0018c	83 c0 40	 add	 eax, 64			; 00000040H
  0018f	89 44 24 24	 mov	 DWORD PTR array_size$[rsp], eax

; 92   :         
; 93   :             tmp = (BREAKPOINT_FORMAT*) realloc(points, sizeof(BREAKPOINT_FORMAT) *array_size);

  00193	48 63 44 24 24	 movsxd	 rax, DWORD PTR array_size$[rsp]
  00198	48 6b c0 10	 imul	 rax, rax, 16
  0019c	48 8b d0	 mov	 rdx, rax
  0019f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR points$[rsp]
  001a4	e8 00 00 00 00	 call	 realloc
  001a9	48 89 44 24 40	 mov	 QWORD PTR tmp$1[rsp], rax

; 94   : 
; 95   :             //Release all memory
; 96   :             if(tmp == NULL)

  001ae	48 83 7c 24 40
	00		 cmp	 QWORD PTR tmp$1[rsp], 0
  001b4	75 1d		 jne	 SHORT $LN11@get_breakp

; 97   :             {
; 98   :                 total_points = 0;

  001b6	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR total_points$[rsp], 0

; 99   :                 free(points);

  001be	48 8b 4c 24 28	 mov	 rcx, QWORD PTR points$[rsp]
  001c3	e8 00 00 00 00	 call	 free

; 100  :                 points = NULL;

  001c8	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR points$[rsp], 0

; 101  :                 break;

  001d1	eb 0f		 jmp	 SHORT $LN3@get_breakp
$LN11@get_breakp:

; 102  :             }
; 103  : 
; 104  :             points = tmp;

  001d3	48 8b 44 24 40	 mov	 rax, QWORD PTR tmp$1[rsp]
  001d8	48 89 44 24 28	 mov	 QWORD PTR points$[rsp], rax
$LN10@get_breakp:

; 105  :         }
; 106  :     }

  001dd	e9 9a fe ff ff	 jmp	 $LN14@get_breakp
$LN3@get_breakp:

; 107  :     if(total_points)

  001e2	83 7c 24 20 00	 cmp	 DWORD PTR total_points$[rsp], 0
  001e7	74 0e		 je	 SHORT $LN12@get_breakp

; 108  :     {
; 109  :         *psize = total_points;

  001e9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR psize$[rsp]
  001f1	8b 4c 24 20	 mov	 ecx, DWORD PTR total_points$[rsp]
  001f5	89 08		 mov	 DWORD PTR [rax], ecx
$LN12@get_breakp:

; 110  :     }    
; 111  : 
; 112  :     return points;

  001f7	48 8b 44 24 28	 mov	 rax, QWORD PTR points$[rsp]
$LN1@get_breakp:

; 113  : }

  001fc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00204	48 33 cc	 xor	 rcx, rsp
  00207	e8 00 00 00 00	 call	 __security_check_cookie
  0020c	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00213	c3		 ret	 0
get_breakpoints ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File k:\audio\editing\current\programming\the_audio_programming_book\test_code\chapter_1\1.7.3\code\breakdur.c
_TEXT	SEGMENT
i$ = 0
point$ = 8
__$ArrayPad$ = 24
$T1 = 64
points$ = 72
total_points$ = 80
breakpoint_max_point_value PROC

; 15   : {

$LN7:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 44 24 18	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 16   :     int i;
; 17   :     BREAKPOINT_FORMAT point;
; 18   : 
; 19   :     //Start from first point
; 20   :     point.breakpoint_time = points[0].breakpoint_time;

  00024	b8 10 00 00 00	 mov	 eax, 16
  00029	48 6b c0 00	 imul	 rax, rax, 0
  0002d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR points$[rsp]
  00032	f2 0f 10 04 01	 movsd	 xmm0, QWORD PTR [rcx+rax]
  00037	f2 0f 11 44 24
	08		 movsd	 QWORD PTR point$[rsp], xmm0

; 21   :     point.breakpoint_value = points[0].breakpoint_value;

  0003d	b8 10 00 00 00	 mov	 eax, 16
  00042	48 6b c0 00	 imul	 rax, rax, 0
  00046	48 8b 4c 24 48	 mov	 rcx, QWORD PTR points$[rsp]
  0004b	f2 0f 10 44 01
	08		 movsd	 xmm0, QWORD PTR [rcx+rax+8]
  00051	f2 0f 11 44 24
	10		 movsd	 QWORD PTR point$[rsp+8], xmm0

; 22   : 
; 23   :     for(i = 0; i < total_points; i++)

  00057	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  0005e	eb 08		 jmp	 SHORT $LN4@breakpoint
$LN2@breakpoint:
  00060	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00063	ff c0		 inc	 eax
  00065	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@breakpoint:
  00068	8b 44 24 50	 mov	 eax, DWORD PTR total_points$[rsp]
  0006c	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  0006f	7d 4e		 jge	 SHORT $LN3@breakpoint

; 24   :     {
; 25   :         if(point.breakpoint_value < points[i].breakpoint_value)

  00071	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00075	48 6b c0 10	 imul	 rax, rax, 16
  00079	48 8b 4c 24 48	 mov	 rcx, QWORD PTR points$[rsp]
  0007e	f2 0f 10 44 01
	08		 movsd	 xmm0, QWORD PTR [rcx+rax+8]
  00084	66 0f 2f 44 24
	10		 comisd	 xmm0, QWORD PTR point$[rsp+8]
  0008a	76 31		 jbe	 SHORT $LN5@breakpoint

; 26   :         {
; 27   :             point.breakpoint_value = points[i].breakpoint_value;

  0008c	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00090	48 6b c0 10	 imul	 rax, rax, 16
  00094	48 8b 4c 24 48	 mov	 rcx, QWORD PTR points$[rsp]
  00099	f2 0f 10 44 01
	08		 movsd	 xmm0, QWORD PTR [rcx+rax+8]
  0009f	f2 0f 11 44 24
	10		 movsd	 QWORD PTR point$[rsp+8], xmm0

; 28   :             point.breakpoint_time = points[i].breakpoint_time; 

  000a5	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000a9	48 6b c0 10	 imul	 rax, rax, 16
  000ad	48 8b 4c 24 48	 mov	 rcx, QWORD PTR points$[rsp]
  000b2	f2 0f 10 04 01	 movsd	 xmm0, QWORD PTR [rcx+rax]
  000b7	f2 0f 11 44 24
	08		 movsd	 QWORD PTR point$[rsp], xmm0
$LN5@breakpoint:

; 29   :         }
; 30   :     }

  000bd	eb a1		 jmp	 SHORT $LN2@breakpoint
$LN3@breakpoint:

; 31   : 
; 32   :     return point;

  000bf	48 8d 44 24 08	 lea	 rax, QWORD PTR point$[rsp]
  000c4	48 8b 7c 24 40	 mov	 rdi, QWORD PTR $T1[rsp]
  000c9	48 8b f0	 mov	 rsi, rax
  000cc	b9 10 00 00 00	 mov	 ecx, 16
  000d1	f3 a4		 rep movsb
  000d3	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]

; 33   : }

  000d8	48 8b 4c 24 18	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000dd	48 33 cc	 xor	 rcx, rsp
  000e0	e8 00 00 00 00	 call	 __security_check_cookie
  000e5	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000e9	5f		 pop	 rdi
  000ea	5e		 pop	 rsi
  000eb	c3		 ret	 0
breakpoint_max_point_value ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2267 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2268 :         int _Result;
; 2269 :         va_list _ArgList;
; 2270 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2271 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2272 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2273 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2274 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2172 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2173 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	e8 00 00 00 00	 call	 __stdio_common_vsscanf

; 2174 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2175 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2176 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 952  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 953  :         int _Result;
; 954  :         va_list _ArgList;
; 955  :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 48	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 956  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00022	b9 01 00 00 00	 mov	 ecx, 1
  00027	e8 00 00 00 00	 call	 __acrt_iob_func
  0002c	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00031	45 33 c0	 xor	 r8d, r8d
  00034	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Format$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 _vfprintf_l
  00041	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 957  :         __crt_va_end(_ArgList);

  00045	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 958  :         return _Result;

  0004e	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 959  :     }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 640  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 641  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	e8 00 00 00 00	 call	 __stdio_common_vfprintf

; 642  :     }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 95   :         static unsigned __int64 _OptionsStorage;
; 96   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 97   :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 86   :         static unsigned __int64 _OptionsStorage;
; 87   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 88   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
